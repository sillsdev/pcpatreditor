// Copyright (c) 2021-2022 SIL International 
// This software is licensed under the LGPL, version 2.1 or later 
// (http://www.gnu.org/licenses/lgpl-2.1.html) 
/**
 * 
 */
package org.sil.pcpatreditor.pcpatrgrammar;

import static org.junit.Assert.*;

import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;

import org.antlr.v4.runtime.CharStream;
import org.antlr.v4.runtime.CharStreams;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.tree.ParseTree;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.sil.pcpatreditor.Constants;
import org.sil.pcpatreditor.pcpatrgrammar.PcPatrGrammarErrorListener.VerboseListener;
import org.sil.pcpatreditor.pcpatrgrammar.antlr4generated.PcPatrGrammarLexer;
import org.sil.pcpatreditor.pcpatrgrammar.antlr4generated.PcPatrGrammarParser;

public class PcPatrGrammarRecognizerTest {

	@Before
	public void setUp() throws Exception {
	}

	@After
	public void tearDown() throws Exception {
	}

	@Test
	public void validDescriptionsTest() {
		checkValidGrammar(
				"rule\n S = NP VP",
				"(patrgrammar (patrRules (patrRule (ruleKW rule) (phraseStructureRule (constituent S) (ruleDef =) (rightHandSide (constituent NP) (constituent VP))))) <EOF>)");
		checkValidGrammar(
				"rule | comment after 'rule'\n S = NP VP",
				"(patrgrammar (patrRules (patrRule (ruleKW rule) (comment | comment after 'rule'\\n) (phraseStructureRule (constituent S) (ruleDef =) (rightHandSide (constituent NP) (constituent VP))))) <EOF>)");
		checkValidGrammar(
				"rule {basic rule test}\nS = NP VP\n",
				"(patrgrammar (patrRules (patrRule (ruleKW rule) (ruleIdentifier { basic rule test }) (phraseStructureRule (constituent S) (ruleDef =) (rightHandSide (constituent NP) (constituent VP))))) <EOF>)");
		checkValidGrammar(
				" | This is a comment\nrule {basic with just NP}\nS=NP ",
				"(patrgrammar (comment | This is a comment\\n) (patrRules (patrRule (ruleKW rule) (ruleIdentifier { basic with just NP }) (phraseStructureRule (constituent S) (ruleDef =) (rightHandSide (constituent NP))))) <EOF>)");
		checkValidGrammar(
				" | This is a comment\nrule {basic with just NP} | comment after id\nS=NP ",
				"(patrgrammar (comment | This is a comment\\n) (patrRules (patrRule (ruleKW rule) (ruleIdentifier { basic with just NP }) (comment | comment after id\\n) (phraseStructureRule (constituent S) (ruleDef =) (rightHandSide (constituent NP))))) <EOF>)");
		checkValidGrammar(
				"rule S = NP VP | comment after psr\n",
				"(patrgrammar (patrRules (patrRule (ruleKW rule) (phraseStructureRule (constituent S) (ruleDef =) (rightHandSide (constituent NP) (constituent VP))) (comment | comment after psr\\n))) <EOF>)");
		checkValidGrammar(
				"rule S = NP VP | comment after psr",
				"(patrgrammar (patrRules (patrRule (ruleKW rule) (phraseStructureRule (constituent S) (ruleDef =) (rightHandSide (constituent NP) (constituent VP))) (comment | comment after psr))) <EOF>)");
		checkValidGrammar(
				"rule\n S = NP_1 V NP_2",
				"(patrgrammar (patrRules (patrRule (ruleKW rule) (phraseStructureRule (constituent S) (ruleDef =) (rightHandSide (constituent NP_1) (constituent V) (constituent NP_2))))) <EOF>)");
		checkValidGrammar("rule {testing}\r\n"
				+ "S = AdvP / DP    |/ VP / PP "
				, "(patrgrammar (patrRules (patrRule (ruleKW rule) (ruleIdentifier { testing }) (phraseStructureRule (constituent S) (ruleDef =) (rightHandSide (constituent AdvP) (disjunctionConstituents / (constituent DP) (comment |/ VP / PP )))))) <EOF>)");
		checkValidGrammar(
				"rule\n S = NP_1 V (NP_2 ({Adv / Adj (P)}))",
				"(patrgrammar (patrRules (patrRule (ruleKW rule) (phraseStructureRule (constituent S) (ruleDef =) (rightHandSide (constituent NP_1) (constituent V) (optionalConstituents ( (constituent NP_2) (optionalConstituents ( (disjunctiveConstituents { (constituent Adv) (disjunctionConstituents / (constituent Adj) (optionalConstituents ( (constituent P) ))) }) )) )))))) <EOF>)");
		checkValidGrammar(
				"rule\n S = NP VP\n<S head cat> = <VP head cat>",
				"(patrgrammar (patrRules (patrRule (ruleKW rule) (phraseStructureRule (constituent S) (ruleDef =) (rightHandSide (constituent NP) (constituent VP))) (constraints (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent S) (featurePath (atomicValue head) (featurePath (atomicValue cat))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (constituent VP) (featurePath (atomicValue head) (featurePath (atomicValue cat))) (closingWedge >)))))) <EOF>)");
		// Following Let statements based on ones in the PcPatr documentation
		checkValidGrammar(
				"Let singular be [number:sg]\nrule\n S = NP VP\n",
				"(patrgrammar (featureTemplates (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue singular)) be) (featureStructureTemplateBody (featureStructure (openingBracket [) (featureStructureName (atomicValue number)) : (featureStructureValue (atomicValue sg)) (closingBracket ]))))) (patrRules (patrRule (ruleKW rule) (phraseStructureRule (constituent S) (ruleDef =) (rightHandSide (constituent NP) (constituent VP))))) <EOF>)");
		checkValidGrammar(
				"Let singular be <number> = sg\nrule\n S = NP VP\n",
				"(patrgrammar (featureTemplates (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue singular)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue number)) (closingWedge >)) = (featureTemplateValue (atomicValue sg))))) (patrRules (patrRule (ruleKW rule) (phraseStructureRule (constituent S) (ruleDef =) (rightHandSide (constituent NP) (constituent VP))))) <EOF>)");
		checkValidGrammar(
				"Let 3sg be [tense:pres\nagr:3sg\nfinite:+\nvform:S]\nrule\n S = NP VP\n",
				"(patrgrammar (featureTemplates (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue 3sg)) be) (featureStructureTemplateBody (featureStructure (openingBracket [) (featureStructureName (atomicValue tense)) : (featureStructureValue (atomicValue pres)) (embeddedFeatureStructure (featureStructureName (atomicValue agr)) : (featureStructureValue (atomicValue 3sg))) (embeddedFeatureStructure (featureStructureName (atomicValue finite)) : (featureStructureValue (atomicValue +))) (embeddedFeatureStructure (featureStructureName (atomicValue vform)) : (featureStructureValue (atomicValue S))) (closingBracket ]))))) (patrRules (patrRule (ruleKW rule) (phraseStructureRule (constituent S) (ruleDef =) (rightHandSide (constituent NP) (constituent VP))))) <EOF>)");
		checkValidGrammar(
				"Let 3sg be <tense> = pres\n<agr> = 3sg\n<finite> = +\n<vform> = S\nrule\n S = NP VP\n",
				"(patrgrammar (featureTemplates (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue 3sg)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue tense)) (closingWedge >)) = (featureTemplateValue (atomicValue pres)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue agr)) (closingWedge >)) = (featureTemplateValue (atomicValue 3sg)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue finite)) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue vform)) (closingWedge >)) = (featureTemplateValue (atomicValue S)))))))) (patrRules (patrRule (ruleKW rule) (phraseStructureRule (constituent S) (ruleDef =) (rightHandSide (constituent NP) (constituent VP))))) <EOF>)");
		checkValidGrammar(
				"Let singular be <number> = sg\nLet irreg be <reg> = -\n[singular]\nrule\n S = NP VP\n",
				"(patrgrammar (featureTemplates (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue singular)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue number)) (closingWedge >)) = (featureTemplateValue (atomicValue sg)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue irreg)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue reg)) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue singular)) ]))))) (patrRules (patrRule (ruleKW rule) (phraseStructureRule (constituent S) (ruleDef =) (rightHandSide (constituent NP) (constituent VP))))) <EOF>)");
		checkValidGrammar(
				"Let singular be <number> = sg\nLet irreg be <reg> = -\nsingular\nrule\n S = NP VP\n",
				"(patrgrammar (featureTemplates (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue singular)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue number)) (closingWedge >)) = (featureTemplateValue (atomicValue sg)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue irreg)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue reg)) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featureTemplateAbbreviation (featureTemplateName (atomicValue singular))))))) (patrRules (patrRule (ruleKW rule) (phraseStructureRule (constituent S) (ruleDef =) (rightHandSide (constituent NP) (constituent VP))))) <EOF>)");
		checkValidGrammar(
				"Let sg-pl be {[number:sg]\n[number:pl]}\nrule\n S = NP VP\n",
				"(patrgrammar (featureTemplates (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue sg-pl)) be) (featurePathTemplateBody (featureTemplateDisjunction (openingBrace {) (featurePathOrStructure (featureStructure (openingBracket [) (featureStructureName (atomicValue number)) : (featureStructureValue (atomicValue sg)) (closingBracket ]))) (featurePathOrStructure (featureStructure (openingBracket [) (featureStructureName (atomicValue number)) : (featureStructureValue (atomicValue pl)) (closingBracket ]))) (closingBrace }))))) (patrRules (patrRule (ruleKW rule) (phraseStructureRule (constituent S) (ruleDef =) (rightHandSide (constituent NP) (constituent VP))))) <EOF>)");
		checkValidGrammar(
				"Let sg/pl be {[number:sg]\n[number:pl]}\nrule\n S = NP VP\n",
				"(patrgrammar (featureTemplates (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue sg) / (atomicValue pl)) be) (featurePathTemplateBody (featureTemplateDisjunction (openingBrace {) (featurePathOrStructure (featureStructure (openingBracket [) (featureStructureName (atomicValue number)) : (featureStructureValue (atomicValue sg)) (closingBracket ]))) (featurePathOrStructure (featureStructure (openingBracket [) (featureStructureName (atomicValue number)) : (featureStructureValue (atomicValue pl)) (closingBracket ]))) (closingBrace }))))) (patrRules (patrRule (ruleKW rule) (phraseStructureRule (constituent S) (ruleDef =) (rightHandSide (constituent NP) (constituent VP))))) <EOF>)");
		checkValidGrammar(
				"Let sg/pl be <number> = {sg pl}\nrule\n S = NP VP\n",
				"(patrgrammar (featureTemplates (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue sg) / (atomicValue pl)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue number)) (closingWedge >)) = (atomicValueDisjunction (openingBrace {) (atomicValue sg) (atomicValue pl) (closingBrace }))))) (patrRules (patrRule (ruleKW rule) (phraseStructureRule (constituent S) (ruleDef =) (rightHandSide (constituent NP) (constituent VP))))) <EOF>)");
		checkValidGrammar(
				"Let sg be <number> = sg\nLet pl be <number> = pl\nLet sg/pl be {sg pl}\nrule\n S = NP VP\n",
				"(patrgrammar (featureTemplates (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue sg)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue number)) (closingWedge >)) = (featureTemplateValue (atomicValue sg)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue pl)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue number)) (closingWedge >)) = (featureTemplateValue (atomicValue pl)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue sg) / (atomicValue pl)) be) (featurePathTemplateBody (featureTemplateDisjunction (openingBrace {) (featurePathOrStructure (featurePath (atomicValue sg))) (featurePathOrStructure (featurePath (atomicValue pl))) (closingBrace }))))) (patrRules (patrRule (ruleKW rule) (phraseStructureRule (constituent S) (ruleDef =) (rightHandSide (constituent NP) (constituent VP))))) <EOF>)");
		checkValidGrammar(
				"Let sg be <number> = sg\nLet pl be <number> = pl\nLet sg/pl be {[sg] [pl]}\nrule\n S = NP VP\n",
				"(patrgrammar (featureTemplates (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue sg)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue number)) (closingWedge >)) = (featureTemplateValue (atomicValue sg)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue pl)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue number)) (closingWedge >)) = (featureTemplateValue (atomicValue pl)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue sg) / (atomicValue pl)) be) (featurePathTemplateBody (featureTemplateDisjunction (openingBrace {) (featurePathOrStructure (featureTemplateAbbreviation [ (featureTemplateName (atomicValue sg)) ])) (featurePathOrStructure (featureTemplateAbbreviation [ (featureTemplateName (atomicValue pl)) ])) (closingBrace }))))) (patrRules (patrRule (ruleKW rule) (phraseStructureRule (constituent S) (ruleDef =) (rightHandSide (constituent NP) (constituent VP))))) <EOF>)");
		checkValidGrammar(
				"Let N be <number> = !sg\nrule\n S = NP VP\n",
				"(patrgrammar (featureTemplates (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue N)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue number)) (closingWedge >)) = (featureTemplateValue (atomicValue !sg))))) (patrRules (patrRule (ruleKW rule) (phraseStructureRule (constituent S) (ruleDef =) (rightHandSide (constituent NP) (constituent VP))))) <EOF>)");
		// Following Let statements based on ones in active grammars
		checkValidGrammar(
				"rule {VP option 6cIpastNew - V final, DP initial or final or medial (2) and ditransitive with PP, past only}\r\n"
				+ "VP = {DP (AdvP) {(PP_1) PP / PP PP_1} / {(PP_3) PP_2 / PP_2 PP_3} (AdvP) DP / {PP_2 / PP_2 PP_3} DP (AdvP) PP_1} V | RL 5Oct21 - don't think we need 1st PP_3 since it can come in the I' phrase. Try turning it off sometime.\r\n"
				+ "                                                                                                                   | RL 17Nov21 added optional AdvP\r\n"
				,
				"(patrgrammar (patrRules (patrRule (ruleKW rule) (ruleIdentifier { VP option 6cIpastNew - V final, DP initial or final or medial ( 2 ) and ditransitive with PP, past only }) (phraseStructureRule (constituent VP) (ruleDef =) (rightHandSide (disjunctiveConstituents { (constituent DP) (optionalConstituents ( (constituent AdvP) )) (disjunctiveConstituents { (optionalConstituents ( (constituent PP_1) )) (constituent PP) (disjunctionConstituents / (constituent PP) (constituent PP_1)) }) (disjunctionConstituents / (disjunctiveConstituents { (optionalConstituents ( (constituent PP_3) )) (constituent PP_2) (disjunctionConstituents / (constituent PP_2) (constituent PP_3)) }) (optionalConstituents ( (constituent AdvP) )) (constituent DP)) (disjunctionConstituents / (disjunctiveConstituents { (constituent PP_2) (disjunctionConstituents / (constituent PP_2) (constituent PP_3)) }) (constituent DP) (optionalConstituents ( (constituent AdvP) )) (constituent PP_1)) }) (constituent V))) (comment | RL 5Oct21 - don't think we need 1st PP_3 since it can come in the I' phrase. Try turning it off sometime.\\r\\n) (comment | RL 17Nov21 added optional AdvP\\r\\n))) <EOF>)");
		checkValidGrammar(
				"Let absolutive be <head case> = absolutive\nrule\n S = NP VP\n",
				"(patrgrammar (featureTemplates (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue absolutive)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (featureTemplateValue (atomicValue absolutive))))) (patrRules (patrRule (ruleKW rule) (phraseStructureRule (constituent S) (ruleDef =) (rightHandSide (constituent NP) (constituent VP))))) <EOF>)");
		checkValidGrammar(
				"Let transitive.optional be  <head type transitive> = {+ -}\nrule S = NP VP\n",
				"(patrgrammar (featureTemplates (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue transitive.optional)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)) = (atomicValueDisjunction (openingBrace {) (atomicValue +) (atomicValue -) (closingBrace }))))) (patrRules (patrRule (ruleKW rule) (phraseStructureRule (constituent S) (ruleDef =) (rightHandSide (constituent NP) (constituent VP))))) <EOF>)");
		checkValidGrammar(
				"Let -accusative be <head case> = {nominative genitive dative}\nrule\n S = NP VP\n",
				"(patrgrammar (featureTemplates (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue -accusative)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (atomicValueDisjunction (openingBrace {) (atomicValue nominative) (atomicValue genitive) (atomicValue dative) (closingBrace }))))) (patrRules (patrRule (ruleKW rule) (phraseStructureRule (constituent S) (ruleDef =) (rightHandSide (constituent NP) (constituent VP))))) <EOF>)");
		checkValidGrammar("Let AdjP-final              be  <head type AdjP-final>                      = +\r\n"
				+ "                                <head type AdjP-initial>                    = -\r\n"
				+ "rule\n S = NP VP\r\n",
				"(patrgrammar (featureTemplates (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue AdjP-final)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue AdjP-final)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue AdjP-initial)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)))))) (patrRules (patrRule (ruleKW rule) (phraseStructureRule (constituent S) (ruleDef =) (rightHandSide (constituent NP) (constituent VP))))) <EOF>)");
		checkValidGrammar(
				"Let copular_suffix          be  <head type copular_suffix>                  = +\r\n"
				+ "                                    [copular]\r\n"
				+ ""
				+ "rule\n S = NP VP\r\n"
				,
				"(patrgrammar (featureTemplates (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue copular_suffix)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue copular_suffix)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue copular)) ]))))) (patrRules (patrRule (ruleKW rule) (phraseStructureRule (constituent S) (ruleDef =) (rightHandSide (constituent NP) (constituent VP))))) <EOF>)");
		checkValidGrammar(
				"Let RefPn                   be  [Pron]  | 31Jan03 RL\r\n"
				+ "                                <head type reflexivity>           = +\r\n"
				+ "                                <head type locative>            = !-\r\n"
				+ "				<head type NPrep>		= !-  |22Jul06CB\r\n"
				+ ""
				+ "rule\n S = NP VP\r\n"
				,
				"(patrgrammar (featureTemplates (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue RefPn)) be) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue Pron)) ] (comment | 31Jan03 RL\\r\\n)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue reflexivity)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue locative)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue NPrep)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-) (comment |22Jul06CB\\r\\n)))))))) (patrRules (patrRule (ruleKW rule) (phraseStructureRule (constituent S) (ruleDef =) (rightHandSide (constituent NP) (constituent VP))))) <EOF>)");
		checkValidGrammar(
				"Let causative_syntax                     be   { [head:[infl:[valence:[causative:+]]\r\n"
				+ "                                                       type:[causative_syntax:+]\r\n"
				+ "                                                       embedded:[cat:IP]]]\r\n"
				+ "                                                 [head:[type:[causative_syntax:+\r\n"
				+ "                                                              transitive:+]\r\n"
				+ "                                                        embedded:[cat:none]]] }\r\nrule S = NP VP\r\n",
				"(patrgrammar (featureTemplates (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue causative_syntax)) be) (featurePathTemplateBody (featureTemplateDisjunction (openingBrace {) (featurePathOrStructure (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue infl)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue valence)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue causative)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (closingBracket ]))) (embeddedFeatureStructure (featureStructureName (atomicValue type)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue causative_syntax)) : (featureStructureValue (atomicValue +)) (closingBracket ])))) (embeddedFeatureStructure (featureStructureName (atomicValue embedded)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue cat)) : (featureStructureValue (atomicValue IP)) (closingBracket ])))) (closingBracket ]))) (closingBracket ]))) (featurePathOrStructure (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue type)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue causative_syntax)) : (featureStructureValue (atomicValue +)) (embeddedFeatureStructure (featureStructureName (atomicValue transitive)) : (featureStructureValue (atomicValue +))) (closingBracket ]))) (embeddedFeatureStructure (featureStructureName (atomicValue embedded)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue cat)) : (featureStructureValue (atomicValue none)) (closingBracket ])))) (closingBracket ]))) (closingBracket ]))) (closingBrace }))))) (patrRules (patrRule (ruleKW rule) (phraseStructureRule (constituent S) (ruleDef =) (rightHandSide (constituent NP) (constituent VP))))) <EOF>)");
		checkValidGrammar(
				"rule {S option start symbol -  final ya na & Quote allowed}\r\n"
				+ "S = {IP / CP} (Conj Deg) (Quote)\r\n"
				+ "    <S head> = <IP head>\r\n"
				+ "    <S head> = <CP head>\r\n"
				+ "    <IP head type root> = +\r\n"
				+ "    <IP head type conj_suffix> = -     | 16Jul03 CB\r\n"
				+ "    <CP head type root> = +\r\n"
				+ "    <CP head type conj_suffix> = -     | 16Jul03 CB\r\n"
				+ "    <CP head type relcl> = -          | 21Nov03 CB\r\n"
				+ "    <Conj gloss> = or\r\n"
				+ "    <Conj head type CP-final> = +\r\n"
				+ "    <Deg head type CP-final> = +\r\n"
				+ "    <Deg head infl polarity> = -\r\n"
				+ "    <S head type initialP> = - \r\n"
				+ "    <IP head type relcl> = -            | not a rel clause 21Nov03 CB\r\n"
				+ "    <CP head type relcl> = -            | not a rel clause 21Nov03 CB\r\n"
				+ "    <S rule> = start\n",
				"(patrgrammar (patrRules (patrRule (ruleKW rule) (ruleIdentifier { S option start symbol - final ya na & Quote allowed }) (phraseStructureRule (constituent S) (ruleDef =) (rightHandSide (disjunctiveConstituents { (constituent IP) (disjunctionConstituents / (constituent CP)) }) (optionalConstituents ( (constituent Conj) (constituent Deg) )) (optionalConstituents ( (constituent Quote) )))) (constraints (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent S) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (constituent IP) (featurePath (atomicValue head)) (closingWedge >))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent S) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (constituent CP) (featurePath (atomicValue head)) (closingWedge >))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent IP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue root)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent IP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue conj_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 16Jul03 CB\\r\\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent CP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue root)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent CP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue conj_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 16Jul03 CB\\r\\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent CP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 21Nov03 CB\\r\\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent Conj) (featurePath (atomicValue gloss)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue or))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue CP-final)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue CP-final)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent Deg) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue polarity)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent S) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue initialP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent IP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not a rel clause 21Nov03 CB\\r\\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent CP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not a rel clause 21Nov03 CB\\r\\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent S) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue start)))))) <EOF>)");
		checkValidGrammar(
				"rule {S option startInitDP with DP initial elements and final ya na & Quote allowed}\r\n"
				+ "S = InitP IP (Conj Deg) (Quote)\r\n"
				+ "    <S head> = <IP head>\r\n"
				+ "    <IP head subject> = <InitP head subject> | pass reflexive info\r\n"
				+ "    <IP head type root> = +\r\n"
				+ "    <IP head type pro-drop> = -     | 28May19 \r\n"
				+ "    <IP head type conj_suffix> = -     | 16Jul03 CB\r\n"
				+ "    <InitP head type root> = + \r\n"
				+ "    <Conj gloss> = or\r\n"
				+ "    <Conj head type CP-final> = +\r\n"
				+ "    <Deg head type CP-final> = +\r\n"
				+ "    <Deg head infl polarity> = -\r\n"
				+ "    <S head type initialP> = + \r\n"
				+ "    {<InitP head type relcl> = -  | 03Apr03 CB\r\n"
				+ "    /<InitP head type relcl> = +  |  relcl in InitP only with overt subject\r\n"
				+ "     <IP head type pro-drop> = -\r\n"
				+ "    }\r\n"
				+ "    <InitP head type DP> = +              | 17Feb03 CB for generic/reflex\r\n"
				+ "    <InitP head type PP> = -              | 17Feb03 CB for generic/reflex\r\n"
				+ "    <IP head type relcl> = -            | not a rel clause 21Nov03 CB\r\n"
				+ "    <S rule> = startInitDP\r\n"
				,
				"(patrgrammar (patrRules (patrRule (ruleKW rule) (ruleIdentifier { S option startInitDP with DP initial elements and final ya na & Quote allowed }) (phraseStructureRule (constituent S) (ruleDef =) (rightHandSide (constituent InitP) (constituent IP) (optionalConstituents ( (constituent Conj) (constituent Deg) )) (optionalConstituents ( (constituent Quote) )))) (constraints (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent S) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (constituent IP) (featurePath (atomicValue head)) (closingWedge >))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent IP) (featurePath (atomicValue head) (featurePath (atomicValue subject))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (constituent InitP) (featurePath (atomicValue head) (featurePath (atomicValue subject))) (closingWedge >) (comment | pass reflexive info\\r\\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent IP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue root)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent IP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pro-drop)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 28May19 \\r\\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent IP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue conj_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 16Jul03 CB\\r\\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue root)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent Conj) (featurePath (atomicValue gloss)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue or))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue CP-final)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue CP-final)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent Deg) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue polarity)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent S) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue initialP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +))) (unificationConstraint (disjunctiveUnificationConstraint { (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 03Apr03 CB\\r\\n))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment |  relcl in InitP only with overt subject\\r\\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent IP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pro-drop)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) })) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | 17Feb03 CB for generic/reflex\\r\\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue PP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 17Feb03 CB for generic/reflex\\r\\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent IP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not a rel clause 21Nov03 CB\\r\\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent S) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue startInitDP)))))) <EOF>)");
		checkValidGrammar(
				"rule {S option startInitDP with DP initial elements and final ya na & Quote allowed}\r\n"
				+ "S = InitP IP (Conj Deg) (Quote)\r\n"
				+ "    <S head> = <IP head>\r\n"
                  // skipping unification constraints to test logical constraint
				+ "| don't split coordination - these replace logical constraints in subject rules that incorrectly eliminated even adverbial InitPs 17Apr03 CB\r\n"
				+ "    <IP head> == ~([subject:[head:[type:[coordination:+]]]] \r\n"
				+ "                   & [type:[pro-drop:-]])\r\n"
				+ "    <IP head> == ~([object:[head:[type:[coordination:+]]]] \r\n"
				+ "                   & [type:[pro-drop:+]])\r\n"
				+ "    <IP head type relcl> = -            | not a rel clause 21Nov03 CB\r\n"
				+ "    <S rule> = startInitDP\r\n"
				,
				"(patrgrammar (patrRules (patrRule (ruleKW rule) (ruleIdentifier { S option startInitDP with DP initial elements and final ya na & Quote allowed }) (phraseStructureRule (constituent S) (ruleDef =) (rightHandSide (constituent InitP) (constituent IP) (optionalConstituents ( (constituent Conj) (constituent Deg) )) (optionalConstituents ( (constituent Quote) )))) (constraints (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent S) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (constituent IP) (featurePath (atomicValue head)) (closingWedge >) (comment | don't split coordination - these replace logical constraints in subject rules that incorrectly eliminated even adverbial InitPs 17Apr03 CB\\r\\n))) (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (constituent IP) (featurePath (atomicValue head)) (closingWedge >)) == (logConstraintExpression ~ (logConstraintFactor ( (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue subject)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue type)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue coordination)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (binop &) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue type)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue pro-drop)) : (featureStructureValue (atomicValue -)) (closingBracket ]))) (closingBracket ])))) )))) (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (constituent IP) (featurePath (atomicValue head)) (closingWedge >)) == (logConstraintExpression ~ (logConstraintFactor ( (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue object)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue type)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue coordination)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (binop &) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue type)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue pro-drop)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (closingBracket ])))) )))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent IP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not a rel clause 21Nov03 CB\\r\\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent S) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue startInitDP)))))) <EOF>)");
		checkValidGrammar(
				"rule {InitP option address - DP address or focus/topic - root or nonroot}\r\n"
				+ "InitP = (Conj / Excl) DP\r\n"
				+ "    <InitP head> = <DP head>\r\n"
				+ "    <InitP head type initialP> = +     | restrict conjunctions here and in DP \r\n"
				+ "    <InitP head type comma> = +        | must have comma\r\n"
				+ "    <InitP head subject> = <DP head reflexive> | pass reflexive info\r\n"
				+ "    <Conj head type CP-initial> = +\r\n"
				+ "    <DP head type coordination> = -       | not a DP coordination construction\r\n"
				+ "    <DP head type nonfinalcoordination> = -\r\n"
				+ "    <DP head type DO_contraction> = -   | 17Feb03 CB\r\n"
				+ "    <DP head type case-marked> = -\r\n"
				+ "    <DP head case> = nominative\r\n"
				+ "    <DP head case_for_position> = direct  | for apposition \r\n"
				+ "    <DP head case_for_position_front> = direct  | for apposition \r\n"
				+ "    <DP head case_for_position_front_and> = direct  | for apposition \r\n"
				+ "    <DP head case_for_position_front_and_center> = direct  | for apposition \r\n"
				+ "    <InitP head type PP> = -          | 17Feb03 CB\r\n"
				+ "    <InitP head type DP> = +          | 17Feb03 CB\r\n"
				+ "    <DP head type> == [relative:+] <-> [relcl:+]      | require rel suffix to only occur when relative clause present\r\n"
				+ "    <InitP rule> = address\r\n"
				,
				"(patrgrammar (patrRules (patrRule (ruleKW rule) (ruleIdentifier { InitP option address - DP address or focus / topic - root or nonroot }) (phraseStructureRule (constituent InitP) (ruleDef =) (rightHandSide (optionalConstituents ( (constituent Conj) (disjunctionOptionalConstituents / (constituent Excl)) )) (constituent DP))) (constraints (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent InitP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head)) (closingWedge >))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue initialP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | restrict conjunctions here and in DP \\r\\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | must have comma\\r\\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent InitP) (featurePath (atomicValue head) (featurePath (atomicValue subject))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >) (comment | pass reflexive info\\r\\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue CP-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not a DP coordination construction\\r\\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue nonfinalcoordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DO_contraction)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 17Feb03 CB\\r\\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue nominative))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | for apposition \\r\\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position_front))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | for apposition \\r\\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position_front_and))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | for apposition \\r\\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position_front_and_center))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | for apposition \\r\\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue PP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 17Feb03 CB\\r\\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | 17Feb03 CB\\r\\n))) (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relative)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop <->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relcl)) : (featureStructureValue (atomicValue +)) (closingBracket ]) (comment | require rel suffix to only occur when relative clause present\\r\\n))))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent InitP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue address)))))) <EOF>)");
		checkValidGrammar(
				"rule {IP option 0a-DP - missing final verb IPs}\r\n"
				+ "IP = IP_1 Conj DP\r\n"
				+ "    <IP head> = <IP_1 head>\r\n"
				+ "    <IP head subject> = <DP head reflexive> | pass reflexive info\r\n"
				+ "    {<DP head case> = direct\r\n"
				+ "     <DP head type case-marked> = -\r\n"
				+ "    /<DP head case> = objective\r\n"
				+ "     <DP head type case-marked> = +\r\n"
				+ "    }\r\n"
				+ "    <DP head type coordination> = -\r\n"
				+ "    <IP head type conjoined> <= +   | mark for checking compounding constraints (special case with relcl2+kh and 5c) 20Oct03 CB\r\n"
				+ "|?|    <IP head type final-conjunct compounds_with1> = <DP head type compounds_with1>\r\n"
				+ "|?|    <IP head type final-conjunct compounds_with2> = <DP head type compounds_with2>\r\n"
				+ "|?|    <IP head type final-conjunct compounds_with3> = <DP head type compounds_with3>\r\n"
				+ "|?|    <IP head type final-conjunct compounds_with4> = <DP head type compounds_with4>\r\n"
				+ "    <IP head type comma> <= <DP head type comma>  | comma placement for InitP\r\n"
				+ "    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present\r\n"
				+ "    <Conj> == ~[gloss:namely]\r\n"
				+ "    <IP rule> = 0a-DP\r\n"
				+ "    <IP rule> = start\r\n"
				+ "    <IP rule> = 1\r\n"
				+ "    <IP rule> = address2\r\n"
				+ "    <IP rule> = 2cNon-ImpersonalV-PastIntransitive\r\n"
				+ "    <IP rule> = F.able\r\n"
				+ "    <IP rule> = DPCopSuf\r\n"
				+ "    <IP rule> = object_relcl\r\n"
				+ "    <IP rule> = double-temporal\r\n"
				,
				"(patrgrammar (patrRules (patrRule (ruleKW rule) (ruleIdentifier { IP option 0a-DP - missing final verb IPs }) (phraseStructureRule (constituent IP) (ruleDef =) (rightHandSide (constituent IP_1) (constituent Conj) (constituent DP))) (constraints (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent IP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (constituent IP_1) (featurePath (atomicValue head)) (closingWedge >))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent IP) (featurePath (atomicValue head) (featurePath (atomicValue subject))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >) (comment | pass reflexive info\\r\\n))) (unificationConstraint (disjunctiveUnificationConstraint { (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue objective))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) })) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -))) (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (constituent IP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue conjoined)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | mark for checking compounding constraints (special case with relcl2+kh and 5c) 20Oct03 CB\\r\\n)) (comment |?|    <IP head type final-conjunct compounds_with1> = <DP head type compounds_with1>\\r\\n) (comment |?|    <IP head type final-conjunct compounds_with2> = <DP head type compounds_with2>\\r\\n) (comment |?|    <IP head type final-conjunct compounds_with3> = <DP head type compounds_with3>\\r\\n) (comment |?|    <IP head type final-conjunct compounds_with4> = <DP head type compounds_with4>\\r\\n) (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (constituent IP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) (comment | comma placement for InitP\\r\\n)) (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relative)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relcl)) : (featureStructureValue (atomicValue +)) (closingBracket ]) (comment | require rel suffix to only occur when relative clause present\\r\\n))))) (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (constituent Conj) (closingWedge >)) == (logConstraintExpression ~ (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue gloss)) : (featureStructureValue (atomicValue namely)) (closingBracket ]))))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent IP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 0a-DP))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent IP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue start))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent IP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 1))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent IP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue address2))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent IP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 2cNon-ImpersonalV-PastIntransitive))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent IP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue F.able))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent IP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue DPCopSuf))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent IP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue object_relcl))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent IP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue double-temporal)))))) <EOF>)");
		checkValidGrammar(
				"rule\n S = NP VP\r\n"
				+ "    <IP head> == [rootgloss:^1] ->\r\n"
				+ "                 ~ ( [type:[no_intervening:+]] &    \r\n"
				+ "                   (( [subject:[head:[type:[compounds_with1:^1]]]]\r\n"
				+ "                    / [subject:[head:[type:[compounds_with2:^1]]]])\r\n"
				+ "                    / ([subject:[head:[type:[compounds_with3:^1]]]]\r\n"
				+ "                    / [subject:[head:[type:[compounds_with4:^1]]]]) ) )\r\n"
				,
				"(patrgrammar (patrRules (patrRule (ruleKW rule) (phraseStructureRule (constituent S) (ruleDef =) (rightHandSide (constituent NP) (constituent VP))) (constraints (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (constituent IP) (featurePath (atomicValue head)) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue rootgloss)) : (featureStructureValue (atomicValue ^1)) (closingBracket ]))) (binop ->) ~ (logConstraintFactor ( (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue type)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue no_intervening)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (closingBracket ]))) (binop &) (logConstraintFactor ( (logConstraintExpression (logConstraintFactor ( (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue subject)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue type)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue compounds_with1)) : (featureStructureValue (atomicValue ^1)) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (binop /) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue subject)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue type)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue compounds_with2)) : (featureStructureValue (atomicValue ^1)) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ])))) )) (binop /) (logConstraintFactor ( (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue subject)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue type)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue compounds_with3)) : (featureStructureValue (atomicValue ^1)) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (binop /) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue subject)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue type)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue compounds_with4)) : (featureStructureValue (atomicValue ^1)) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ])))) ))) ))) ))))))) <EOF>)");
		checkValidGrammar(
				"rule\n"
				+ "VP = DP ({PP / {DP_1 / AdvP} / PP_1 {DP_1 / AdvP} / {DP_2 / AdvP} PP / PP_1 {DP_2 / AdvP} PP}) V (CP)"
				,
				"(patrgrammar (patrRules (patrRule (ruleKW rule) (phraseStructureRule (constituent VP) (ruleDef =) (rightHandSide (constituent DP) (optionalConstituents ( (disjunctiveConstituents { (constituent PP) (disjunctionConstituents / (disjunctiveConstituents { (constituent DP_1) (disjunctionConstituents / (constituent AdvP)) })) (disjunctionConstituents / (constituent PP_1) (disjunctiveConstituents { (constituent DP_1) (disjunctionConstituents / (constituent AdvP)) })) (disjunctionConstituents / (disjunctiveConstituents { (constituent DP_2) (disjunctionConstituents / (constituent AdvP)) }) (constituent PP)) (disjunctionConstituents / (constituent PP_1) (disjunctiveConstituents { (constituent DP_2) (disjunctionConstituents / (constituent AdvP)) }) (constituent PP)) }) )) (constituent V) (optionalConstituents ( (constituent CP) )))))) <EOF>)");
		checkValidGrammar("rule {InitP option locPP - locative PP - comma not required - root only}\r\n"
				+ "InitP = (Conj (Conj_1) / Adv) PP (Conj_2)\r\n"
				, "(patrgrammar (patrRules (patrRule (ruleKW rule) (ruleIdentifier { InitP option locPP - locative PP - comma not required - root only }) (phraseStructureRule (constituent InitP) (ruleDef =) (rightHandSide (optionalConstituents ( (constituent Conj) (optionalConstituents ( (constituent Conj_1) )) (disjunctionOptionalConstituents / (constituent Adv)) )) (constituent PP) (optionalConstituents ( (constituent Conj_2) )))))) <EOF>)");
		checkValidGrammar("rule {testing}\r\n"
				+ "S = AdvP / DP    |/ VP / PP \r\n"
				+ "    <S head> = <AdvP head>\r\n"
				+ "    <S head> = <DP head>\r\n"
				+ "|    <S head> = <VP head>\r\n"
				+ "|    <S head> = <PP head>\r\n"
				, "(patrgrammar (patrRules (patrRule (ruleKW rule) (ruleIdentifier { testing }) (phraseStructureRule (constituent S) (ruleDef =) (rightHandSide (constituent AdvP) (disjunctionConstituents / (constituent DP) (comment |/ VP / PP \\r\\n)))) (constraints (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent S) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (constituent AdvP) (featurePath (atomicValue head)) (closingWedge >))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent S) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head)) (closingWedge >) (comment |    <S head> = <VP head>\\r\\n)) (comment |    <S head> = <PP head>\\r\\n))))) <EOF>)");
		checkValidGrammar("rule {IP option 2cImpersonalV - subject initial, required, root clause}  \r\n"
				+ "IP = DP I'\r\n"
				+ "    <IP head> = <I' head>\r\n"
				+ "    <IP head type root> = +\r\n"
				+ "    <IP head type pro-drop> = -\r\n"
				+ "    <IP head subject head agr> = <DP head reflexive head agr> | pass reflexive info\r\n"
				+ "    {<DP head type comma> = -\r\n"
				+ "     <DP head type apposition> = -\r\n"
				+ "    /<DP head type apposition> = +    | 17Jan03  CB\r\n"
				+ "    /<DP head type apposition> = namely    | 21Nov03  CB\r\n"
				+ "    /<DP head type relcl> = +        | can have comma if relcl 27Jan03 CB\r\n"
				+ "     <DP head type comma> = +\r\n"
				+ "     <DP head type apposition> = -\r\n"
				+ "    }\r\n"
				+ "    <I' head subject> = <DP>\r\n"
				+ "    <I' head type impersonal> = +       | impersonal verbs do not agree **24Jul06 CB\r\n"
				+ "    <IP head subject head type> = <DP head type>  | pass DP type features for compounding, regardless of agreement 17Apr03 CB\r\n"
				+ "    <IP head subject head possessor> = <DP head possessor> | pass DP possessor info for compounding, regardless of agreement 17Apr03 CB\r\n"
				+ "    {<DP head case> = oblique\r\n"
				+ "    <DP head case_for_position> = oblique  | to know normal case for conjoined DPs\r\n"
				+ "     <DP head agr person third> = +\r\n"
				+ "    /<DP head agr person first> = +        | pronouns different case CB 23May19\r\n"
				+ "     <DP head case> = objective\r\n"
				+ "    <DP head case_for_position> = objective  | to know normal case for conjoined DPs\r\n"
				+ "    /<DP head agr person second> = +        | pronouns different case CB 23May19\r\n"
				+ "     <DP head case> = objective\r\n"
				+ "    <DP head case_for_position> = objective  | to know normal case for conjoined DPs\r\n"
				+ "    }\r\n"
				+ "    <DP head type DO_contraction> = -   | 17Feb03 CB\r\n"
				+ "    <DP head type case-marked> = -\r\n"
				+ "    <DP head type nonfinalcoordination> = -\r\n"
				+ "    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially\r\n"
				+ "    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete\r\n"
				+ "    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present\r\n"
				+ "    <IP head> == [type:[reciprocal:+]] -> \r\n"
				+ "                 [subject:[head:[agr:[number:[plural:+]]]]]\r\n"
				+ "    <IP head> == [object:[head:[type:[reciprocal:+]]]] ->\r\n"
				+ "                 [subject:[head:[agr:[number:[plural:+]]]]]\r\n"
				+ "    <IP head> == [object:[head:[infl:[polarity:-]]]] ->   |if the object is negative, the verb must be negative\r\n"
				+ "                 [infl:[polarity:-]]\r\n"
				+ "    <IP head> == [subject:[head:[infl:[polarity:-]]]] ->   |if the subject is negative, the verb must be negative\r\n"
				+ "                 [infl:[polarity:-]]\r\n"
				+ "    <IP head> == ~[object:[head:[type:[conjunction_gloss:initial_ya]]]]   | to restrict splitting between subject and object\r\n"
				+ "||    <IP head> == [subject:[head:[type:[coordination:+]]]] ->\r\n"
				+ "||                ~[type:[initialP:+]]\r\n"
				+ "    <IP head> == ((([subject:[head:[participle:[cat:V]]]] / [subject:[head:[possessor:[head:[participle:[cat:V]]]]]]))\r\n"
				+ "                   & ([type:[no_intervening:+]])) -> \r\n"
				+ "                 (([type:[auxiliary:-\r\n"
				+ "                         copular:-\r\n"
				+ "                         passive:-]] \r\n"
				+ "                 / [type:[auxiliary:+\r\n"
				+ "                          participle:+]])        \r\n"
				+ "                 / [type:[participle_passive:+]])  | to force participle to be w/ V or Aux 12-APR-04\r\n"
				+ "    <IP head> == [rootgloss:^1] ->\r\n"
				+ "                 ~ ( [type:[no_intervening:+]] &    \r\n"
				+ "                   (( [subject:[head:[type:[compounds_with1:^1]]]]\r\n"
				+ "                    / [subject:[head:[type:[compounds_with2:^1]]]])\r\n"
				+ "                    / ([subject:[head:[type:[compounds_with3:^1]]]]\r\n"
				+ "                    / [subject:[head:[type:[compounds_with4:^1]]]]) ) )\r\n"
				+ "    <IP head> == [rootgloss:^1] ->\r\n"
				+ "                 ~ ( [type:[no_intervening:+]] & \r\n"
				+ "                  (( [subject:[head:[possessor:[head:[type:[compounds_with1:^1]]]]]]\r\n"
				+ "                   / [subject:[head:[possessor:[head:[type:[compounds_with2:^1]]]]]]) \r\n"
				+ "                   / ([subject:[head:[possessor:[head:[type:[compounds_with3:^1]]]]]] \r\n"
				+ "                   / [subject:[head:[possessor:[head:[type:[compounds_with4:^1]]]]]]) ))\r\n"
				+ "    <IP rule> = 2cImpersonalV\r\n"
				, "(patrgrammar (patrRules (patrRule (ruleKW rule) (ruleIdentifier { IP option 2cImpersonalV - subject initial, required, root clause }) (phraseStructureRule (constituent IP) (ruleDef =) (rightHandSide (constituent DP) (constituent I'))) (constraints (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent IP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (constituent I') (featurePath (atomicValue head)) (closingWedge >))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent IP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue root)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent IP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pro-drop)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent IP) (featurePath (atomicValue head) (featurePath (atomicValue subject) (featurePath (atomicValue head) (featurePath (atomicValue agr))))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive) (featurePath (atomicValue head) (featurePath (atomicValue agr))))) (closingWedge >) (comment | pass reflexive info\\r\\n))) (unificationConstraint (disjunctiveUnificationConstraint { (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue apposition)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue apposition)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | 17Jan03  CB\\r\\n)))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue apposition)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue namely) (comment | 21Nov03  CB\\r\\n)))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | can have comma if relcl 27Jan03 CB\\r\\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue apposition)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) })) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent I') (featurePath (atomicValue head) (featurePath (atomicValue subject))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (constituent DP) (closingWedge >))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent I') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue impersonal)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | impersonal verbs do not agree **24Jul06 CB\\r\\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent IP) (featurePath (atomicValue head) (featurePath (atomicValue subject) (featurePath (atomicValue head) (featurePath (atomicValue type))))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >) (comment | pass DP type features for compounding, regardless of agreement 17Apr03 CB\\r\\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent IP) (featurePath (atomicValue head) (featurePath (atomicValue subject) (featurePath (atomicValue head) (featurePath (atomicValue possessor))))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue possessor))) (closingWedge >) (comment | pass DP possessor info for compounding, regardless of agreement 17Apr03 CB\\r\\n))) (unificationConstraint (disjunctiveUnificationConstraint { (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue oblique))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue oblique) (comment | to know normal case for conjoined DPs\\r\\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue third))))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue first))))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | pronouns different case CB 23May19\\r\\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue objective))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue objective) (comment | to know normal case for conjoined DPs\\r\\n)))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue second))))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | pronouns different case CB 23May19\\r\\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue objective))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue objective) (comment | to know normal case for conjoined DPs\\r\\n)))) })) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DO_contraction)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 17Feb03 CB\\r\\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue nonfinalcoordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -))) (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (constituent DP) (closingWedge >)) == (logConstraintExpression ~ (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue mother_node)) : (featureStructureValue (atomicValue -)) (closingBracket ]) (comment | if coordination, must be allowed initially\\r\\n))))) (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (constituent DP) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue mother_node)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue type)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue coordination)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (closingBracket ]))) (closingBracket ]) (comment |and be complete\\r\\n))))) (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relative)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relcl)) : (featureStructureValue (atomicValue +)) (closingBracket ]) (comment | require rel suffix to only occur when relative clause present\\r\\n))))) (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (constituent IP) (featurePath (atomicValue head)) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue type)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue reciprocal)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue subject)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue agr)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue number)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue plural)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))))) (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (constituent IP) (featurePath (atomicValue head)) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue object)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue type)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue reciprocal)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue subject)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue agr)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue number)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue plural)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))))) (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (constituent IP) (featurePath (atomicValue head)) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue object)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue infl)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue polarity)) : (featureStructureValue (atomicValue -)) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (binop -> (comment |if the object is negative, the verb must be negative\\r\\n)) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue infl)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue polarity)) : (featureStructureValue (atomicValue -)) (closingBracket ]))) (closingBracket ]))))) (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (constituent IP) (featurePath (atomicValue head)) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue subject)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue infl)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue polarity)) : (featureStructureValue (atomicValue -)) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (binop -> (comment |if the subject is negative, the verb must be negative\\r\\n)) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue infl)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue polarity)) : (featureStructureValue (atomicValue -)) (closingBracket ]))) (closingBracket ]))))) (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (constituent IP) (featurePath (atomicValue head)) (closingWedge >)) == (logConstraintExpression ~ (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue object)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue type)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue conjunction_gloss)) : (featureStructureValue (atomicValue initial_ya)) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ]) (comment | to restrict splitting between subject and object\\r\\n) (comment ||    <IP head> == [subject:[head:[type:[coordination:+]]]] ->\\r\\n) (comment ||                ~[type:[initialP:+]]\\r\\n))))) (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (constituent IP) (featurePath (atomicValue head)) (closingWedge >)) == (logConstraintExpression (logConstraintFactor ( (logConstraintExpression (logConstraintFactor ( (logConstraintExpression (logConstraintFactor ( (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue subject)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue participle)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue cat)) : (featureStructureValue (atomicValue V)) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (binop /) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue subject)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue possessor)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue participle)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue cat)) : (featureStructureValue (atomicValue V)) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ])))) ))) )) (binop &) (logConstraintFactor ( (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue type)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue no_intervening)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (closingBracket ])))) ))) )) (binop ->) (logConstraintFactor ( (logConstraintExpression (logConstraintFactor ( (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue type)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue auxiliary)) : (featureStructureValue (atomicValue -)) (embeddedFeatureStructure (featureStructureName (atomicValue copular)) : (featureStructureValue (atomicValue -))) (embeddedFeatureStructure (featureStructureName (atomicValue passive)) : (featureStructureValue (atomicValue -))) (closingBracket ]))) (closingBracket ]))) (binop /) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue type)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue auxiliary)) : (featureStructureValue (atomicValue +)) (embeddedFeatureStructure (featureStructureName (atomicValue participle)) : (featureStructureValue (atomicValue +))) (closingBracket ]))) (closingBracket ])))) )) (binop /) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue type)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue participle_passive)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (closingBracket ])))) )))) (comment | to force participle to be w/ V or Aux 12-APR-04\\r\\n) (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (constituent IP) (featurePath (atomicValue head)) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue rootgloss)) : (featureStructureValue (atomicValue ^1)) (closingBracket ]))) (binop ->) ~ (logConstraintFactor ( (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue type)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue no_intervening)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (closingBracket ]))) (binop &) (logConstraintFactor ( (logConstraintExpression (logConstraintFactor ( (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue subject)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue type)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue compounds_with1)) : (featureStructureValue (atomicValue ^1)) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (binop /) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue subject)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue type)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue compounds_with2)) : (featureStructureValue (atomicValue ^1)) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ])))) )) (binop /) (logConstraintFactor ( (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue subject)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue type)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue compounds_with3)) : (featureStructureValue (atomicValue ^1)) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (binop /) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue subject)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue type)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue compounds_with4)) : (featureStructureValue (atomicValue ^1)) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ])))) ))) ))) )))) (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (constituent IP) (featurePath (atomicValue head)) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue rootgloss)) : (featureStructureValue (atomicValue ^1)) (closingBracket ]))) (binop ->) ~ (logConstraintFactor ( (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue type)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue no_intervening)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (closingBracket ]))) (binop &) (logConstraintFactor ( (logConstraintExpression (logConstraintFactor ( (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue subject)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue possessor)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue type)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue compounds_with1)) : (featureStructureValue (atomicValue ^1)) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (binop /) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue subject)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue possessor)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue type)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue compounds_with2)) : (featureStructureValue (atomicValue ^1)) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ])))) )) (binop /) (logConstraintFactor ( (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue subject)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue possessor)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue type)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue compounds_with3)) : (featureStructureValue (atomicValue ^1)) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (binop /) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue subject)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue possessor)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue type)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue compounds_with4)) : (featureStructureValue (atomicValue ^1)) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ])))) ))) ))) )))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent IP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 2cImpersonalV)))))) <EOF>)");
		checkValidGrammar("rule {P' option bh-I - prefixed to oblique, complement required}\r\n"
				+ "P' = P DP\r\n"
				+ "    <P' head> = <P head>\r\n"
				+ "    <P' head rootgloss> = <P rootgloss>\r\n"
				+ "    <P' head gloss> = <P gloss>\r\n"
				+ "    <P head type comma> = -\r\n"
				+ "    <P head type passive> = +\r\n"
				+ "    <P head case> = oblique\r\n"
				+ "    <P head type prefix_Prep> = +\r\n"
				+ "    <P head type suffix_Pn> = -\r\n"
				+ "    <P' head reflexive> = <DP head reflexive> | pass reflexive info\r\n"
				+ "    <P' head object> = <DP>         |- for passive, etc.\r\n"
				+ "    <DP head type DO_contraction> = -\r\n"
				+ "    <DP head case_for_position> = direct  | to know normal case for conjoined DPs\r\n"
				+ "    <DP head case> = direct\r\n"
				+ "    <P' head type stranded> = -         |- not missing a complement\r\n"
				+ "    <DP head participle> = none                                      | trying to restrict participles 12-APR-04\r\n"
				+ "    <DP head possessor head participle> = none                       | trying to restrict participles 12-APR-04\r\n"
				+ "    <DP head type nonfinalcoordination> = -\r\n"
				+ "    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially\r\n"
				+ "    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete\r\n"
				+ "    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present\r\n"
				+ "    <P' head type comma> <= <DP head type comma> \r\n"
				+ "    <P' rule> = bh-I\r\n"
				+ "\r\n"
				+ "rule {P' option bh-II - prefixed to N, Pn or Dem complement so full PP}\r\n"
				+ "P' = P\r\n"
				+ "    <P' head> = <P head>\r\n"
				+ "    <P' head rootgloss> = <P rootgloss>\r\n"
				+ "    <P' head gloss> = <P gloss>\r\n"
				+ "    <P head type passive> = +\r\n"
				+ "    <P head case> = direct\r\n"
				+ "    <P head type prefix_Prep> = +\r\n"
				+ "    <P' head type stranded> = -         |- not missing a complement\r\n"
				+ "    <P' rule> = bh-II\r\n"
				+ "\r\n"
				+ "|added 15Jul03 CB\r\n"
				, "(patrgrammar (patrRules (patrRule (ruleKW rule) (ruleIdentifier { P' option bh-I - prefixed to oblique, complement required }) (phraseStructureRule (constituent P') (ruleDef =) (rightHandSide (constituent P) (constituent DP))) (constraints (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent P') (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (constituent P) (featurePath (atomicValue head)) (closingWedge >))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent P') (featurePath (atomicValue head) (featurePath (atomicValue rootgloss))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (constituent P) (featurePath (atomicValue rootgloss)) (closingWedge >))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent P') (featurePath (atomicValue head) (featurePath (atomicValue gloss))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (constituent P) (featurePath (atomicValue gloss)) (closingWedge >))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent P) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent P) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue passive)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent P) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue oblique))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent P) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue prefix_Prep)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent P) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue suffix_Pn)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent P') (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >) (comment | pass reflexive info\\r\\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent P') (featurePath (atomicValue head) (featurePath (atomicValue object))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (constituent DP) (closingWedge >) (comment |- for passive, etc.\\r\\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DO_contraction)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | to know normal case for conjoined DPs\\r\\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent P') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue stranded)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment |- not missing a complement\\r\\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue participle))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue none) (comment | trying to restrict participles 12-APR-04\\r\\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue possessor) (featurePath (atomicValue head) (featurePath (atomicValue participle))))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue none) (comment | trying to restrict participles 12-APR-04\\r\\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue nonfinalcoordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -))) (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (constituent DP) (closingWedge >)) == (logConstraintExpression ~ (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue mother_node)) : (featureStructureValue (atomicValue -)) (closingBracket ]) (comment | if coordination, must be allowed initially\\r\\n))))) (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (constituent DP) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue mother_node)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue type)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue coordination)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (closingBracket ]))) (closingBracket ]) (comment |and be complete\\r\\n))))) (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relative)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relcl)) : (featureStructureValue (atomicValue +)) (closingBracket ]) (comment | require rel suffix to only occur when relative clause present\\r\\n))))) (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (constituent P') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent P') (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue bh-I))))) (patrRule (ruleKW rule) (ruleIdentifier { P' option bh-II - prefixed to N, Pn or Dem complement so full PP }) (phraseStructureRule (constituent P') (ruleDef =) (rightHandSide (constituent P))) (constraints (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent P') (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (constituent P) (featurePath (atomicValue head)) (closingWedge >))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent P') (featurePath (atomicValue head) (featurePath (atomicValue rootgloss))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (constituent P) (featurePath (atomicValue rootgloss)) (closingWedge >))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent P') (featurePath (atomicValue head) (featurePath (atomicValue gloss))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (constituent P) (featurePath (atomicValue gloss)) (closingWedge >))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent P) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue passive)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent P) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent P) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue prefix_Prep)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent P') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue stranded)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment |- not missing a complement\\r\\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent P') (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue bh-II) (comment |added 15Jul03 CB\\r\\n)))))) <EOF>)");
		checkValidGrammar("rule {VP option 5cPastNew - V final, transitive}\r\n"
				+ "VP = DP ({PP / {DP_1 / AdvP} / PP_1 {DP_1 / AdvP} / {DP_2 / AdvP} PP / PP_1 {DP_2 / AdvP} PP}) V (CP)  \r\n"
				+ "    <VP head> = <V head>\r\n"
				+ "    <VP head rootgloss> <= <V rootgloss>\r\n"
				+ "    <VP head object> = <DP>\r\n"
				+ "   | Experimental object agreement\r\n"
				+ "    <VP head> ==  ([object:[head:[agr:[number:[plural:+]]]]] & [object:[head:[agr:[person:[third:+]]]]]) -> ([obj:[head:[agr:[number:[plural:+]]]]] & [obj:[head:[agr:[person:[third:+]]]]])\r\n"
				+ "|    <VP head> == ~([object:[head:[agr:[number:[plural:+]]]]] & [object:[head:[agr:[person:[third:+]]]]]) -> ([obj:[head:[agr:[number:[singular:+]]]]] & [obj:[head:[agr:[person:[third:+]]]]])\r\n"
				+ "    <VP head> == (~[object:[head:\r\n"
				+ "    [agr:[number:[plural:+]]]]] / ~[object:[head:[agr:[person:[third:+]]]]]) -> ([obj:[head:[agr:[number:[singular:+]]]]] & [obj:[head:[agr:[person:[third:+]]]]])\r\n"
				+ "    <VP head adjoined> <= <DP_1>\r\n"
				+ "    <VP head adjoinedPP> <= <PP>\r\n"
				+ "    <VP head adjoined> <= <AdvP>\r\n"
				+ "    <VP head type no_intervening> = -   | for compounding constraint\r\n"
				+ "    {<VP head infl tense past> = +\r\n"
				+ "    /<VP head infl tense past> = -\r\n"
				+ "     <VP head infl mood subjunctive> = +        | Apr2020\r\n"
				+ "     <VP head auxiliary rootgloss> = be.able  |tense from Aux  Feb2020\r\n"
				+ "     <VP head auxiliary infl tense past> = +  | must be past Aux Apr2020 | RL20May20 corrected typo\r\n"
				+ "     <VP head type auxiliary> = +             | Aux must be present Apr2020\r\n"
				+ "    }\r\n"
				+ "    <VP head> == ~[VP_2:[head:[infl:[tense:[past:-]]]]]    | for prtConj rule VP_2 determines tense 19Apr21 CB\r\n"
				+ "\r\n"
				+ "		<AdvP head type> == (([temporal:+] / [locative:+]) / [manner:+])\r\n"
				+ "		<DP_1 head type> == (([temporal:+] / [locative:+]) / [manner:+])\r\n"
				+ "		<DP_2 head type> == (([temporal:+] / [locative:+]) / [manner:+])\r\n"
				+ "    <DP_1 head case> = direct         \r\n"
				, "(patrgrammar (patrRules (patrRule (ruleKW rule) (ruleIdentifier { VP option 5cPastNew - V final, transitive }) (phraseStructureRule (constituent VP) (ruleDef =) (rightHandSide (constituent DP) (optionalConstituents ( (disjunctiveConstituents { (constituent PP) (disjunctionConstituents / (disjunctiveConstituents { (constituent DP_1) (disjunctionConstituents / (constituent AdvP)) })) (disjunctionConstituents / (constituent PP_1) (disjunctiveConstituents { (constituent DP_1) (disjunctionConstituents / (constituent AdvP)) })) (disjunctionConstituents / (disjunctiveConstituents { (constituent DP_2) (disjunctionConstituents / (constituent AdvP)) }) (constituent PP)) (disjunctionConstituents / (constituent PP_1) (disjunctiveConstituents { (constituent DP_2) (disjunctionConstituents / (constituent AdvP)) }) (constituent PP)) }) )) (constituent V) (optionalConstituents ( (constituent CP) )))) (constraints (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent VP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (constituent V) (featurePath (atomicValue head)) (closingWedge >))) (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (constituent VP) (featurePath (atomicValue head) (featurePath (atomicValue rootgloss))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (constituent V) (featurePath (atomicValue rootgloss)) (closingWedge >))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent VP) (featurePath (atomicValue head) (featurePath (atomicValue object))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (constituent DP) (closingWedge >) (comment | Experimental object agreement\\r\\n))) (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (constituent VP) (featurePath (atomicValue head)) (closingWedge >)) == (logConstraintExpression (logConstraintFactor ( (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue object)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue agr)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue number)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue plural)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (binop &) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue object)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue agr)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue person)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue third)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ])))) )) (binop ->) (logConstraintFactor ( (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue obj)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue agr)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue number)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue plural)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (binop &) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue obj)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue agr)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue person)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue third)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ])))) )))) (comment |    <VP head> == ~([object:[head:[agr:[number:[plural:+]]]]] & [object:[head:[agr:[person:[third:+]]]]]) -> ([obj:[head:[agr:[number:[singular:+]]]]] & [obj:[head:[agr:[person:[third:+]]]]])\\r\\n) (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (constituent VP) (featurePath (atomicValue head)) (closingWedge >)) == (logConstraintExpression (logConstraintFactor ( (logConstraintExpression ~ (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue object)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue agr)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue number)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue plural)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (binop /) ~ (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue object)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue agr)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue person)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue third)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ])))) )) (binop ->) (logConstraintFactor ( (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue obj)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue agr)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue number)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue singular)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (binop &) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue obj)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue agr)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue person)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue third)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ])))) )))) (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (constituent VP) (featurePath (atomicValue head) (featurePath (atomicValue adjoined))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (constituent DP_1) (closingWedge >))) (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (constituent VP) (featurePath (atomicValue head) (featurePath (atomicValue adjoinedPP))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (constituent PP) (closingWedge >))) (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (constituent VP) (featurePath (atomicValue head) (featurePath (atomicValue adjoined))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (constituent AdvP) (closingWedge >))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent VP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_intervening)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | for compounding constraint\\r\\n))) (unificationConstraint (disjunctiveUnificationConstraint { (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent VP) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue tense) (featurePath (atomicValue past))))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent VP) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue tense) (featurePath (atomicValue past))))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent VP) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue mood) (featurePath (atomicValue subjunctive))))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | Apr2020\\r\\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent VP) (featurePath (atomicValue head) (featurePath (atomicValue auxiliary) (featurePath (atomicValue rootgloss)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue be.able) (comment |tense from Aux  Feb2020\\r\\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent VP) (featurePath (atomicValue head) (featurePath (atomicValue auxiliary) (featurePath (atomicValue infl) (featurePath (atomicValue tense) (featurePath (atomicValue past)))))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | must be past Aux Apr2020 | RL20May20 corrected typo\\r\\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent VP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue auxiliary)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | Aux must be present Apr2020\\r\\n)))) })) (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (constituent VP) (featurePath (atomicValue head)) (closingWedge >)) == (logConstraintExpression ~ (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue VP_2)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue infl)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue tense)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue past)) : (featureStructureValue (atomicValue -)) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ]) (comment | for prtConj rule VP_2 determines tense 19Apr21 CB\\r\\n))))) (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (constituent AdvP) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor ( (logConstraintExpression (logConstraintFactor ( (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue temporal)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop /) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue locative)) : (featureStructureValue (atomicValue +)) (closingBracket ])))) )) (binop /) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue manner)) : (featureStructureValue (atomicValue +)) (closingBracket ])))) )))) (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (constituent DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor ( (logConstraintExpression (logConstraintFactor ( (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue temporal)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop /) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue locative)) : (featureStructureValue (atomicValue +)) (closingBracket ])))) )) (binop /) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue manner)) : (featureStructureValue (atomicValue +)) (closingBracket ])))) )))) (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (constituent DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor ( (logConstraintExpression (logConstraintFactor ( (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue temporal)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop /) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue locative)) : (featureStructureValue (atomicValue +)) (closingBracket ])))) )) (binop /) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue manner)) : (featureStructureValue (atomicValue +)) (closingBracket ])))) )))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent DP_1) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct)))))) <EOF>)");
		checkValidGrammar("rule {InitP option advNew - Adverbial clauses - root or nonroot}\r\n"
				+ "InitP = (Conj / C) (DP) (PP) { AdvP (PP_1) / (AdvP_1) AdvCl } (Conj_2) \r\n"
				+ "    <InitP head> = <AdvP head>\r\n"
				+ "    <InitP head> = <AdvCl head>\r\n"
				+ "    <InitP head type initialP> = +     | restrict occurrence in sentential PPs \r\n"
				+ "		<DP head type> == (([temporal:+] / [locative:+]) / [manner:+])\r\n"
				+ "    <DP head> == ([type:[temporal:+]] & ~[deg_modifier:[rootgloss:every]]) -> [case:oblique]                | RL 17Jun21 temporals need to be marked oblique, except when modified by 'har' (every)\r\n"
				+ "    <DP head> == ~([type:[temporal:+]] & ~[deg_modifier:[rootgloss:every]]) -> [case:direct]                | RL 17Jun21 non-temporals need to be unmarked\r\n"
				+ "    <DP head type coordination> = -       | not a DP coordination construction\r\n"
				+ "    <DP head type nonfinalcoordination> = -\r\n"
				+ "    <DP head type DO_contraction> = -   \r\n"
				+ "    <DP head type case-marked> = -\r\n"
				+ "    <DP head case_for_position> = direct  | for apposition \r\n"
				+ "    <DP head type copular_suffix> = -\r\n"
				+ "		<PP head type> == (([temporal:+] / [locative:+]) / [manner:+])\r\n"
				+ "    <PP head type passive> = -         \r\n"
				+ "    <PP head type stranded> = -  \r\n"
				+ "    <PP_1 head type benefactor> = +     | RL 8Jun21 limit what kind of trailing PPs we get      \r\n"
				+ "    <Conj head type CP-initial> = + \r\n"
				+ "    <AdvP head type CP-initial> = + \r\n"
				+ "    <AdvP_1 head type CP-initial> = + \r\n"
				+ "    <Conj_2 head type CP-initial> = +\r\n"
				+ "    <C> == [gloss:clm]\r\n"
				+ "    <InitP head type PP> = -          | 17Feb03 CB\r\n"
				+ "    <InitP head type DP> = -          | 17Feb03 CB\r\n"
				+ "    <InitP head type adverbial-phrase> = +   | RL 18Mar21 for allowing an adverbial InitP to stand-alone\r\n"
				+ "    <InitP rule> = adv\r\n"
				+ "\r\n"
				, "(patrgrammar (patrRules (patrRule (ruleKW rule) (ruleIdentifier { InitP option advNew - Adverbial clauses - root or nonroot }) (phraseStructureRule (constituent InitP) (ruleDef =) (rightHandSide (optionalConstituents ( (constituent Conj) (disjunctionOptionalConstituents / (constituent C)) )) (optionalConstituents ( (constituent DP) )) (optionalConstituents ( (constituent PP) )) (disjunctiveConstituents { (constituent AdvP) (optionalConstituents ( (constituent PP_1) )) (disjunctionConstituents / (optionalConstituents ( (constituent AdvP_1) )) (constituent AdvCl)) }) (optionalConstituents ( (constituent Conj_2) )))) (constraints (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent InitP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (constituent AdvP) (featurePath (atomicValue head)) (closingWedge >))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent InitP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (constituent AdvCl) (featurePath (atomicValue head)) (closingWedge >))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue initialP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | restrict occurrence in sentential PPs \\r\\n))) (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor ( (logConstraintExpression (logConstraintFactor ( (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue temporal)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop /) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue locative)) : (featureStructureValue (atomicValue +)) (closingBracket ])))) )) (binop /) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue manner)) : (featureStructureValue (atomicValue +)) (closingBracket ])))) )))) (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head)) (closingWedge >)) == (logConstraintExpression (logConstraintFactor ( (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue type)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue temporal)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (closingBracket ]))) (binop &) ~ (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue deg_modifier)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue rootgloss)) : (featureStructureValue (atomicValue every)) (closingBracket ]))) (closingBracket ])))) )) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue case)) : (featureStructureValue (atomicValue oblique)) (closingBracket ]) (comment | RL 17Jun21 temporals need to be marked oblique, except when modified by 'har' (every)\\r\\n))))) (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head)) (closingWedge >)) == (logConstraintExpression ~ (logConstraintFactor ( (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue type)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue temporal)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (closingBracket ]))) (binop &) ~ (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue deg_modifier)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue rootgloss)) : (featureStructureValue (atomicValue every)) (closingBracket ]))) (closingBracket ])))) )) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue case)) : (featureStructureValue (atomicValue direct)) (closingBracket ]) (comment | RL 17Jun21 non-temporals need to be unmarked\\r\\n))))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not a DP coordination construction\\r\\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue nonfinalcoordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DO_contraction)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | for apposition \\r\\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue copular_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -))) (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (constituent PP) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor ( (logConstraintExpression (logConstraintFactor ( (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue temporal)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop /) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue locative)) : (featureStructureValue (atomicValue +)) (closingBracket ])))) )) (binop /) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue manner)) : (featureStructureValue (atomicValue +)) (closingBracket ])))) )))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent PP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue passive)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent PP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue stranded)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent PP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue benefactor)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | RL 8Jun21 limit what kind of trailing PPs we get      \\r\\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue CP-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent AdvP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue CP-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent AdvP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue CP-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent Conj_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue CP-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +))) (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (constituent C) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue gloss)) : (featureStructureValue (atomicValue clm)) (closingBracket ]))))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue PP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 17Feb03 CB\\r\\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 17Feb03 CB\\r\\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue adverbial-phrase)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | RL 18Mar21 for allowing an adverbial InitP to stand-alone\\r\\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent InitP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue adv)))))) <EOF>)");
		// use of keyword 'rule' in feature structure
		checkValidGrammar("rule {InitP option PPNew - certain types - root only}\r\n"
				+ "InitP = (Conj (Conj_3) / Adv) PP (Conj_2)\r\n" + "    <InitP head> = <PP head>\r\n"
				+ "    <InitP head type root> = +\r\n"
				+ "    <InitP head subject> = <PP head reflexive> | pass reflexive info\r\n"
				+ "    <InitP head type initialP> = +     | restrict occurrence in sentential PPs \r\n"
				+ "    <Adv head type reason> = +\r\n" + "    <PP head> == ~[rootgloss: to.IO]       \r\n"
				+ "		<PP head type> == ((([temporal:+] / [locative:+]) / [benefactor:+]) / [manner:+])\r\n"
				+ "    <PP head type copular_suffix> = -   \r\n"
				+ "    <PP head type stranded> = -         |- PP must have overt complement\r\n"
				+ "    <Conj head type CP-initial> = + \r\n" + "    <Conj_2 head type CP-initial> = +\r\n"
				+ "    <PP> == ~[rule: 1conj]\r\n" + "    <PP> == ~[rule: 1conj]\r\n"
				+ "    <Conj_3 head type CP-initial> = +  |e.g. امّا اگر به کسی که در خانهٔ تو باشد، صدمه‌ای برسد،تری\r\n"
				+ "    <InitP head type PP> = +          | 17Feb03 CB\r\n"
				+ "    <InitP head type DP> = -          | 17Feb03 CB\r\n"
				+ "    <InitP head type adverbial-phrase> = +   | RL 18Mar21 for allowing an adverbial InitP to stand-alone\r\n"
				+ "    <InitP rule> = tempPP\r\n"
				, "(patrgrammar (patrRules (patrRule (ruleKW rule) (ruleIdentifier { InitP option PPNew - certain types - root only }) (phraseStructureRule (constituent InitP) (ruleDef =) (rightHandSide (optionalConstituents ( (constituent Conj) (optionalConstituents ( (constituent Conj_3) )) (disjunctionOptionalConstituents / (constituent Adv)) )) (constituent PP) (optionalConstituents ( (constituent Conj_2) )))) (constraints (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent InitP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (constituent PP) (featurePath (atomicValue head)) (closingWedge >))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue root)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent InitP) (featurePath (atomicValue head) (featurePath (atomicValue subject))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (constituent PP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >) (comment | pass reflexive info\\r\\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue initialP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | restrict occurrence in sentential PPs \\r\\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent Adv) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue reason)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +))) (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (constituent PP) (featurePath (atomicValue head)) (closingWedge >)) == (logConstraintExpression ~ (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue rootgloss)) : (featureStructureValue (atomicValue to.IO)) (closingBracket ]))))) (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (constituent PP) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor ( (logConstraintExpression (logConstraintFactor ( (logConstraintExpression (logConstraintFactor ( (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue temporal)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop /) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue locative)) : (featureStructureValue (atomicValue +)) (closingBracket ])))) )) (binop /) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue benefactor)) : (featureStructureValue (atomicValue +)) (closingBracket ])))) )) (binop /) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue manner)) : (featureStructureValue (atomicValue +)) (closingBracket ])))) )))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent PP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue copular_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent PP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue stranded)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment |- PP must have overt complement\\r\\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue CP-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent Conj_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue CP-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +))) (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (constituent PP) (closingWedge >)) == (logConstraintExpression ~ (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (ruleKW rule)) : (featureStructureValue (atomicValue 1conj)) (closingBracket ]))))) (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (constituent PP) (closingWedge >)) == (logConstraintExpression ~ (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (ruleKW rule)) : (featureStructureValue (atomicValue 1conj)) (closingBracket ]))))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent Conj_3) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue CP-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment |e.g. امّا اگر به کسی که در خانهٔ تو باشد، صدمه‌ای برسد،تری\\r\\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue PP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | 17Feb03 CB\\r\\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 17Feb03 CB\\r\\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue adverbial-phrase)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | RL 18Mar21 for allowing an adverbial InitP to stand-alone\\r\\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent InitP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue tempPP)))))) <EOF>)");
		// use of keyword 'be' in feature structure value
		checkValidGrammar("rule {VP option PrtConj - conjoined VPs with participle on first verb acting as the Conj}\r\n"
				+ "VP = VP_1 ({PP / { DP / AdvP } / PP { DP / AdvP } / { DP / AdvP } PP / PP_1 { DP / AdvP } PP}) VP_2\r\n"
				+ "    <VP_2 head type copular_suffix> = -             | RL 26Aug20 I don't think this construction ever happens with the 2nd verb having a copular suffix.\r\n"
				+ "    <VP_2> == [head:[rootgloss:be]] -> ~[rule:2a]  | RL 24Jan21 can't be a lone V that is 'be' which would be a past perfect construction\r\n"
				+ "    <VP_2> == [head:[rootgloss:exist]] -> ~[rule:2a]  | RL 24Jan21 can't be a lone V that is 'be' which would be a past perfect construction\r\n"
				+ "    <VP_2> == [head:[rootgloss:be.aux]] -> ~[rule:2a]  | RL 24Jan21 can't be a lone V that is 'be' which would be a past perfect construction\r\n"
				+ "    <VP_2> == [head:[rootgloss:become]] -> ~[rule:2a]  | RL 5Mar21 can't be a lone V that is 'become' which would be a past perfect construction\r\n"
				+ "    <VP_2> == [head:[rootgloss:become]] -> ~[rule:9f]  | RL 5Mar21 can't be passive construction\r\n"
				+ "    <VP_2> == ~[head:[rootgloss:be.prs.sbjv]]          | RL 26May21 can't be subjunctive 'to be'\r\n"
				+ "    <VP_2> == ~[rule:8a]                               | RL 5Mar21 no VP that has a sentential complement\r\n"
				+ "    <VP_2> == [head:[rootgloss:be.prs.3sg]] -> ~[head:[type:[no_intervening:+]]]  | RL 3Jul21 can't have 'ast' alone\r\n"
				, "(patrgrammar (patrRules (patrRule (ruleKW rule) (ruleIdentifier { VP option PrtConj - conjoined VPs with participle on first verb acting as the Conj }) (phraseStructureRule (constituent VP) (ruleDef =) (rightHandSide (constituent VP_1) (optionalConstituents ( (disjunctiveConstituents { (constituent PP) (disjunctionConstituents / (disjunctiveConstituents { (constituent DP) (disjunctionConstituents / (constituent AdvP)) })) (disjunctionConstituents / (constituent PP) (disjunctiveConstituents { (constituent DP) (disjunctionConstituents / (constituent AdvP)) })) (disjunctionConstituents / (disjunctiveConstituents { (constituent DP) (disjunctionConstituents / (constituent AdvP)) }) (constituent PP)) (disjunctionConstituents / (constituent PP_1) (disjunctiveConstituents { (constituent DP) (disjunctionConstituents / (constituent AdvP)) }) (constituent PP)) }) )) (constituent VP_2))) (constraints (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent VP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue copular_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | RL 26Aug20 I don't think this construction ever happens with the 2nd verb having a copular suffix.\\r\\n))) (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (constituent VP_2) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue rootgloss)) : (featureStructureValue be) (closingBracket ]))) (closingBracket ]))) (binop ->) ~ (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (ruleKW rule)) : (featureStructureValue (atomicValue 2a)) (closingBracket ]) (comment | RL 24Jan21 can't be a lone V that is 'be' which would be a past perfect construction\\r\\n))))) (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (constituent VP_2) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue rootgloss)) : (featureStructureValue (atomicValue exist)) (closingBracket ]))) (closingBracket ]))) (binop ->) ~ (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (ruleKW rule)) : (featureStructureValue (atomicValue 2a)) (closingBracket ]) (comment | RL 24Jan21 can't be a lone V that is 'be' which would be a past perfect construction\\r\\n))))) (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (constituent VP_2) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue rootgloss)) : (featureStructureValue (atomicValue be.aux)) (closingBracket ]))) (closingBracket ]))) (binop ->) ~ (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (ruleKW rule)) : (featureStructureValue (atomicValue 2a)) (closingBracket ]) (comment | RL 24Jan21 can't be a lone V that is 'be' which would be a past perfect construction\\r\\n))))) (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (constituent VP_2) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue rootgloss)) : (featureStructureValue (atomicValue become)) (closingBracket ]))) (closingBracket ]))) (binop ->) ~ (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (ruleKW rule)) : (featureStructureValue (atomicValue 2a)) (closingBracket ]) (comment | RL 5Mar21 can't be a lone V that is 'become' which would be a past perfect construction\\r\\n))))) (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (constituent VP_2) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue rootgloss)) : (featureStructureValue (atomicValue become)) (closingBracket ]))) (closingBracket ]))) (binop ->) ~ (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (ruleKW rule)) : (featureStructureValue (atomicValue 9f)) (closingBracket ]) (comment | RL 5Mar21 can't be passive construction\\r\\n))))) (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (constituent VP_2) (closingWedge >)) == (logConstraintExpression ~ (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue rootgloss)) : (featureStructureValue (atomicValue be.prs.sbjv)) (closingBracket ]))) (closingBracket ]) (comment | RL 26May21 can't be subjunctive 'to be'\\r\\n))))) (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (constituent VP_2) (closingWedge >)) == (logConstraintExpression ~ (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (ruleKW rule)) : (featureStructureValue (atomicValue 8a)) (closingBracket ]) (comment | RL 5Mar21 no VP that has a sentential complement\\r\\n))))) (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (constituent VP_2) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue rootgloss)) : (featureStructureValue (atomicValue be.prs.3sg)) (closingBracket ]))) (closingBracket ]))) (binop ->) ~ (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue type)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue no_intervening)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (closingBracket ]))) (closingBracket ]) (comment | RL 3Jul21 can't have 'ast' alone\\r\\n)))))))) <EOF>)");
		// no space between a slash and a constituent
		checkValidGrammar("rule {VP option 6cSpeechNoPPwithPostVObj, past or non-past} | RL 1Jun20\r\n"
				+ "VP = (PP) V {Excl (Excl_1)/NP}             | RL 1Jun20 usually we have a CP, but sometimes no 'that' so allow IP, optional Excl_1 added for #20 8Jun2020\r\n"
				, "(patrgrammar (patrRules (patrRule (ruleKW rule) (ruleIdentifier { VP option 6cSpeechNoPPwithPostVObj, past or non-past }) (comment | RL 1Jun20\\r\\n) (phraseStructureRule (constituent VP) (ruleDef =) (rightHandSide (optionalConstituents ( (constituent PP) )) (constituent V) (disjunctiveConstituents { (constituent Excl) (optionalConstituents ( (constituent Excl_1) )) (disjunctionConstituents / (constituent NP)) } (comment | RL 1Jun20 usually we have a CP, but sometimes no 'that' so allow IP, optional Excl_1 added for #20 8Jun2020\\r\\n)))))) <EOF>)");
		// disjunctive in disjunctive
		checkValidGrammar("rule {VP option 6cIpastNew - V final, DP initial or final or medial (2) and ditransitive with PP, past only}\r\n"
				+ "VP = {DP (AdvP) {(PP_1) PP / PP PP_1} / {(PP_3) PP_2 / PP_2 PP_3} (AdvP) DP / {PP_2 / PP_2 PP_3} DP (AdvP) PP_1} V | RL 5Oct21 - don't think we need 1st PP_3 since it can come in the I' phrase. Try turning it off sometime.\r\n"
				, "(patrgrammar (patrRules (patrRule (ruleKW rule) (ruleIdentifier { VP option 6cIpastNew - V final, DP initial or final or medial ( 2 ) and ditransitive with PP, past only }) (phraseStructureRule (constituent VP) (ruleDef =) (rightHandSide (disjunctiveConstituents { (constituent DP) (optionalConstituents ( (constituent AdvP) )) (disjunctiveConstituents { (optionalConstituents ( (constituent PP_1) )) (constituent PP) (disjunctionConstituents / (constituent PP) (constituent PP_1)) }) (disjunctionConstituents / (disjunctiveConstituents { (optionalConstituents ( (constituent PP_3) )) (constituent PP_2) (disjunctionConstituents / (constituent PP_2) (constituent PP_3)) }) (optionalConstituents ( (constituent AdvP) )) (constituent DP)) (disjunctionConstituents / (disjunctiveConstituents { (constituent PP_2) (disjunctionConstituents / (constituent PP_2) (constituent PP_3)) }) (constituent DP) (optionalConstituents ( (constituent AdvP) )) (constituent PP_1)) }) (constituent V))) (comment | RL 5Oct21 - don't think we need 1st PP_3 since it can come in the I' phrase. Try turning it off sometime.\\r\\n))) <EOF>)");
		// comment after slash in disjunctive unification constraint
		checkValidGrammar("rule {DP option Appos - Apposition} |e.g. John, the butcher, came.\r\n"
				+ "DP = DP_1 DP_2\r\n"
				+ "   {\r\n"
				+ "    <DP_1 head type proper> = +          | RL 29Jun20 For now require one of the DPs to be (or contain) a proper noun. Otherwise we get too many unneeded parses.\r\n"
				+ "    <DP_2 head type proper> = -\r\n"
				+ "   /                                     | DP apposition is mainly of the proper noun type. E.g. به نزد پدرشان یترون lit. to side(of) their.father Jethro\r\n"
				+ "    <DP_1 head type proper> = -\r\n"
				+ "    <DP_2 head type proper> = +\r\n"
				+ "   }\r\n"
				, "(patrgrammar (patrRules (patrRule (ruleKW rule) (ruleIdentifier { DP option Appos - Apposition }) (comment |e.g. John, the butcher, came.\\r\\n) (phraseStructureRule (constituent DP) (ruleDef =) (rightHandSide (constituent DP_1) (constituent DP_2))) (constraints (unificationConstraint (disjunctiveUnificationConstraint { (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue proper)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | RL 29Jun20 For now require one of the DPs to be (or contain) a proper noun. Otherwise we get too many unneeded parses.\\r\\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue proper)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -))) (disjunctionUnificationConstraint / (comment | DP apposition is mainly of the proper noun type. E.g. به نزد پدرشان یترون lit. to side(of) their.father Jethro\\r\\n) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue proper)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (constituent DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue proper)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) }))))) <EOF>)");
		// parameters
		checkValidGrammar("Parameter Start symbol is S"
				, "(patrgrammar (parameters (parameter (parameterKW Parameter) (parameterName Start symbol) is (parameterValue S))) <EOF>)");
		checkValidGrammar("Parameter Attribute order is cat lex sense head\nfirst rest areement\n"
				, "(patrgrammar (parameters (parameter (parameterKW Parameter) Attribute order is (parameterValue cat) (parameterValue lex) (parameterValue sense) (parameterValue head) (parameterValue first) (parameterValue rest) (parameterValue areement))) <EOF>)");
		checkValidGrammar("Parameter Start symbol is S\n"
				+ "Parameter Attribute order is cat lex sense head\nfirst rest areement\n"
				+ "parameter Category feature is Categ\n"
				+ "PARAMETER Lexical feature is Lex\n"
				+ "Parameter Gloss feature is Gloss\n"
				+ "Parameter RootGloss feature is RootGloss\n"
				, "(patrgrammar (parameters (parameter (parameterKW Parameter) (parameterName Start symbol) is (parameterValue S)) (parameter (parameterKW Parameter) Attribute order is (parameterValue cat) (parameterValue lex) (parameterValue sense) (parameterValue head) (parameterValue first) (parameterValue rest) (parameterValue areement)) (parameter (parameterKW parameter) (parameterName Category feature) is (parameterValue Categ)) (parameter (parameterKW PARAMETER) (parameterName Lexical feature) is (parameterValue Lex)) (parameter (parameterKW Parameter) (parameterName Gloss feature) is (parameterValue Gloss)) (parameter (parameterKW Parameter) (parameterName RootGloss feature) is (parameterValue RootGloss))) <EOF>)");
		// Lexical rules
		checkValidGrammar("Define MapKimmoFeatures as\r\n"
				+ "		<out cat>       = <in head pos>\r\n"
				+ "		<out head>      = <in head>\r\n"
				+ "		<out gloss>     = <in root>\r\n"
				+ "		<out root_pos>  = <in root_pos>\n"
				, "(patrgrammar (lexicalRules (lexicalRule (lexicalRuleKW Define) (lexicalRuleName MapKimmoFeatures) as (lexicalRuleDefinition (lexicalRuleMapping (lexicalRuleOutput < out (featurePath (atomicValue cat)) >) (lexicalRuleAssignment =) (lexicalRuleInput < in (featurePath (atomicValue head) (featurePath (atomicValue pos))) >)) (lexicalRuleMapping (lexicalRuleOutput < out (featurePath (atomicValue head)) >) (lexicalRuleAssignment =) (lexicalRuleInput < in (featurePath (atomicValue head)) >)) (lexicalRuleMapping (lexicalRuleOutput < out (featurePath (atomicValue gloss)) >) (lexicalRuleAssignment =) (lexicalRuleInput < in (featurePath (atomicValue root)) >)) (lexicalRuleMapping (lexicalRuleOutput < out (featurePath (atomicValue root_pos)) >) (lexicalRuleAssignment =) (lexicalRuleInput < in (featurePath (atomicValue root_pos)) >))))) <EOF>)");
		// constraint templates
		checkValidGrammar("CONSTRAINT ValidVerb is [finite: +] <-> [tense: []]"
				, "(patrgrammar (constraintTemplates (constraintTemplate (constraintTemplateKW CONSTRAINT) (constraintTemplateName ValidVerb) is (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue finite)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop <->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue tense)) : (featureStructureValue (featureStructure (emptyFeatureStructure []))) (closingBracket ])))))) <EOF>)");
		// Recognize a large grammar
		File largeGrammarFile = new File(Constants.UNIT_TEST_DATA_FILE_EXTRAS);
		File largeGrammarExpectedResultsFile = new File(Constants.UNIT_TEST_LARGE_GRAMMAR_EXTRAS_RECOGNIZER_EXPECTED_RESULTS_FILE);
		try {
			String largeFileContent = new String(Files.readAllBytes(largeGrammarFile.toPath()),
					StandardCharsets.UTF_8);
			String largeFileExpectedResults = new String(Files.readAllBytes(largeGrammarExpectedResultsFile.toPath()),
					StandardCharsets.UTF_8);
			checkValidGrammar(largeFileContent, largeFileExpectedResults);
		} catch (IOException e) {
			e.printStackTrace();
		}

	}

	private void checkValidGrammar(String sDescription, String sANTLRTree) {
		PcPatrGrammarParser parser = parseAString(sDescription);
		int numErrors = parser.getNumberOfSyntaxErrors();
		assertEquals(0, numErrors);
		ParseTree tree = parser.patrgrammar();
		assertEquals(sANTLRTree, tree.toStringTree(parser));
	}

	private PcPatrGrammarParser parseAString(String sInput) {
		CharStream input = CharStreams.fromString(sInput);
		PcPatrGrammarLexer lexer = new PcPatrGrammarLexer(input);
		CommonTokenStream tokens = new CommonTokenStream(lexer);
//		System.out.println(tokens.getTokenSource().getInputStream().toString());
//		for (Token t : lexer.getAllTokens())
//		{
//			System.out.println("type=" + t.getType() + "; content='" + t.getText() +"'");
//		}
		PcPatrGrammarParser parser = new PcPatrGrammarParser(tokens);
		return parser;
	}

	private PcPatrGrammarParser parseAStringExpectFailure(String sInput) {
		CharStream input = CharStreams.fromString(sInput);
		PcPatrGrammarLexer lexer = new PcPatrGrammarLexer(input);
		CommonTokenStream tokens = new CommonTokenStream(lexer);
		PcPatrGrammarParser parser = new PcPatrGrammarParser(tokens);
		parser.removeErrorListeners();
		VerboseListener errListener = new PcPatrGrammarErrorListener.VerboseListener();
		errListener.clearErrorMessageList();
		parser.addErrorListener(errListener);
		// begin parsing at rule 'description'
		ParseTree tree = parser.patrgrammar();
		// uncomment the next two lines to see what parsed
//		String sTree = tree.toStringTree(parser);
//		System.out.println(sTree);
		return parser;
	}

// Not running this test since checking for these makes the parser run much too slowly.
//	@Test
	public void invalidDescriptionsTest() {
		checkInvalidDescription("(S NP) (VP))",
				"mismatched input '(' expecting {<EOF>, 'Let', 'rule', 'Rule', 'RULE', 'parameter', 'Parameter', 'PARAMETER', 'define', 'Define', 'DEFINE', 'constraint', 'Constraint', 'CONSTRAINT', LINECOMMENT}",
				0, 1);
		// template beginning
		checkInvalidDescription("Let", PcPatrGrammarConstants.MISSING_TEMPLATE_NAME_OR_BE, 3, 2);
		checkInvalidDescription("Let xyz", PcPatrGrammarConstants.MISSING_TEMPLATE_NAME_OR_BE, 4, 1);
		checkInvalidDescription("Let xyz be", PcPatrGrammarConstants.MISSING_TEMPLATE_BODY, 10, 1);
		checkInvalidDescription("Let xyz be <abc>", PcPatrGrammarConstants.MISSING_EQUALS_SIGN, 16, 1);

		// Missing opening/closing brace
		checkInvalidDescription("Let xyz be <abc> = d e f}", PcPatrGrammarConstants.MISSING_OPENING_BRACE, 19, 1);
		checkInvalidDescription("Let xyz be <abc> = {d e f", PcPatrGrammarConstants.MISSING_CLOSING_BRACE, 25, 1);
		checkInvalidDescription("Let xyz be <abc> = [d:e] [e:f]}", PcPatrGrammarConstants.MISSING_OPENING_BRACE, 19, 1);
		checkInvalidDescription("Let xyz be <abc> = {[d:e] [e:f]", PcPatrGrammarConstants.MISSING_CLOSING_BRACE, 31, 1);
		checkInvalidDescription("rule S = {NP / DP", PcPatrGrammarConstants.MISSING_CLOSING_BRACE, 17, 1);

		// Missing opening/closing bracket
		checkInvalidDescription("Let xyz be <abc> = {d:e] [e:f]}", PcPatrGrammarConstants.MISSING_OPENING_BRACKET, 20, 1);
		checkInvalidDescription("Let xyz be <abc> = {[d:e] e:f]}", PcPatrGrammarConstants.MISSING_OPENING_BRACKET, 26, 1);
		checkInvalidDescription("Let xyz be <abc> = {de] [e:f]}", PcPatrGrammarConstants.MISSING_OPENING_BRACKET, 20, 1);
		checkInvalidDescription("Let xyz be <abc> = {[d:e [e:f]}", PcPatrGrammarConstants.MISSING_CLOSING_BRACKET, 25, 1);
		checkInvalidDescription("Let xyz be <abc> = {[d:e] [e:f}", PcPatrGrammarConstants.MISSING_CLOSING_BRACKET, 30, 1);
		checkInvalidDescription("Let xyz be <abc> = {[d:e] [ef}", PcPatrGrammarConstants.MISSING_CLOSING_BRACKET, 29, 1);

		// Missing opening/closing wedge
		checkInvalidDescription("Let xyz be abc> = def", PcPatrGrammarConstants.MISSING_OPENING_WEDGE, 11, 1);
		checkInvalidDescription("Let xyz be <abc = def", PcPatrGrammarConstants.MISSING_CLOSING_WEDGE, 16, 1);

		checkInvalidDescription("rule S = VP\nS head> = <VP head>", PcPatrGrammarConstants.MISSING_OPENING_WEDGE, 0, 1);
		checkInvalidDescription("rule S = VP\n<S head = <VP head>", PcPatrGrammarConstants.MISSING_CLOSING_WEDGE, 8, 1);
		checkInvalidDescription("rule S = VP\n<S head> = VP head>", PcPatrGrammarConstants.MISSING_OPENING_WEDGE, 11, 1);
		checkInvalidDescription("rule S = VP\n<S head> = <VP head", PcPatrGrammarConstants.MISSING_CLOSING_WEDGE, 19, 1);

		checkInvalidDescription("rule S = VP\nS head> <= <VP head>", PcPatrGrammarConstants.MISSING_OPENING_WEDGE, 0, 1);
		checkInvalidDescription("rule S = VP\n<S head <= <VP head>", PcPatrGrammarConstants.MISSING_CLOSING_WEDGE, 8, 1);
		checkInvalidDescription("rule S = VP\n<S head> <= VP head>", PcPatrGrammarConstants.MISSING_OPENING_WEDGE, 12, 1);
		checkInvalidDescription("rule S = VP\n<S head> <= <VP head", PcPatrGrammarConstants.MISSING_CLOSING_WEDGE, 20, 1);

		checkInvalidDescription("rule S = VP\nS head> == [finite:+]", PcPatrGrammarConstants.MISSING_OPENING_WEDGE, 2, 1);
		checkInvalidDescription("rule S = VP\n<S head == [finite:+]", PcPatrGrammarConstants.MISSING_CLOSING_WEDGE, 8, 1);

		// Missing opening/closing paren
		checkInvalidDescription("rule S = VP) NP", PcPatrGrammarConstants.MISSING_OPENING_PAREN, 9, 1);
		checkInvalidDescription("rule S = VP NP) PP", PcPatrGrammarConstants.MISSING_OPENING_PAREN, 12, 1);
		checkInvalidDescription("rule S = (VP NP", "no viable alternative at input '(VPNP'", 15, 1);
		checkInvalidDescription("rule S = VP (NP PP", "no viable alternative at input '(NPPP'", 18, 1);

		checkInvalidDescription("rule S = VP / IP) NP", PcPatrGrammarConstants.MISSING_OPENING_PAREN, 12, 1);
		checkInvalidDescription("rule S = (VP / IP NP", PcPatrGrammarConstants.MISSING_CLOSING_PAREN, 20, 1);

		checkInvalidDescription("rule IP = I <IP head> == ~[subject:[head:[type:[coordination:+]]]]"
				+ "& [type:[pro-drop:-]])"
				, "extraneous input ')' expecting {<EOF>, 'Let', 'rule', 'Rule', 'RULE', 'parameter', 'Parameter', 'PARAMETER', 'define', 'Define', 'DEFINE', 'constraint', 'Constraint', 'CONSTRAINT', LINECOMMENT}"
				, 87, 1);
		checkInvalidDescription("rule IP = I <IP head> == ~([subject:[head:[type:[coordination:+]]]]"
				+ "& [type:[pro-drop:-]]"
				, PcPatrGrammarConstants.MISSING_CLOSING_PAREN, 88, 1);

		// Missing colon
		checkInvalidDescription("Let xyz be <abc> = {[d e] [e:f]}", PcPatrGrammarConstants.MISSING_COLON, 23, 1);
		checkInvalidDescription("Let xyz be <abc> = {[d:[e g]] [e:f]}", PcPatrGrammarConstants.MISSING_COLON, 26, 1);

		// Missing binop
		checkInvalidDescription("rule IP = I <IP head> == [subject:[head:[type:[coordination:+]]]]"
				+ " [type:[pro-drop:-]]"
				, PcPatrGrammarConstants.MISSING_BINOP, 66, 1);
		checkInvalidDescription("rule IP = I <IP head> == ~[subject:[head:[type:[coordination:+]]]]"
				+ " [type:[pro-drop:-]]"
				, PcPatrGrammarConstants.MISSING_BINOP, 67, 1);
		checkInvalidDescription("rule IP = I <IP head> == [subject:[head:[type:[coordination:+]]]]"
				+ " ~[type:[pro-drop:-]]"
				, PcPatrGrammarConstants.MISSING_BINOP, 66, 1);
		checkInvalidDescription("rule IP = I <IP head> == ~[subject:[head:[type:[coordination:+]]]]"
				+ " ~[type:[pro-drop:-]]"
				, PcPatrGrammarConstants.MISSING_BINOP, 67, 1);
	}

	private void checkInvalidDescription(String sDescription, String sFailedPortion, int iPos,
			int iNumErrors) {
		PcPatrGrammarParser parser = parseAStringExpectFailure(sDescription);
		assertEquals(iNumErrors, parser.getNumberOfSyntaxErrors());
		VerboseListener errListener = (VerboseListener) parser.getErrorListeners().get(0);
		assertNotNull(errListener);
		PcPatrGrammarErrorInfo info = errListener.getErrorMessages().get(0);
		assertNotNull(info);
		assertEquals(sFailedPortion, info.getMsg());
		assertEquals(iPos, info.getCharPositionInLine());
	}

}
