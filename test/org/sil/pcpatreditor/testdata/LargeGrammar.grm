|-PC-PATR Grammar file for FARSI, Based on FARPatr-2019 but ergative version, changing case features to non-binary May 2019, Cutting out most extra rules version 2 Jan 2020  Now no case in glosses RL Apr 2020

|- additional templates for Balochi/Gilaki conflicts 6/21/19
||Let Gil_accusative          be  [ ]

|- additional templates for Balochi 3/29/19

|Let benefactor              be  <head case>                                 = benefactor
Let direct                  be  <head case>                                 = direct
||Let object                  be  <head case>                                 = objective
Let object_case             be  <head case>                                 = objective
Let generic                 be  <head type generic>                         = +
Let attributive             be  <head type attributive>                     = +
Let definite                be  <head type indefinite>                      = -
Let translates2prep         be  <head type translates2Prep>                 = +
Let modifier_required       be  <head type modifier_required>               = +   ||testing for ez 20Aug2019

|-***********************************************************
|-Feature templates

Let absolutive              be  <head case>                                 = absolutive
Let -absolutive             be  <head case>                                 = {ergative genitive dative}
Let accusative              be  <head case>                                 = accusative
Let -accusative             be  <head case>                                 = {nominative genitive dative}
Let AdjP-final              be  <head type AdjP-final>                      = +
                                <head type AdjP-initial>                    = -
Let AdjP-initial            be  <head type AdjP-initial>                    = +
                                <head type AdjP-final>                      = -
Let AdvP-final              be  <head type AdvP-final>                      = +
                                <head type AdvP-initial>                    = -
Let AdvP-initial            be  <head type AdvP-initial>                    = +
                                <head type AdvP-final>                      = -
Let animate                 be  <head type animate>                         = +
Let animate_object          be  <head object head type animate>             = +
Let animate_subject         be  <head subject head type animate>            = +
Let -animate                be  <head type animate>                         = -
Let -animate_object         be  <head object head type animate>             = -
Let -animate_subject        be  <head subject head type animate>            = -
Let benefactor              be  <head case>                                 = benefactor
Let causative               be  <head infl valence causative>               = +
Let causative_syntax                     be   { [head:[infl:[valence:[causative:+]]
                                                       type:[causative_syntax:+]
                                                       embedded:[cat:IP]]]
                                                 [head:[type:[causative_syntax:+
                                                              transitive:+]
                                                        embedded:[cat:none]]] }
Let comma                   be  <head type comma>                           = +
Let completive              be  <head infl aspect completive>               = +
Let compound                be  <head type compound>                        = +
Let -compound               be  <head type compound>                        = -
Let comp_suffix             be  <head type comp_suffix>                     = +
Let conj_suffix             be  <head type conj_suffix>                     = +
                                <head type participle>                      = -
Let conjoins_DP             be  <head type conjoins_DP>                     = +
Let conjoins_IP             be  <head type conjoins_IP>                     = +
Let -conjoins_DP            be  <head type conjoins_DP>                     = -
Let -conjoins_IP            be  <head type conjoins_IP>                     = -
Let continuative            be  <head infl aspect continuative>             = +
Let copular                 be  <head type copular>                         = +
                                <head type transitive>                      = -
Let -copular                be  <head type copular>                         = -
                                <head type transitive>                      = +
Let copular_suffix          be  <head type copular_suffix>                  = +
                                    [copular]
Let CP-final                be  <head type CP-final>                        = +
Let -CP-final               be  <head type CP-final>                        = -
Let CP-initial              be  <head type CP-initial>                      = +
Let -CP-initial             be  <head type CP-initial>                      = -
Let CP-specifier-initial    be  <head type CP-specifier-initial>            = +
Let declarative             be  <head infl mood declarative>                = +
Let ditransitive            be  <head type ditransitive>                    = +
                                <head type transitive>                      = +
Let -ditransitive           be  <head type ditransitive>                    = -  |testing for adj 5
                                <head type transitive>                      = +
Let DP-final                be  <head type DP-final>                        = +
Let -DP-final               be  <head type DP-final>                        = -
Let DP-initial              be  <head type DP-initial>                      = +
Let -DP-initial             be  <head type DP-initial>                      = -
Let DO_contraction          be  <head type DO_contraction>                  = +
Let dual                    be  <head agr number dual>                      = +
Let dual_object             be  <head object head agr number dual>          = +
Let dual_subject            be  <head subject head agr number dual>         = +
Let embedded_subjunctive    be  <embedded infl mood realis>                 = - 
                                <embedded infl mood subjunctive>            = +    | Feb2020
Let ergative                be  <head case>                                 = ergative
Let -ergative               be  <head case>                                 = {absolutive genitive}
Let exclusive               be  <head agr person first>                     = +
                                <head agr person second>                    = -         
Let feminine                be  <head agr gender feminine>                  = +
Let feminine_object         be  <head object head agr gender feminine>      = +
Let feminine_subject        be  <head subject head agr gender feminine>     = +
Let first                   be  <head agr person first>                     = +
                                <head agr person second>                    = !-
                                <head agr person third>                     = -
Let first_exclusive_subject be  <head subject head agr person first>        = +
                                <head subject head agr person second>       = -
Let first_exclusive_object  be  <head object head agr person first>         = +
                                <head object head agr person second>        = -
Let first_inclusive_subject be  <head subject head agr person first>        = +
                                <head subject head agr person second>       = +
Let first_inclusive_object  be  <head object head agr person first>         = +
                                <head object head agr person second>        = +
Let first_object            be  <head object head agr person first>         = +
                                <head object head agr person second>        = -
                                <head object head agr person third>         = -
                                <head type object_agr_suffix>               = +
Let first_subject           be  <head subject head agr person first>        = +
                                <head subject head agr person second>       = -
                                <head subject head agr person third>        = -
Let future                  be  <head infl tense future>                    = +
Let gen_initial             be  <head type gen_initial>                     = +
Let genitive                be  <head case>                                 = genitive
Let genitive-accusative     be  <head case>                                 = {genitive accusative}
Let -genitive               be  <head case>                                 = {nominative accusative}
Let genitive_suffix         be  <head type genitive_suffix>                 = +  
                                [genitive]   
Let habitual                be  <head infl aspect habitual>                 = +
Let human                   be  <head type human>                           = +
                                [animate]
Let -human                  be  <head type human>                           = -
Let imperative              be  <head infl mood imperative>                 = +
                                <head subject head agr person second>       = +   |for Adj 4
                                <head subject head agr person third>        = -   |for Adj 4
Let imperfective            be  <head infl aspect perfective>               = -
Let impersonal		    be	<head type impersonal>			    = +
Let inclusive               be  <head agr person second>                    = +
Let incompletive            be  <head infl aspect completive>               = -
Let indefinite              be  <head type indefinite>                      = +
                                <head type relative>                        = -
Let infinitive              be  <head infl finite>                          = -
Let interrogative           be  <head infl mood interrogative>              = +
                                <head type question>                        = +
Let -interrogative          be  <head infl mood interrogative>              = -
                                <head type question>                        = -
Let intransitive            be  <head type transitive>                      = -
Let irrealis                be  <head infl mood realis>                     = -
Let locative                be  <head type locative>                        = +
                                <head type temporal>                        = !-
Let manner                  be  <head type manner>                          = +
Let -manner                 be  <head type manner>                          = -
Let masculine               be  <head agr gender masculine>                 = +
Let masculine_object        be  <head object head agr gender masculine>     = +
Let masculine_subject       be  <head subject head agr gender masculine>    = +
Let modifies_Adj            be  <head type modifies_Adj>                    = +
Let modifies_Adv            be  <head type modifies_Adv temporal>           = +
                                <head type modifies_Adv locative>           = +
                                <head type modifies_Adv manner>             = +
                                <head type modifies_Adv reason>             = +
Let modifies_Adv-reason     be  <head type modifies_Adv reason>             = -
                                <head type modifies_Adv locative>           = +
                                <head type modifies_Adv manner>             = +
                                <head type modifies_Adv temporal>           = +
Let modifies_locative       be  <head type modifies_Adv locative>           = +
Let modifies_manner         be  <head type modifies_Adv manner>             = +
Let modifies_NP             be  <head type modifies_NP>                     = +
Let modifies_NPrep          be  <head type modifies_NPrep>                  = +
Let modifies_PP             be  <head type modifies_PP>                     = +
Let modifies_Q              be  <head type modifies_Q>                      = +
Let modifies_reason         be  <head type modifies_Adv reason>             = +
Let modifies_temporal       be  <head type modifies_Adv temporal>           = +
Let motion                  be  <head type motion>                          = +
Let negative                be  <head infl polarity>                        = -
Let negative_prefix         be  <head type negative_prefix>                 = +  
                                [negative]
Let negative_suffix         be  <head type negative_suffix>                 = +
                                [negative]
Let neuter                  be  <head agr gender neuter>                    = +
Let neuter_object           be  <head object head agr gender neuter>        = +
Let neuter_subject          be  <head subject head agr gender neuter>       = +
Let nominative              be  <head case>                                 = nominative
Let -nominative             be  <head case>                                 = {accusative genitive}
Let oblique                 be  <head case>                                 = oblique
Let participle              be  <head type participle>                      = +
Let partitive               be  <head type partitive>                       = +
Let passive                 be  <head type passive>                         = +
Let -passive                be  <head type passive>                         = -
Let passive.optional        be  <head type passive>                         = {+ -}
Let past                    be  <head infl tense past>                      = +
                                <head infl tense present>                   = -
Let perfective              be  <head infl aspect perfective>               = +
Let plural                  be  <head agr number plural>                    = +
                                <head agr number singular>                  = -
Let plural_object           be  <head object head agr number plural>        = +
                                <head object head agr number singular>      = -
                                <head type object_agr_suffix>               = +  |added 24May19
Let plural_subject          be  <head subject head agr number plural>       = +
                                <head subject head agr number singular>     = -
Let poss_dual               be  <head possessor head agr number dual>       = +
                                <head possessor head agr number singular>   = -
                                <head possessor head agr number plural>     = -
Let poss_exclusive          be  <head possessor head agr person first>      = +
                                <head possessor head agr person second>     = -
                                <head possessor head agr person third>      = -
Let poss_feminine           be  <head possessor head agr gender feminine>   = +
Let poss_first              be    [poss_exclusive]
Let poss_inclusive          be  <head possessor head agr person first>      = +
                                <head possessor head agr person second>     = +
                                <head possessor head agr person third>      = -
Let poss_masculine          be  <head possessor head agr gender masculine>  = +
Let poss_plural             be  <head possessor head agr number plural>     = +
                                <head possessor head agr number singular>   = -
Let poss_second             be  <head possessor head agr person first>      = -
                                <head possessor head agr person second>     = +
                                <head possessor head agr person third>      = -
Let poss_singular           be  <head possessor head agr number plural>     = -
                                <head possessor head agr number singular>   = +
Let poss_third              be  <head possessor head agr person first>      = -
                                <head possessor head agr person second>     = -
                                <head possessor head agr person third>      = +
Let possessed               be  <head type possessed>                       = +
Let potential               be  <head infl aspect potential>                = +
Let PP-final                be  <head type QP-final>                        = +
                                <head type QP-initial>                      = -
Let PP-initial              be  <head type QP-initial>                      = +
                                <head type QP-final>                        = -
Let prefix_Prep             be  <head type prefix_Prep>                     = +
Let present                 be  <head infl tense present>                   = +
                                <head infl tense past>                      = -
Let progressive             be  <head infl aspect progressive>              = +
Let question                be  <head type question>                        = +
Let -question               be  <head type question>                        = -
Let QP-final                be  <head type QP-final>                        = +
                                <head type QP-initial>                      = -
Let QP-initial              be  <head type QP-initial>                      = +
                                <head type QP-final>                        = -
Let quantifier              be  <head type quantifier>                      = +
Let reason                  be  <head type reason>                          = +
Let realis                  be  <head infl mood realis>                     = +
Let reciprocal              be  <head type reciprocal>                      = +
Let reflexive               be  <head type reflexivity>                       = +
Let relative                be  <head type relative>                        = +
                                <head type indefinite>                      = -
Let -relative               be  <head type relative>                        = -
                                <head type indefinite>                      = -
Let +root                   be  <head type root>                            = +
Let -root                   be  <head type root>                            = -
Let second                  be  <head agr person second>                    = +
                                <head agr person first>                     = -
                                <head agr person third>                     = -
Let second_object           be  <head object head agr person second>        = +
                                <head object head agr person first>         = -
                                <head object head agr person third>         = -
                                <head type object_agr_suffix>               = +
Let second_subject          be  <head subject head agr person second>       = +
                                <head subject head agr person first>        = -
                                <head subject head agr person third>        = -
Let sentential              be  <head type sentential>                      = +
Let short_infinitive        be  <head infl finite>                          = short
Let singular                be  <head agr number singular>                  = +
                                <head agr number plural>                    = -
Let singular_object         be  <head object head agr number singular>      = +
                                <head object head agr number plural>        = -
                                <head type object_agr_suffix>               = +
Let singular_subject        be  <head subject head agr number singular>     = +
                                <head subject head agr number plural>       = -
Let stative                 be  <head infl aspect stative>                  = +
Let stand-alone             be  <head type stand-alone>                     = +
Let subjunctive             be  <head infl mood subjunctive>                = +
                                <head infl mood realis>                     = -
Let suffix_Pn               be  <head type suffix_Pn>                       = +
Let temporal                be  <head type temporal>                        = +
Let -temporal               be  <head type temporal>                        = -
Let third                   be  <head agr person third>                     = +
                                <head agr person first>                     = -
                                <head agr person second>                    = -
Let third_object            be  <head object head agr person third>         = +
                                <head object head agr person first>         = -
                                <head object head agr person second>        = -
                                <head type object_agr_suffix>               = +
Let third_subject           be  <head subject head agr person third>        = +
                                <head subject head agr person first>        = -
                                <head subject head agr person second>       = -
Let transitive              be  <head type transitive>                      = +
Let transitive_motion       be  <head type transitive_motion>               = +
Let transitive.optional     be  <head type transitive>                      = {+ -} | 21Jul03
Let wh                      be  <head type wh>                              = +
Let -wh                     be  <head type wh>                              = -


|-special features for compounding restrictions - these only forced to compound when rootgloss matches. Rules currently allow up to 5 rootglosses.

Let compounds_with_bring1_intrans            be <head type compounds_with1> = bring
                                                <head type transitive>      = -        
                                                <head type compound>        = +
Let compounds_with_bring1_trans              be <head type compounds_with1> = bring
                                                <head type transitive>      = +          
                                                <head type compound>        = +
Let compounds_with_bring2_intrans            be <head type compounds_with2> = bring
                                                <head type transitive>      = -        
                                                <head type compound>        = +
Let compounds_with_come1_intrans             be <head type compounds_with1> = come
                                                <head type transitive>      = -
                                                <head type compound>        = +
Let compounds_with_come2_intrans             be <head type compounds_with2> = come
                                                <head type transitive>      = -
                                                <head type compound>        = +
Let compounds_with_do1_intrans               be <head type compounds_with1> = do
                                                <head type transitive>      = -
                                                <head type compound>        = +
Let compounds_with_do1_trans                 be <head type compounds_with1> = do
                                                <head type transitive>      = +          
                                                <head type compound>        = +
Let compounds_with_do2_trans                 be <head type compounds_with2> = do
                                                <head type transitive>      = +          
                                                <head type compound>        = +
Let compounds_with_do2_intrans               be <head type compounds_with2> = do
                                                <head type transitive>      = -
                                                <head type compound>        = +
Let compounds_with_do3_intrans               be <head type compounds_with3> = do
                                                <head type transitive>      = -
                                                <head type compound>        = +
Let compounds_with_do4_intrans               be <head type compounds_with4> = do
                                                <head type transitive>      = -
                                                <head type compound>        = +
Let compounds_with_fall1_intrans             be <head type compounds_with1> = fall
                                                <head type transitive>      = -
                                                <head type compound>        = +
Let compounds_with_give1_trans               be <head type compounds_with1> = give
                                                <head type transitive>      = +          
                                                <head type compound>        = +
Let compounds_with_give1_intrans             be <head type compounds_with1> = give
                                                <head type transitive>      = -          
                                                <head type compound>        = +
Let compounds_with_have1_intrans             be <head type compounds_with1> = have
                                                <head type transitive>      = -
                                                <head type compound>        = +
Let compounds_with_hit1_intrans              be <head type compounds_with1> = hit
                                                <head type transitive>      = -
                                                <head type compound>        = +
Let compounds_with_hit2_intrans              be <head type compounds_with2> = hit
                                                <head type transitive>      = -
                                                <head type compound>        = +
Let compounds_with_hit3_intrans              be <head type compounds_with3> = hit
                                                <head type transitive>      = -
                                                <head type compound>        = +
Let compounds_with_pull1_intrans             be <head type compounds_with1> = pull
                                                <head type transitive>      = -
                                                <head type compound>        = +
Let compounds_with_pull2_intrans             be <head type compounds_with2> = pull
                                                <head type transitive>      = -
                                                <head type compound>        = +
Let compounds_with_sew1_intrans              be <head type compounds_with1> = sew
                                                <head type transitive>      = -
                                                <head type compound>        = +
Let compounds_with_supply1_intrans           be <head type compounds_with1> = supply
                                                <head type transitive>      = -
                                                <head type compound>        = +

| Need to be redone or removed
Let compounds_with_آمدن be                      <head type compounds_with1> = come.pst
                                                <head type compound> = +
Let compounds_with_آمدن،آوردن be                <head type compounds_with1> = come.pst
                                                <head type compounds_with2> = bring.pst
                                                <head type compound> = +
Let compounds_with_آمدن،آوردن،بردن،کردن be      <head type compounds_with1> = come.pst
                                                <head type compounds_with2> = bring.pst
                                                <head type compounds_with3> = carry.pst
                                                <head type compounds_with4> = do.pst
                                                <head type compound> = +
Let compounds_with_آمدن،آوردن،شدن،کردن be       <head type compounds_with1> = come.pst
                                                <head type compounds_with2> = bring.pst
                                                <head type compounds_with3> = become.pst
                                                <head type compounds_with4> = do.pst
                                                <head type compound> = +
Let compounds_with_آمدن،آوردن،رفتن،فرستادن be   <head type compounds_with1> = come.pst
                                                <head type compounds_with2> = bring.pst
                                                <head type compounds_with3> = go.pst
                                                <head type compounds_with4> = send.pst
                                                <head type compound> = +
Let compounds_with_اندوختن،یافتن be             <head type compounds_with1> = amass.pst
                                                <head type compounds_with2> = find.pst
                                                <head type compound> = +
Let compounds_with_آوردن be                     <head type compounds_with1> = bring.pst
                                                <head type compound> = +
Let compounds_with_آوردن،دادن be                <head type compounds_with1> = bring.pst
                                                <head type compounds_with2> = give.pst
                                                <head type compound> = +
Let compounds_with_آوردن،دادن،گشتن be           <head type compounds_with1> = bring.pst
                                                <head type compounds_with2> = give.pst
                                                <head type compounds_with3> = turn.pst
                                                <head type compound> = +
Let compounds_with_آوردن،داشتن be               <head type compounds_with1> = آوردن
                                                <head type compounds_with2> = داشتن
                                                <head type compound> = +
Let compounds_with_بخشیدن،دادن،یافتن be         <head type compounds_with1> = بخشیدن
                                                <head type compounds_with2> = دادن
                                                <head type compounds_with3> = یافتن
                                                <head type compound> = +
Let compounds_with_بر‌‌آوردن،زدن،کردن،کشیدن   be  <head type compounds_with1> = بر‌‌آوردن
                                                <head type compounds_with2> = زدن
                                                <head type compounds_with3> = کردن
                                                <head type compounds_with4> = کشیدن
                                                <head type compound> = +
Let compounds_with_پوشیدن،دوختن be              <head type compounds_with1> = پوشیدن
                                                <head type compounds_with2> = دوختن
                                                <head type compound> = +
Let compounds_with_خوردن،خریدن،دادن be          <head type compounds_with1> = خوردن
                                                <head type compounds_with2> = خریدن
                                                <head type compounds_with3> = دادن
                                                <head type compound> = +
Let compounds_with_خواندن be                    <head type compounds_with1> = خواندن
                                                <head type compound> = +
Let compounds_with_دادن  be                     <head type compounds_with1> = دادن
                                                <head type compound> = +
Let compounds_with_دادن،فرا‌‌دادن،سپردن،کردن be <head type compounds_with1> = دادن
                                                <head type compounds_with2> = فرا‌‌دادن
                                                <head type compounds_with3> = سپردن
                                                <head type compounds_with4> = کردن
                                                <head type compound> = +
Let compounds_with_دادن،فرمودن،کردن be          <head type compounds_with1> = دادن
                                                <head type compounds_with2> = فرمودن
                                                <head type compounds_with3> = کردن
                                                <head type compound> = +
Let compounds_with_دادن،کردن be                 <head type compounds_with1> = دادن
                                                <head type compounds_with2> = کردن
                                                <head type compound> = +
Let compounds_with_دادن،گرفتن be                <head type compounds_with1> = دادن
                                                <head type compounds_with2> = گرفتن
                                                <head type compound> = +
Let compounds_with_دادن،گفتن be                 <head type compounds_with1> = دادن
                                                <head type compounds_with2> = گفتن
                                                <head type compound> = +
Let compounds_with_دادن،یافتن be                <head type compounds_with1> = دادن
                                                <head type compounds_with2> = یافتن
                                                <head type compound> = +
Let compounds_with_داشتن،کردن be                <head type compounds_with1> = داشتن
                                                <head type compounds_with2> = کردن
                                                <head type compound> = +
Let compounds_with_داشتن،شدن،کردن،نمودن be      <head type compounds_with1> = داشتن
                                                <head type compounds_with2> = شدن
                                                <head type compounds_with3> = کردن
                                                <head type compounds_with4> = نمودن
                                                <head type compound> = +
Let compounds_with_داشتن،کردن،نمودن be          <head type compounds_with1> = داشتن
                                                <head type compounds_with2> = کردن
                                                <head type compounds_with3> = نمودن
                                                <head type compound> = +
Let compounds_with_دیدن  be                     <head type compounds_with1> = دیدن
                                                <head type compound> = +
Let compounds_with_رسیدن be                     <head type compounds_with1> = رسیدن
                                                <head type compound> = +
Let compounds_with_ساختن،شدن،کردن be            <head type compounds_with1> = ساختن
                                                <head type compounds_with2> = شدن
                                                <head type compounds_with3> = کردن
                                                <head type compound> = +
Let compounds_with_ساختن،شدن،کردن،گشتن be       <head type compounds_with1> = ساختن
                                                <head type compounds_with2> = شدن
                                                <head type compounds_with3> = کردن
                                                <head type compounds_with4> = گشتن
                                                <head type compound> = +
Let compounds_with_ساختن be                     <head type compounds_with1> = ساختن
                                                <head type compound> = +
Let compounds_with_شدن be                       <head type compounds_with1> = شدن
                                                <head type compound> = +
Let compounds_with_شدن،کردن be                  <head type compounds_with1> = شدن
                                                <head type compounds_with2> = کردن
                                                <head type compound> = +
Let compounds_with_شدن،کردن،نمودن be            <head type compounds_with1> = شدن
                                                <head type compounds_with2> = کردن
                                                <head type compounds_with3> = نمودن
                                                <head type compound> = +
Let compounds_with_شمردن،گرفتن،نمودن be         <head type compounds_with1> = شمردن
                                                <head type compounds_with2> = گرفتن
                                                <head type compounds_with3> = نمودن
                                                <head type compound> = +
Let compounds_with_کردن be                      <head type compounds_with1> = do.pst
                                                <head type compound> = +
Let compounds_with_کردن،گفتن be                 <head type compounds_with1> = کردن
                                                <head type compounds_with2> = گفتن
                                                <head type compound> = +
Let compounds_with_کردن،شدن be                  <head type compounds_with1> = کردن
                                                <head type compounds_with2> = شدن
                                                <head type compound> = +
Let compounds_with_کردن،نمودن be                <head type compounds_with1> = کردن
                                                <head type compounds_with2> = نمودن
                                                <head type compound> = +
Let compounds_with_گفتن be                      <head type compounds_with1> = گفتن
                                                <head type compound> = +
Let compounds_with_گزیدن be                     <head type compounds_with1> = گزیدن
                                                <head type compound> = +
Let compounds_with_گزیدن،کردن be                <head type compounds_with1> = گزیدن
                                                <head type compounds_with2> = کردن
                                                <head type compound> = +
Let compounds_with_یافتن be                     <head type compounds_with1> = یافتن
                                                <head type compound> = +

|-Category changes and defaults

Let Adj                     be  <cat> = !Adj
                                <head type ordinal>             = !-
                                <head type wh>                  = !-
                                <head type indefinite>          = !-
                                <head type sentential>          = !-
                                <head type DP-initial>          = !-
                                <head type genitive_suffix>     = !-
                                <head type negative_suffix>     = !-
                                <head type negative_prefix>     = !-
                                <head type attributive>         = !-
                                <head case>                     = !direct
                                <head type relative>            = !-
                                <head type comma>               = !-
                                <head type impersonal>          = !- |CB 24Jul06
                                <head type compounds_with2>     = !none
                                <head type compounds_with3>     = !none
                                <head type compounds_with4>     = !none
                                <head type compound>            = !unspecified

Let Adv                     be  <cat> = !Adv
                                <head type wh>            = !-
                                <head case>                     = !direct
                                <head infl polarity>            = !+
                                <head type modifier-final>      = -
                                <head type modifier-initial>    = -
                                <head type manner>              = !-
                                <head type comma>               = !-
                                <head type temporal>            = !-
                                <head type locative>            = !-
                
Let Art                     be  <cat> = !Art
                                <head type wh>                  = !-
                                <head type comma>               = !-
                                <head type negative_suffix>     = !-
                                <head type negative_prefix>     = !-

Let Aux                     be  <cat> = !Aux
                                <head type passive>             = !-
                                <head infl finite>              = !+
                                <head infl tense future>        = !-
                                <head infl mood realis>         = !+
                                <head infl polarity>            = !+
                                <head type comma>               = !-
                                <head type negative_suffix>     = !-
                                <head type negative_prefix>     = !-
                                <head infl aspect perfective>   = !-
                                <head type object_agr_suffix>   = !-   |24May19
                                <head type impersonal>          = !-  

Let C                       be  <cat> = C
                                <head type question>            = !-
                                <head type comma>               = !-

|Mark Conj with - values of features if cannot occur in that position!!
Let Conj                    be  <cat> = !Conj
                                <head type conjoins_DP>         = !+
                                <head type conjoins_IP>         = !+
                                <head type CP-initial>          = !+
                                <head type CP-final>            = !+
                                <head type DP-initial>          = !+
                                <head type DP-final>            = !+ 
                                <head type comma>               = !-

Let Deg                     be  <cat> = Deg
                                <head type DO_contraction>      = !-
                                <head case>                     = !direct
                                <head type modifies_Adj>        = !-
                                <head type modifies_Adv temporal> = !-
                                <head type modifies_Adv locative> = !-
                                <head type modifies_Adv manner> = !-
                                <head type modifies_Adv reason> = !-
                                <head type modifies_NP>         = !-
                                <head type modifies_NPrep>      = !-
                                <head type modifies_PP>         = !-
                                <head type modifies_Q>          = !-
                                <head type quantifier>          = !-
                                <head type wh>                  = !-
                                <head type indefinite>          = !-
                                <head type CP-final>            = !-
                                <head infl polarity>            = !+
                                <head type compound>            = !-
                                <head type DP-final>            = !-
                                <head type relative>            = !-
                                <head type relcl>              = -
                                <head type comma>               = !-
                                <head agr number plural>        = !-
                                <head type apposition>          = -  |17Jan03CB
                                <head type pronoun>             = !-
                                <head type proper>              = !-
                                <head type gen_initial>         = !-  |7Apr03CB
                                <head type comp_suffix>         = !-
                                <head type negative_suffix>     = !-
                                <head type negative_prefix>     = !-
| Deg meaning 'all' needs to be marked plural
                                 
Let Dem                 be  <cat> = !Dem
                                <head type wh>                  = !-
                                <head type indefinite>          = !-
                                <head type DO_contraction>      = !-
                                <head case>                     = !direct
                                <head agr number singular>      = !+
                                <head agr number plural>        = !-
                                <head agr person third>         = !+
                                <head agr person first>         = !-
                                <head agr person second>        = !-
                                <head type relative>            = !-
                                <head type relcl>              = -
                                <head type comma>               = !-
                                <head type apposition>          = - |17Jan03 CB
                                <head type pronoun>             = !-
                                <head type proper>              = !-
                                <head type comp_suffix>         = !-
                                <head type demonstrative>       = + |28Jul03 CB
                                <head type negative_suffix>     = !-
                                <head type negative_prefix>     = !-

Let Excl                    be  <cat> = !Excl
                                <head type comma>               = !-

Let N                       be  <cat> = !N
                                <head agr person third>         = !+
                                <head agr person first>         = !-
                                <head agr person second>        = !-
                                <head agr number singular>      = !+
                                <head agr number plural>        = !-
                                <head case>                     = !direct
                                <head infl polarity>            = !+
                                <head infl finite>              = !+
                                <head type animate>             = !-
                                <head type human>               = !-
                                <head type generic>             = !-
                                <head type wh>                  = -
                                <head type reciprocal>          = !-
                                <head type indefinite>          = !-
                                <head type sentential>          = !-
                                <head type modifier-final>      = -
                                <head type modifier-initial>    = -
                                <head type DO_contraction>      = !-
                                <head type proper>              = !-
                                <head type pronoun>             = !- |set by force_Pn to +, so can't have - w/o default 28Jan03 CB
                                <head type relative>            = !-
                                <head type relcl>              = -
                                <head type genitive_suffix>     = !-
                                <head type comma>               = !-
                                <head type compounds_with2>     = !none
                                <head type compounds_with3>     = !none
                                <head type compounds_with4>     = !none
                                <head type compound>            = !unspecified
                                <head type temporal>            = !-
                                <head type locative>            = !-    |**
                                <head type apposition>          = -  |17Jan03CB
                                <head type reflexivity>           = !- |17Feb03CB
                                <head type case-marked>         = -  |1Apr03CB
                                <head type comp_suffix>         = !-
                                <head type transitive>          = !+ |for compound default case, mark intransitive if needed 17Apr03 CB
                                <head type nonfinalcoordination> = - |15Aug03CB
				<head type NPrep>		= !-  |22Jul06CB
                                <head type negative_suffix>     = !-
                                <head type negative_prefix>     = !-
                                <head type copular_suffix>      = !-  |Apr2020
                
Let Num                     be  <cat> = Num
                                <head type ordinal>             = !-
                                <head type wh>                  = !-
                                <head type indefinite>          = !-
                                <head type DO_contraction>      = !-
                                <head agr number singular>      = !-
                                <head agr number plural>        = !+
                                [DP-initial]
                                <head type relative>            = !-
                                <head type relcl>              = -
                                <head type comma>               = !-
                                <head type apposition>          = -  |17Jan03CB
                                <head type pronoun>             = !-
                                <head type proper>              = !-
                                <head type comp_suffix>         = !-
                                <head type negative_suffix>     = !-
                                <head type negative_prefix>     = !-

Let ordinal                 be  <cat> = !Adj
                                <head type ordinal>             = +
                                <head type indefinite>          = !-
                                <head type genitive_suffix>     = !-
                                <head type comma>               = !-
                                <head type negative_suffix>     = !-
                                <head type negative_prefix>     = !-
    
Let P                       be  <cat> = !P
                                <head type passive>             = !-
                                <head type wh>                  = -
                                <head type partitive>           = !-
                                <head type stand-alone>         = !-
                                <head type prefix_Prep>         = !-
                                <head type suffix_Pn>           = !-
                                <head case>                     = !direct
                                <head type genitive_suffix>     = !-
                                <head type comma>               = !-
                                <head type locative>            = !- |21Apr03CB
				<head type NPrep>		= !-  |22Jul06CB

Let Poss                    be  <cat> = !Poss
                                [genitive]
                                <head type comma>               = !-
                                <head type negative_suffix>     = !-
                                <head type negative_prefix>     = !-

Let Pron                    be  <cat> = !Pron
                                <head type pronoun>             = +
                                <head type proper>              = -
                                <head type wh>                  = !-
                                <head type animate>             = !+
                                <head infl polarity>            = !+
                                <head type reciprocal>          = !-
                                <head type indefinite>          = !-
                                <head type human>               = !+
                                <head type generic>             = !-
                                <head case>                     = !direct
                                <head type locative>            = !-
                                <head type temporal>            = !-
                                <head type modifier-final>      = -
                                <head type modifier-initial>    = -
                                <head type DO_contraction>      = !-
                                <head type relative>            = !-
                                <head type relcl>              = -
                                <head type genitive_suffix>     = !-
                                <head type comma>               = !-
                                <head type apposition>          = -  |17Jan03CB
                                <head type reflexivity>           = !- |17Feb03CB
                                <head type comp_suffix>         = !-
                                <head type compound>            = -
				<head type NPrep>		= !-  |22Jul06CB
                                <head type negative_suffix>     = !-
                                <head type negative_prefix>     = !-
               
Let Q                       be  <cat> = Q
                                <head type wh>                  = !-
                                <head type indefinite>          = !-
                                <head type comma>               = !-
                                <head type pronoun>             = !-
                                <head type proper>              = !-
                                <head type comp_suffix>         = !-
                                <head type negative_suffix>     = !-
                                <head type negative_prefix>     = !-

Let V                       be  <cat> = !V
                                <head type passive>             = !-
                                <head type sentential>          = !-
                                <head type copular>             = !-
                                <head type copular_suffix>      = !-
                                <head type motion>              = !-
                                <head type transitive_motion>   = !-
                                <head type reciprocal>          = !-
                                <head infl finite>              = !+
                                <head infl polarity>            = !+
                                <head type participle>          = !-
                                <head infl mood realis>         = !+
                                <head type conj_suffix>         = !-
                                <head type comma>               = !-
                                <head type impersonal>          = !- |CB 24Jul06
                                <head infl tense present>       = !-
                                <head infl tense past>          = !-
                                <head type compounded>          = -
				<head type participle_passive>  = -
				<head rootgloss_V_2>            = none
                                <head type object_agr_suffix>   = !-   |24May19
                                <head type negative_suffix>     = !-
                                <head type negative_prefix>     = !-
                                <head infl aspect perfective>   = !-
                                <head infl mood subjunctive>    = !-  |20Feb2020
                              				
|- Farsi categories in AMPLE

Let AdjB                    be  [Adj]

Let NB                      be  [N]
				<head type NPrep>		= !-  |22Jul06CB

Let PN                      be  <cat> = !N
                                <head agr person third>         = !+
                                <head agr person first>         = !-
                                <head agr person second>        = !-
                                <head agr number singular>      = !+
                                <head agr number plural>        = !-
                                <head case>                     = !direct
                                <head infl polarity>            = !+
                                <head type animate>             = !+
                                <head type generic>             = !-
                                <head type wh>                  = !-
                                <head type reciprocal>          = !-
                                <head type proper>              = +
                                <head type pronoun>             = -
                                <head type human>               = !+
                                <head type indefinite>          = !-
                                <head type modifier-final>      = -
                                <head type modifier-initial>    = -
                                <head type DO_contraction>      = !-
                                <head type relcl>              = !-
                                <head type relative>            = !-
                                <head type genitive_suffix>     = !-
                                <head type comma>               = !-
                                <head type locative>            = !- |Feb03CB
                                <head type apposition>          = -  |17Jan03CB
                                <head type comp_suffix>         = !-
                                <head infl finite>              = +
                                <head type compound>            = -
				<head type NPrep>		= !-  |22Jul06CB
                                <head type negative_suffix>     = !-
                                <head type negative_prefix>     = !-
  

Let PNP                     be  <cat> = !N
                                <head agr person third>         = !+
                                <head agr person first>         = !-
                                <head agr person second>        = !-
                                <head agr number singular>      = !+
                                <head agr number plural>        = !-
                                <head case>                     = !direct
                                <head infl polarity>            = !+
                                <head type animate>             = !-
                                <head type wh>                  = !-
                                <head type generic>             = !-
                                <head type reciprocal>          = !-
                                <head type proper>              = +
                                <head type pronoun>             = -
                                <head type human>               = !-
                                <head type indefinite>          = !-
                                <head type modifier-final>      = -
                                <head type modifier-initial>    = -
                                <head type DO_contraction>      = !-
                                <head type relcl>              = !-
                                <head type relative>            = !-
                                <head type genitive_suffix>     = !-
                                <head type comma>               = !-
                                <head type locative>            = !+ | Feb03CB
                                <head type apposition>          = -  |17Jan03CB
                                <head type comp_suffix>         = !-
                                <head infl finite>              = +
                                <head type compound>            = -
				<head type NPrep>		= !-  |22Jul06CB
                                <head type negative_suffix>     = !-
                                <head type negative_prefix>     = !-
                
Let Pn                      be  [Pron]
				<head type NPrep>		= !-  |22Jul06CB

Let RefPn                   be  [Pron]  | 31Jan03 RL
                                <head type reflexivity>           = +
                                <head type locative>            = !-
				<head type NPrep>		= !-  |22Jul06CB

Let GenericPn               be  [Pron]  | 31Jan03 RL
                                <head type reflexivity>           = +
                                <head type generic>             = +
                                <head type locative>            = !-
				<head type NPrep>		= !-  |22Jul06CB
|generic pronouns are marked +reflexivity so only need a single constraint to cover both in rules, but also +generic in case a distinction needed  17Feb03 CB

Let Prep                    be  [P]

Let NPrep                   be  [P]                            | 22Aug2019   
                                [locative]
                                <head type apposition>          = -  |17Jan03CB
				<head type NPrep>		= +  |22Jul06CB
                               <head type translates2Prep>      = !-

Let Cop                     be  <cat> = !V
                                [V]
                                [copular]

Let VActor                  be  [N]

Let VPres                   be  [V]
                                [present]
                                <head type impersonal>          = !- |CB 24Jul06
                                <head infl aspect perfective>   = !-

Let VPast                   be  [V]
                                [past]
                                [completive]
                                <head type impersonal>          = !- |CB 24Jul06
                                <head infl aspect perfective>   = !-

Let VSubj                   be  [V]
                                [irrealis]
                                <head type impersonal>          = !- |CB 24Jul06
                                <head infl aspect perfective>   = !-

Let VPart                   be  [V]
                                <head case>                     = !direct
                                <head type impersonal>          = !- |CB 24Jul06
                                <head infl aspect perfective>   = !-
                            
Let VPerf                   be  [V]
                                [perfective]
                                <head type impersonal>          = !- |CB 24Jul06
                                <head infl aspect perfective>   = !-

Let VProg                   be  [V]
                                [progressive]
                                <head type impersonal>          = !- |CB 24Jul06
                                <head infl aspect perfective>   = !-

Let VInf                    be  [V]
                                <head type impersonal>          = !- |CB 24Jul06
                                <head infl aspect perfective>   = !-
                                
Let Quest                   be  [Adv]
                            
Let QPn                     be  <cat> = Pron
                                [Pron]
                                [wh]

Let Quote                   be  <cat> = Quote

|- override the default category.

Let DO                      be  <cat> = Case
                                <head type comma>               = !-
                                <head type negative_suffix>     = !-
                                <head type negative_prefix>     = !-

Let makeAux                 be  <cat> = Aux
                                <head type passive>             = !-
                                <head infl finite>              = !+
                                <head infl tense future>        = !-
                                <head infl mood realis>         = !+
                                <head infl polarity>            = !+
                                <head type comma>               = !-
                                <head type negative_suffix>     = !-
                                <head type negative_prefix>     = !-
                                <head infl aspect perfective>   = !-
                                <head type impersonal>          = !-  


Let makeCase               be  <cat> = Case
                                <head type comma>               = !-
                                <head type negative_suffix>     = !-
                                <head type negative_prefix>     = !-

Let makeAdv               be  <cat> = Adv
                                <head type wh>            = !-
                                <head case>                     = !direct
                                <head type modifier-final>      = -
                                <head type modifier-initial>    = -
                                <head type manner>              = !-
                                <head type comma>               = !-
                                <head type temporal>            = !-
                                <head type locative>            = !-

Let makeAdj               be  <cat> = Adj
                                <head type ordinal>             = !-
                                <head type wh>                  = !-
                                <head type indefinite>          = !-
                                <head type sentential>          = !-
                                <head type DP-initial>          = !-
                                <head type genitive_suffix>     = !-
                                <head type negative_suffix>     = !-
                                <head type negative_prefix>     = !-
                                <head type attributive>         = !-
                                <head case>                     = !direct
                                <head type relative>            = !-
                                <head type comma>               = !-
                                <head type impersonal>          = !- |CB 24Jul06
                                <head type compounds_with2>     = !none
                                <head type compounds_with3>     = !none
                                <head type compounds_with4>     = !none
                                <head type compound>            = !unspecified

Let makeExcl                be  <cat> = Excl
                                <head type comma>               = !-

Let force_Dem               be  <cat> = Dem
                                [Dem]

Let force_Pn                be  <cat> = Pron
                                [Pron]

Let force_Prep              be  <cat> = P
                                <head type passive>             = !-
                                <head type wh>                  = -
                                <head type partitive>           = !-
                                <head case>                     = !direct
                                <head type stand-alone>         = !-
                                <head type comma>               = !-
                                <head type locative>            = !- |21Apr03CB

Let force_V                 be  <cat> = V
                                [V]
                                <head type impersonal>          = !- |CB 24Jul06
                                <head infl aspect perfective>   = !-


|- Farsi categories in FLEX *** newly added 2019 to mirror category mapper in PAWS 

Let adj                  be    [Adj]
Let adv                  be    [Adv]
Let aux                  be    [Aux]
Let conn                 be    [Conj]
Let deg                  be    [Deg]
Let dem                  be    [Dem]
Let indf                 be    [Art]
Let interj               be    [Excl]
Let interogpro-form      be    [Pron]
                               <head type wh>                              = +
                               <head agr person third>                     = +
                               [interrogative] 
Let n                    be    [N]
Let n-irreg              be    [N]
Let npl                  be    [N]
                               <head agr number plural>                    = +
                               <head agr number singular>                  = -
Let nprep                be    [NPrep]
Let nprop                be    [PN]
Let num                  be    [Num]
Let pers                 be    [Pron]                                             |16Aug2019
                               <head type personal>                        = +
                               <head type human>                           = +    |21Aug2019
Let post                 be    [P]
                               <head type translates2Prep>                 = !-
Let prep                 be    [P]
                               <head type translates2Prep>                 = !-
Let pro                  be    [Pron]
Let prt                  be    [N]                                          | trying for particle 16Aug19
Let quant                be    [Q]
Let v                    be    [V]
Let vcomp                be    [V]
                               <head type compound>                        = +    |16Aug2019
Let cop                  be    [V]
                               <head type copular>                         = +
                               <head type transitive>                      = -    |19Aug2019
Let vphrase              be    <cat> = VP
                               <head type object_agr_suffix>               = !-   |24May19
				


|---------------------------------------------------------------------
|-Phrase structure rules

rule {testing}
S = AdvP / DP    |/ VP / PP 
    <S head> = <AdvP head>
    <S head> = <DP head>
|    <S head> = <VP head>
|    <S head> = <PP head>

rule {S option start symbol -  final ya na & Quote allowed}
S = {IP / CP} (Conj Deg) (Quote)
    <S head> = <IP head>
    <S head> = <CP head>
    <IP head type root> = +
    <IP head type conj_suffix> = -     | 16Jul03 CB
    <CP head type root> = +
    <CP head type conj_suffix> = -     | 16Jul03 CB
    <CP head type relcl> = -          | 21Nov03 CB
    <Conj gloss> = or
    <Conj head type CP-final> = +
    <Deg head type CP-final> = +
    <Deg head infl polarity> = -
    <S head type initialP> = - 
    <IP head type relcl> = -            | not a rel clause 21Nov03 CB
    <CP head type relcl> = -            | not a rel clause 21Nov03 CB
    <S rule> = start

rule {S option startInitPP symbol with PP initial elements
and final ya na & Quote allowed}
S = InitP {IP / CP} (Conj Deg) (Quote)
    <S head> = <IP head>
    <S head> = <CP head>
    <IP head subject> = <InitP head subject> | pass reflexive info
    <CP head subject> = <InitP head subject> | pass reflexive info
    <IP head type root> = +
    <IP head type pro-drop> = -     | 28May19 CB 
    <IP head type conj_suffix> = -     | 16Jul03 CB
    <CP head type root> = +
    <CP head type conj_suffix> = -     | 16Jul03 CB
    <CP head type relcl> = -          | 21Nov03 CB
    <InitP head type root> = + 
    <Conj gloss> = or
    <Conj head type CP-final> = +
    <Deg head type CP-final> = +
    <Deg head infl polarity> = -
    <S head type initialP> = + 
    <InitP head type PP> = +               | 17Feb03 CB for generic/reflex
    <InitP head type DP> = -               | 17Feb03 CB for generic/reflex
    <IP head type relcl> = -            | not a rel clause 21Nov03 CB
    <CP head type relcl> = -            | not a rel clause 21Nov03 CB
    <S rule> = startInitPP

rule {S option startInitDP with DP initial elements and final ya na & Quote allowed}
S = InitP IP (Conj Deg) (Quote)
    <S head> = <IP head>
    <IP head subject> = <InitP head subject> | pass reflexive info
    <IP head type root> = +
    <IP head type pro-drop> = -     | 28May19 
    <IP head type conj_suffix> = -     | 16Jul03 CB
    <InitP head type root> = + 
    <Conj gloss> = or
    <Conj head type CP-final> = +
    <Deg head type CP-final> = +
    <Deg head infl polarity> = -
    <S head type initialP> = + 
    {<InitP head type relcl> = -  | 03Apr03 CB
    /<InitP head type relcl> = +  |  relcl in InitP only with overt subject
     <IP head type pro-drop> = -
    }
    <InitP head type DP> = +              | 17Feb03 CB for generic/reflex
    <InitP head type PP> = -              | 17Feb03 CB for generic/reflex
| don't split coordination - these replace logical constraints in subject rules that incorrectly eliminated even adverbial InitPs 17Apr03 CB
    <IP head> == ~([subject:[head:[type:[coordination:+]]]] 
                   & [type:[pro-drop:-]])
    <IP head> == ~([object:[head:[type:[coordination:+]]]] 
                   & [type:[pro-drop:+]])
    <IP head type relcl> = -            | not a rel clause 21Nov03 CB
    <S rule> = startInitDP

rule {S option startCPInitDP with DP initial elements and
final ya na & Quote allowed}
S = InitP CP (Conj Deg) (Quote)
    <S head> = <CP head>
    <CP head subject> = <InitP head subject> | pass reflexive info
    <CP head type root> = +
    <CP head type conj_suffix> = -     | 16Jul03 CB
    <CP head type relcl> = -          | 21Nov03 CB
    <InitP head type root> = + 
    <Conj gloss> = or
    <Conj head type CP-final> = +
    <Deg head type CP-final> = +
    <Deg head infl polarity> = -
    <S head type initialP> = + 
    <InitP head type DP> = +              | 17Feb03 CB for generic/reflex
    <InitP head type PP> = -              | 17Feb03 CB for generic/reflex
    <S rule> = startCPInitDP

rule {S option startInit with nonPP/ DP initial elements and
final ya na & Quote allowed}
S = InitP {IP / CP} (Conj Deg) (Quote)
    <S head> = <IP head>
    <S head> = <CP head>
    <IP head type root> = +
    <IP head type conj_suffix> = -     | 16Jul03 CB
    <CP head type root> = +
    <CP head type conj_suffix> = -     | 16Jul03 CB
    <CP head type relcl> = -          | 21Nov03 CB
    <InitP head type root> = + 
    <Conj gloss> = or
    <Conj head type CP-final> = +
    <Deg head type CP-final> = +
    <Deg head infl polarity> = -
    <S head type initialP> = + 
    <InitP head type PP> = -          | 17Feb03 CB
    <InitP head type DP> = -          | 17Feb03 CB
    <IP head type relcl> = -            | not a rel clause 21Nov03 CB
    <CP head type relcl> = -            | not a rel clause 21Nov03 CB
    <S rule> = startInit

rule {InitP option conj - conjunctions - root or nonroot}
InitP = Conj (Conj_2)
    <InitP head> = <Conj head>
|    <InitP head type comma> = +     |need this to have sentences that start with "w" (and)   | must have comma  ***trying removal of comma requirement 28Jan03 CB 
    <InitP head type initialP> = +      | restrict conjunctions here and in DP 
    <Conj head type CP-initial> = + 
    <Conj_2 head type CP-initial> = +
    <InitP head type PP> = -          | 17Feb03 CB
    <InitP head type DP> = -          | 17Feb03 CB
    <InitP head type comma> <= <Conj_2 head type comma> 
    <InitP rule> = conj

rule {InitP option adv - AdvP - root or nonroot}
InitP = (Conj) AdvP (Conj_2)
    <InitP head> = <AdvP head>
|RL 19Nov02    <InitP head type comma> = +        | must have comma
    <InitP head type initialP> = +     | restrict occurrence in sentential PPs 
    <AdvP head type CP-initial> = +    | mark Adv as -CP-initial if not manner but cannot occur clause initial 
    <AdvP head type manner> = -
    <Conj head type CP-initial> = + 
    <Conj_2 head type CP-initial> = +
    <InitP head type PP> = -          | 17Feb03 CB
    <InitP head type DP> = -          | 17Feb03 CB
    <InitP head type comma> <= <Conj_2 head type comma> 
    <InitP rule> = adv

rule {InitP option excl - Exclamation - root or nonroot}
InitP = (Conj) Excl (Conj_2)
    <InitP head> = <Excl head>
    <InitP head type comma> = +        | must have comma
    <InitP head type initialP> = +     | restrict conjunctions here and in DP 
    <Conj head type CP-initial> = + 
    <Conj_2 head type CP-initial> = +
    <InitP head type PP> = -          | 17Feb03 CB
    <InitP head type DP> = -          | 17Feb03 CB
    <InitP head type comma> <= <Conj_2 head type comma> 
    <InitP rule> = excl

|this rule will also include subject DPs with relative clauses and comma in nonroot IPs
rule {InitP option address - DP address or focus/topic - root or nonroot}
InitP = (Conj / Excl) DP
    <InitP head> = <DP head>
    <InitP head type initialP> = +     | restrict conjunctions here and in DP 
    <InitP head type comma> = +        | must have comma
    <InitP head subject> = <DP head reflexive> | pass reflexive info
    <Conj head type CP-initial> = +
    <DP head type coordination> = -       | not a DP coordination construction
    <DP head type nonfinalcoordination> = -
    <DP head type DO_contraction> = -   | 17Feb03 CB
    <DP head type case-marked> = -
    <DP head case> = nominative
    <DP head case_for_position> = direct  | for apposition 
    <InitP head type PP> = -          | 17Feb03 CB
    <InitP head type DP> = +          | 17Feb03 CB
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <InitP rule> = address

| RL 28Mar03 add this rule
rule {InitP option address2 - DP address or focus/topic - root or nonroot}
InitP = Conj Excl DP
    <InitP head> = <DP head>
    <InitP head type initialP> = +     | restrict conjunctions here and in DP 
    <InitP head type comma> = +        | must have comma
    <InitP head subject> = <DP head reflexive> | pass reflexive info
    <Conj head type CP-initial> = +
    <DP head type coordination> = -       | not a DP coordination construction
    <DP head type nonfinalcoordination> = -
    <DP head type DO_contraction> = -   | 17Feb03 CB
    <DP head type case-marked> = -
    <DP head case> = direct
    <DP head case_for_position> = direct  | for apposition 22Jan03 CB
    <InitP head type PP> = -          | 17Feb03 CB
    <InitP head type DP> = +          | 17Feb03 CB
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <InitP rule> = address2

| RL 10Dec02
rule {InitP option address_conjoined - DP address or focus/topic - root or nonroot}
InitP = Excl DP Conj (Excl_2) DP_2 | e.g. Acts 13:16 <<ay mrdan asraYyly w ay Gyryhwdyan Xdatrs, KwS fra^^dhyd!
    <InitP head> = <DP_2 head>
    <InitP head type initialP> = +     | restrict conjunctions here and in DP 
    <InitP head type comma> = +        | must have comma
    <InitP head subject> = <DP head reflexive> | pass reflexive info
    <InitP head subject> = <DP_2 head reflexive> | pass reflexive info
    <DP head type coordination> = -       | not a DP coordination construction
    <DP head type nonfinalcoordination> = -
    <DP head case> = direct
    <DP head case_for_position> = direct  | adjective/apposition 17Apr03 CB
    <DP_2 head case_for_position> = direct  | adjective/apposition 17Apr03 CB
    <DP_2 head type coordination> = -       | not a DP_2 coordination construction
    <DP_2 head type nonfinalcoordination> = -
    <DP_2 head case> = direct
    <InitP head type PP> = -          | 17Feb03 CB
    <InitP head type DP> = +          | 17Feb03 CB
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP_2 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <InitP rule> = address_conjoined

rule {InitP option manner PP - root only}
InitP = (Conj / Adv) PP (Conj_2)
    <InitP head> = <PP head>
    <InitP head type comma> = +        | must have comma
    <InitP head type root> = +
    <InitP head subject> = <PP head reflexive> | pass reflexive info
    <InitP head type initialP> = +     | restrict occurrence in sentential PPs 
    <Adv head type reason> = +
    <PP head type manner> = +
    <PP head type temporal> = -
    <PP head type locative> = -
|    <PP head type passive> = -          | this may not work, remove if passive P can be here
    <PP head type stranded> = -         |- PP must have overt complement
    <Conj head type CP-initial> = + 
    <Conj_2 head type CP-initial> = +
    <InitP head type PP> = +          | 17Feb03 CB
    <InitP head type DP> = -          | 17Feb03 CB
    <InitP head type comma> <= <Conj_2 head type comma> 
    <InitP rule> = mannerPP

rule {InitP option tempPP - temporal PP - root only}
InitP = (Conj / Adv) PP (Conj_2)
    <InitP head> = <PP head>
    <InitP head type comma> = +        | must have comma
    <InitP head type root> = +
    <InitP head subject> = <PP head reflexive> | pass reflexive info
    <InitP head type initialP> = +     | restrict occurrence in sentential PPs 
    <Adv head type reason> = +
    <PP head type temporal> = +
    <PP head type manner> = -
    <PP head type locative> = -
    <PP head type passive> = -          | this may not work, remove if passive P can be here
    <PP head type stranded> = -         |- PP must have overt complement
    <Conj head type CP-initial> = + 
    <Conj_2 head type CP-initial> = +
    <InitP head type PP> = +          | 17Feb03 CB
    <InitP head type DP> = -          | 17Feb03 CB
    <InitP head type comma> <= <Conj_2 head type comma> 
    <InitP rule> = tempPP

rule {InitP option locPP - locative PP - comma not required - root only}
InitP = (Conj (Conj_1) / Adv) PP (Conj_2)
    <InitP head> = <PP head>
    <InitP head type root> = +
    <InitP head subject> = <PP head reflexive> | pass reflexive info
    <InitP head type initialP> = +     | restrict occurrence in sentential PPs 
    <Adv head type reason> = +
    <Adv head type temporal> = -
    <PP head type manner> = -
    <PP head type locative> = +
    <PP head type temporal> = -
    <PP head type passive> = -          
    <PP head type stranded> = -         |- PP must have overt complement
    <Conj head type CP-initial> = + 
    <Conj_1 head type CP-initial> = + 
    <Conj_2 head type CP-initial> = +
    <InitP head type PP> = +          | 17Feb03 CB
    <InitP head type DP> = -          | 17Feb03 CB
    <InitP head type comma> <= <Conj_2 head type comma> 
    <InitP rule> = locPP

| separated off from locPP rule to avoid possibility of stranded Conj **19Jul06 CB  | 23Jan03 RL removed passive restriction in locPP above E.g. az nsl ayn mrd 
rule {InitP option passivePP - comma not required - root only}
InitP = (Conj (Conj_1) / Adv) PP
    <InitP head> = <PP head>
    <InitP head type root> = +
    <InitP head subject> = <PP head reflexive> | pass reflexive info
    <InitP head type initialP> = +     | restrict occurrence in sentential PPs 
    <Adv head type reason> = +
    <Adv head type temporal> = -
    <PP head type manner> = -
    <PP head type temporal> = -
    <PP head type passive> = +          | 23Jan03 RL removed passive restriction. E.g. az nsl ayn mrd  |this may not work, remove if passive P can be here
    <PP head type stranded> = -         |- PP must have overt complement
    <Conj head type CP-initial> = + 
    <Conj_1 head type CP-initial> = + 
    <InitP head type PP> = +          | 17Feb03 CB
    <InitP head type DP> = -          | 17Feb03 CB
    <InitP head type comma> <= <Conj_1 head type comma> 
    <InitP rule> = passivePP

rule {InitP option CP - adverbial CP - root only}
InitP = (Conj/InitP_2) CP (Conj_2) | RL 07Dec02 allow another InitP inside this InitP e.g.: "bradran, aKr pnd w andrzy bray mrdm daryd, bKwyyd."
    <InitP head> = <CP head>
    <InitP head type comma> = +        | must have comma
    <InitP head type root> = +
    <InitP head type initialP> = +     | restrict occurrence in sentential PPs 
    <InitP_2 head type comma> = +        | must have comma | RL 07Dec02 added
    <InitP head subject> = <InitP_2 head subject> | pass reflexive info
|    <CP head type root> = -           | removed 02Dec02 CB
    <CP head type conj_suffix> = -     | 16Jul03 CB
    <CP head type relcl> = -          | 21Nov03 CB
    <Conj head type CP-initial> = + 
    <Conj_2 head type CP-initial> = +
    <InitP head type PP> = -          | 17Feb03 CB
    <InitP head type DP> = -          | 17Feb03 CB
    <InitP head type comma> <= <Conj_2 head type comma> 
    <InitP rule> = CP

|-***********************************************************
rule {CP option 1 - no fronting, root or non-root}
CP = C'
    <CP head> = <C' head>
    <CP rule> = 1

|-**********************************************************
rule {C' option 1c - head-initial, question, root}
C' = C IP
    <C' head> = <IP head>
    <C' head type question> = <C head type question> | amended 02Dec02 CB
    <C' head type root> = <C head type root>
    <C' head type root> = +
    <C' head type question> = +
    <C head type comma> = -
    <C head type CP-initial> = +
    <C' rule> = 1c

rule {C' option 1creason - head-initial, reason, root}
C' = C IP
    <C' head> = <IP head>
    <C' head type question> = <C head type question> | amended 02Dec02 CB
    <C' head type reason> = <C head type reason> | amended 02Dec02 CB
    <C' head type root> = +
    <C' head type question> = -
    <C head type reason> = +
    <C head type comma> = -
    <C head type CP-initial> = +
    <C' rule> = 1creason

rule {C' option 2c - head-initial, question, non-root}
C' = (C_1) C_2 IP
    <C' head> = <IP head>
    <C' head type question> = <C_2 head type question> |amended 02Dec02 CB
    <C' head type root> = <C_2 head type root>
    <C' head type root> = -
    <C_1 head type comma> = -
    <C_2 head type comma> = -
    <C_1 head type question> = -
    <C_2 head type question> = +
    <C_1 head type CP-initial> = +
    <C_2 head type CP-initial> = +
    <C' rule> = 2c

rule {C' option 2j - head-initial, non-question, non-root}
C' = C IP
    <C' head> = <IP head>
    <C' head type question> = <C head type question>   | RL 13Feb02 if IP has a comma and C doesn't they can't unify for type.
    <C' head type root> = -
    <C' head type question> = -
    <C head type comma> = -
    <C head type CP-initial> = +
    <C embedded> = <IP head embedded>    | pass subcategorization down
    <C' rule> = 2j

|-***********************************************************
rule {IP option 0 - conjoined IPs}
IP = IP_1 Conj IP_2
    <IP head> = <IP_1 head>
    <IP conjoined> = +                | limit recursion
    <IP_1 conjoined> = -
    <IP_2 head type pro-drop> = -
    <IP_1 head type root> = <IP_2 head type root>
    <IP_1 head infl mood realis> = <IP_2 head infl mood realis> | 15Jul03 CB
    <Conj head type conjoins_IP> = +
    <IP head type comma> <= <IP_2 head type comma>  | comma placement for InitP
    <IP_1 head type relcl> = -            | not a rel clause 21Nov03 CB
    <IP_2 head type relcl> = -            | not a rel clause 21Nov03 CB
    <IP rule> = 0

rule {IP option 0a-DP - missing final verb IPs}
IP = IP_1 Conj DP
    <IP head> = <IP_1 head>
    <IP head subject> = <DP head reflexive> | pass reflexive info
    {<DP head case> = direct
     <DP head type case-marked> = -
    /<DP head case> = objective
     <DP head type case-marked> = +
    }
    <DP head type coordination> = -
    <IP head type conjoined> <= +   | mark for checking compounding constraints (special case with relcl2+kh and 5c) 20Oct03 CB
|?|    <IP head type final-conjunct compounds_with1> = <DP head type compounds_with1>
|?|    <IP head type final-conjunct compounds_with2> = <DP head type compounds_with2>
|?|    <IP head type final-conjunct compounds_with3> = <DP head type compounds_with3>
|?|    <IP head type final-conjunct compounds_with4> = <DP head type compounds_with4>
    <IP head type comma> <= <DP head type comma>  | comma placement for InitP
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <Conj> == ~[gloss:namely]
    <IP rule> = 0a-DP

| for ygny type apposition/coordination/relativization, added 24Mar03 CB
rule {IP option 0a-ygny - "ygny"-type apposition}
IP = IP_1 Conj DP
    <IP head> = <IP_1 head>
    <IP_1 head type comma> = +         | must have comma when at end
    <IP head subject> = <DP head reflexive> | pass reflexive info
    {<DP head case> = direct
     <DP head type case-marked> = -
    /<DP head case> = objective
     <DP head type case-marked> = +
    }
    <Conj gloss> = namely
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <IP rule> = Oa-ygny
   
| for ygny type apposition/coordination/relativization, added 24Mar03 CB
rule {IP option 0a-ygnyPP - "ygny"-type apposition with PP}
IP = IP_1 Conj PP
    <IP head> = <IP_1 head>
    <IP_1 head type comma> = +         | must have comma when at end
    <Conj gloss> = namely
    <IP head subject> = <PP head reflexive> | pass reflexive info
    <PP head type sentential> = -
    <IP rule> = Oa-ygnyPP
   
rule {IP option 0a-AdjP - missing final verb IPs}
IP = IP_1 Conj AdjP
    <IP head> = <IP_1 head>
    <AdjP head case> = direct
    <IP head type comma> <= <AdjP head type comma>  | comma placement for InitP
    <IP rule> = 0a-AdjP

rule {IP option 0b - 2 IPs, initial IP in participle form}
IP = IP_1 IP_2
    <IP head> = <IP_2 head>
    <IP conjoined> = +                | limit recursion
    <IP_1 conjoined> = -
    <IP_1 head type conj_suffix> = +  | allow the participle suffix to serve as a conjunction.
    <IP_1 head type comma> = +        | 13Mar03 CB added per Ron
    <IP_1 head type root> = <IP_2 head type root>
    <IP_1 head subject> = <IP_2 head subject>
    <IP_2 head type auxiliary> = -   | RL 10Feb03 No auxiliaries. E.g. we don't want this sentence from Acts 13:26 to be handled here 'ayn pyam njat bray ma frstadh Sdh ast.'
    <IP_1 head type relcl> = -            | not a rel clause 21Nov03 CB
    <IP_2 head type relcl> = -            | not a rel clause 21Nov03 CB
    <IP rule> = 0b

|*****split rule for impersonalV and then non-past and pst transitive*****
rule {IP option 2cImpersonalV - subject initial, required, root clause}  
IP = DP I'
    <IP head> = <I' head>
    <IP head type root> = +
    <IP head type pro-drop> = -
    <IP head subject head agr> = <DP head reflexive head agr> | pass reflexive info
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = namely    | 21Nov03  CB
    /<DP head type relcl> = +        | can have comma if relcl 27Jan03 CB
     <DP head type comma> = +
     <DP head type apposition> = -
    }
    <I' head subject> = <DP>
    <I' head type impersonal> = +       | impersonal verbs do not agree **24Jul06 CB
    <IP head subject head type> = <DP head type>  | pass DP type features for compounding, regardless of agreement 17Apr03 CB
    <IP head subject head possessor> = <DP head possessor> | pass DP possessor info for compounding, regardless of agreement 17Apr03 CB
    {<DP head case> = oblique
    <DP head case_for_position> = oblique  | to know normal case for conjoined DPs
     <DP head agr person third> = +
    /<DP head agr person first> = +        | pronouns different case CB 23May19
     <DP head case> = objective
    <DP head case_for_position> = objective  | to know normal case for conjoined DPs
    /<DP head agr person second> = +        | pronouns different case CB 23May19
     <DP head case> = objective
    <DP head case_for_position> = objective  | to know normal case for conjoined DPs
    }
    <DP head type DO_contraction> = -   | 17Feb03 CB
    <DP head type case-marked> = -
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <IP head> == [type:[reciprocal:+]] -> 
                 [subject:[head:[agr:[number:[plural:+]]]]]
    <IP head> == [object:[head:[type:[reciprocal:+]]]] ->
                 [subject:[head:[agr:[number:[plural:+]]]]]
    <IP head> == [object:[head:[infl:[polarity:-]]]] ->   |if the object is negative, the verb must be negative
                 [infl:[polarity:-]]
    <IP head> == [subject:[head:[infl:[polarity:-]]]] ->   |if the subject is negative, the verb must be negative
                 [infl:[polarity:-]]
    <IP head> == ~[object:[head:[type:[conjunction_gloss:initial_ya]]]]   | to restrict splitting between subject and object
||    <IP head> == [subject:[head:[type:[coordination:+]]]] ->
||                ~[type:[initialP:+]]
    <IP head> == ((([subject:[head:[participle:[cat:V]]]] / [subject:[head:[possessor:[head:[participle:[cat:V]]]]]]))
                   & ([type:[no_intervening:+]])) -> 
                 (([type:[auxiliary:-
                         copular:-
                         passive:-]] 
                 / [type:[auxiliary:+
                          participle:+]])        
                 / [type:[participle_passive:+]])  | to force participle to be w/ V or Aux 12-APR-04
    <IP head> == [rootgloss:^1] ->
                 ~ ( [type:[no_intervening:+]] &    
                   (( [subject:[head:[type:[compounds_with1:^1]]]]
                    / [subject:[head:[type:[compounds_with2:^1]]]])
                    / ([subject:[head:[type:[compounds_with3:^1]]]]
                    / [subject:[head:[type:[compounds_with4:^1]]]]) ) )
    <IP head> == [rootgloss:^1] ->
                 ~ ( [type:[no_intervening:+]] & 
                  (( [subject:[head:[possessor:[head:[type:[compounds_with1:^1]]]]]]
                   / [subject:[head:[possessor:[head:[type:[compounds_with2:^1]]]]]]) 
                   / ([subject:[head:[possessor:[head:[type:[compounds_with3:^1]]]]]] 
                   / [subject:[head:[possessor:[head:[type:[compounds_with4:^1]]]]]]) ))
    <IP head> ==   [object:[head:[rootgloss:^1]]]   ->
                  ~(( [subject:[head:[type:[compounds_with1:^1]]]]
                    / [subject:[head:[type:[compounds_with2:^1]]]])
                    / ([subject:[head:[type:[compounds_with3:^1]]]]
                    / [subject:[head:[type:[compounds_with4:^1]]]]) ) 
    <IP head> ==   [object:[head:[rootgloss:^1]]] ->
                 ~ (( [subject:[head:[possessor:[head:[type:[compounds_with1:^1]]]]]]
                   / [subject:[head:[possessor:[head:[type:[compounds_with2:^1]]]]]]) 
                   / ([subject:[head:[possessor:[head:[type:[compounds_with3:^1]]]]]] 
                   / [subject:[head:[possessor:[head:[type:[compounds_with4:^1]]]]]]) )
    <IP rule> = 2cImpersonalV
    
rule {IP option 2cINon-ImpersonalVNonPast - subject initial, required, root clause}  
IP = DP I'
    <IP head> = <I' head>
    <IP head type root> = +
    <IP head type pro-drop> = -
    <IP head subject head agr> = <DP head reflexive head agr> | pass reflexive info
|    {<DP head type comma> = -                    ||* 22Aug2019 causing failure
|     <DP head type apposition> = -
|    /<DP head type apposition> = +    | 17Jan03  CB
|    /<DP head type apposition> = namely    | 21Nov03  CB
|    /<DP head type relcl> = +        | can have comma if relcl 27Jan03 CB
|     <DP head type comma> = +
|     <DP head type apposition> = -
|    }
     <I' head type impersonal> = -
     <I' head infl tense past> = -
     <I' head subject> = <DP>
|    /<DP head type human> = -                       | only for impersonal V??  22Aug2019 failures
|     <DP head agr person third> = +
|     <DP head agr number plural> = +
|     <I' head subject head agr number singular> = +
|     <I' head subject head agr number plural> = -
|     <I' head subject head agr person second> = -       | RL 2Feb02 allow 1st and 3rd person, but not 2nd.
|    }
|    <IP head subject head type> = <DP head type>  | pass DP type features for compounding, regardless of agreement 17Apr03 CB
|    <IP head subject head possessor> = <DP head possessor> | pass DP possessor info for compounding, regardless of agreement 17Apr03 CB
     <DP head case_for_position> = direct  | to know normal case for conjoined DPs
    <DP head case> = direct
    <DP head type DO_contraction> = -   | 17Feb03 CB
    <DP head type case-marked> = -
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <IP head> == [object:[head:[infl:[polarity:-]]]] ->   |if the object is negative, the verb must be negative
                 [infl:[polarity:-]]
    <IP head> == [subject:[head:[infl:[polarity:-]]]] ->   |if the subject is negative, the verb must be negative
                 [infl:[polarity:-]]
    <IP head> == ~[object:[head:[type:[conjunction_gloss:initial_ya]]]]   | to restrict splitting between subject and object
    <IP head> == [subject:[head:[type:[coordination:+]]]] ->
                ~[type:[initialP:+]]
    <IP head> == ((([subject:[head:[participle:[cat:V]]]] / [subject:[head:[possessor:[head:[participle:[cat:V]]]]]]))
                   & ([type:[no_intervening:+]])) -> 
                 (([type:[auxiliary:-
                         copular:-
                         passive:-]] 
                 / [type:[auxiliary:+
                          participle:+]])        
                 / [type:[participle_passive:+]])  | to force participle to be w/ V or Aux 12-APR-04
    <IP head> == [rootgloss:^1] ->
                 ~ ( [type:[no_intervening:+]] &    
                   (( [subject:[head:[type:[compounds_with1:^1]]]]
                    / [subject:[head:[type:[compounds_with2:^1]]]])
                    / ([subject:[head:[type:[compounds_with3:^1]]]]
                    / [subject:[head:[type:[compounds_with4:^1]]]]) ) )
    <IP head> == [rootgloss:^1] ->
                 ~ ( [type:[no_intervening:+]] & 
                  (( [subject:[head:[possessor:[head:[type:[compounds_with1:^1]]]]]]
                   / [subject:[head:[possessor:[head:[type:[compounds_with2:^1]]]]]]) 
                   / ([subject:[head:[possessor:[head:[type:[compounds_with3:^1]]]]]] 
                   / [subject:[head:[possessor:[head:[type:[compounds_with4:^1]]]]]]) ))
    <IP head> ==   [object:[head:[rootgloss:^1]]]   ->
                  ~(( [subject:[head:[type:[compounds_with1:^1]]]]
                    / [subject:[head:[type:[compounds_with2:^1]]]])
                    / ([subject:[head:[type:[compounds_with3:^1]]]]
                    / [subject:[head:[type:[compounds_with4:^1]]]]) ) 
    <IP head> ==   [object:[head:[rootgloss:^1]]] ->
                 ~ (( [subject:[head:[possessor:[head:[type:[compounds_with1:^1]]]]]]
                   / [subject:[head:[possessor:[head:[type:[compounds_with2:^1]]]]]]) 
                   / ([subject:[head:[possessor:[head:[type:[compounds_with3:^1]]]]]] 
                   / [subject:[head:[possessor:[head:[type:[compounds_with4:^1]]]]]]) )
    <IP rule> = 2cINon-ImpersonalVNonPast

rule {IP option 2cINon-ImpersonalV-PastIntransitive - subject initial, required, root clause}  
IP = DP I'
    <IP head> = <I' head>
    <IP head type root> = +
    <IP head type pro-drop> = -
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = namely    | 21Nov03  CB
    /<DP head type relcl> = +        | can have comma if relcl 27Jan03 CB
     <DP head type comma> = +
     <DP head type apposition> = -
    }
     <I' head type impersonal> = -
     <I' head infl tense past> = +
     <I' head infl tense future> = -   | Not future Apr2020
     <I' head type transitive> = -
    {<I' head subject> = <DP>
    /<DP head type human> = -
     <DP head agr person third> = +
     <DP head agr number plural> = +
     <I' head subject head agr number singular> = +
     <I' head subject head agr number plural> = -
     <I' head subject head agr person second> = -       | RL 2Feb02 allow 1st and 3rd person, but not 2nd.
    }
    <IP head subject head type> = <DP head type>  | pass DP type features for compounding, regardless of agreement 17Apr03 CB
    <IP head subject head possessor> = <DP head possessor> | pass DP possessor info for compounding, regardless of agreement 17Apr03 CB
    <DP head case_for_position> = direct  | to know normal case for conjoined DPs
    <DP head case> = direct
    <DP head type DO_contraction> = -   | 17Feb03 CB
    <DP head type case-marked> = -
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <IP head> == [type:[reciprocal:+]] -> 
                 [subject:[head:[agr:[number:[plural:+]]]]]
    <IP head> == [subject:[head:[infl:[polarity:-]]]] ->   |if the subject is negative, the verb must be negative
                 [infl:[polarity:-]]
||    <IP head> == [subject:[head:[type:[coordination:+]]]] ->
||                ~[type:[initialP:+]]
    <IP head> == ((([subject:[head:[participle:[cat:V]]]] / [subject:[head:[possessor:[head:[participle:[cat:V]]]]]]))
                   & ([type:[no_intervening:+]])) -> 
                 (([type:[auxiliary:-
                         copular:-
                         passive:-]] 
                 / [type:[auxiliary:+
                          participle:+]])        
                 / [type:[participle_passive:+]])  | to force participle to be w/ V or Aux 12-APR-04
    <IP head> == [rootgloss:^1] ->
                 ~ ( [type:[no_intervening:+]] &    
                   (( [subject:[head:[type:[compounds_with1:^1]]]]
                    / [subject:[head:[type:[compounds_with2:^1]]]])
                    / ([subject:[head:[type:[compounds_with3:^1]]]]
                    / [subject:[head:[type:[compounds_with4:^1]]]]) ) )
    <IP head> == [rootgloss:^1] ->
                 ~ ( [type:[no_intervening:+]] & 
                  (( [subject:[head:[possessor:[head:[type:[compounds_with1:^1]]]]]]
                   / [subject:[head:[possessor:[head:[type:[compounds_with2:^1]]]]]]) 
                   / ([subject:[head:[possessor:[head:[type:[compounds_with3:^1]]]]]] 
                   / [subject:[head:[possessor:[head:[type:[compounds_with4:^1]]]]]]) ))
    <IP rule> = 2cNon-ImpersonalV-PastIntransitive

rule {IP option 2cINon-ImpersonalV-PastTransitive - subject initial, required, root clause}  
IP = DP I'
    <IP head> = <I' head>
    <IP head type root> = +
    <IP head type pro-drop> = -
    <IP head subject head agr> = <DP head reflexive head agr> | pass reflexive info
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = namely    | 21Nov03  CB
    /<DP head type relcl> = +        | can have comma if relcl 27Jan03 CB
     <DP head type comma> = +
     <DP head type apposition> = -
    }
     <I' head type impersonal> = -
     <I' head infl tense past> = +
     <I' head type transitive> = +
    {<I' head subject> = <DP>
    /<DP head type human> = -
     <DP head agr person third> = +
     <DP head agr number plural> = +
     <I' head subject head agr number singular> = +
     <I' head subject head agr number plural> = -
     <I' head subject head agr person second> = -       | RL 2Feb02 allow 1st and 3rd person, but not 2nd.
    }
    <IP head subject head type> = <DP head type>  | pass DP type features for compounding, regardless of agreement 17Apr03 CB
    <IP head subject head possessor> = <DP head possessor> | pass DP possessor info for compounding, regardless of agreement 17Apr03 CB
    {<DP head case> = oblique
    <DP head case_for_position> = oblique  | to know normal case for conjoined DPs
     <DP head agr person third> = +
    /<DP head agr person first> = +        | pronouns different case CB 23May19
     <DP head case> = direct
    <DP head case_for_position> = direct  | to know normal case for conjoined DPs
    /<DP head agr person second> = +        | pronouns different case CB 23May19
     <DP head case> = direct
    <DP head case_for_position> = direct  | to know normal case for conjoined DPs
    }
    <DP head type DO_contraction> = -   | 17Feb03 CB
    <DP head type case-marked> = -
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <IP head> == [type:[reciprocal:+]] -> 
                 [subject:[head:[agr:[number:[plural:+]]]]]
    <IP head> == [object:[head:[type:[reciprocal:+]]]] ->
                 [subject:[head:[agr:[number:[plural:+]]]]]
    <IP head> == [object:[head:[infl:[polarity:-]]]] ->   |if the object is negative, the verb must be negative
                 [infl:[polarity:-]]
    <IP head> == [subject:[head:[infl:[polarity:-]]]] ->   |if the subject is negative, the verb must be negative
                 [infl:[polarity:-]]
    <IP head> == ~[object:[head:[type:[conjunction_gloss:initial_ya]]]]   | to restrict splitting between subject and object
||    <IP head> == [subject:[head:[type:[coordination:+]]]] ->
||                ~[type:[initialP:+]]
    <IP head> == ((([subject:[head:[participle:[cat:V]]]] / [subject:[head:[possessor:[head:[participle:[cat:V]]]]]]))
                   & ([type:[no_intervening:+]])) -> 
                 (([type:[auxiliary:-
                         copular:-
                         passive:-]] 
                 / [type:[auxiliary:+
                          participle:+]])        
                 / [type:[participle_passive:+]])  | to force participle to be w/ V or Aux 12-APR-04
    <IP head> == [rootgloss:^1] ->
                 ~ ( [type:[no_intervening:+]] &    
                   (( [subject:[head:[type:[compounds_with1:^1]]]]
                    / [subject:[head:[type:[compounds_with2:^1]]]])
                    / ([subject:[head:[type:[compounds_with3:^1]]]]
                    / [subject:[head:[type:[compounds_with4:^1]]]]) ) )
    <IP head> == [rootgloss:^1] ->
                 ~ ( [type:[no_intervening:+]] & 
                  (( [subject:[head:[possessor:[head:[type:[compounds_with1:^1]]]]]]
                   / [subject:[head:[possessor:[head:[type:[compounds_with2:^1]]]]]]) 
                   / ([subject:[head:[possessor:[head:[type:[compounds_with3:^1]]]]]] 
                   / [subject:[head:[possessor:[head:[type:[compounds_with4:^1]]]]]]) ))
    <IP head> ==   [object:[head:[rootgloss:^1]]]   ->
                  ~(( [subject:[head:[type:[compounds_with1:^1]]]]
                    / [subject:[head:[type:[compounds_with2:^1]]]])
                    / ([subject:[head:[type:[compounds_with3:^1]]]]
                    / [subject:[head:[type:[compounds_with4:^1]]]]) ) 
    <IP head> ==   [object:[head:[rootgloss:^1]]] ->
                 ~ (( [subject:[head:[possessor:[head:[type:[compounds_with1:^1]]]]]]
                   / [subject:[head:[possessor:[head:[type:[compounds_with2:^1]]]]]]) 
                   / ([subject:[head:[possessor:[head:[type:[compounds_with3:^1]]]]]] 
                   / [subject:[head:[possessor:[head:[type:[compounds_with4:^1]]]]]]) )
    <IP rule> = 2cNon-ImpersonalV-PastTransitive

rule {IP option 2cII - subject initial, pro-drop, root clause}
IP = I'
    <IP head> = <I' head>
    <IP head type root> = +
    <IP head type pro-drop> = +
    <IP head> == [object:[head:[infl:[polarity:-]]]] ->   |if the object is negative, the verb must be negative
                 [infl:[polarity:-]]
||    <IP head> == [object:[head:[type:[coordination:+]]]] ->
||                ~[type:[initialP:+]]
|||    <IP head> == ~([infl:[tense:[past:+]]] & [type:[transitive:+]]) | past transitive must have overt subject CB 30May19  Ron says true only for Balochi, not Farsi 3Feb2020
    <IP rule> = 2cII

|*****split rule for impersonalV and then non-past and past transitive*****
rule {IP option 2cImpersonalVnonroot - subject initial, required, nonroot clause}
IP = (InitP) DP I'
    <IP head> = <I' head>
    <IP head type root> = -
    <InitP head type root> = -
    <IP head type pro-drop> = -
    <IP head subject head agr> = <DP head reflexive head agr> | pass reflexive info
    <I' head subject> = <InitP head subject> | pass reflexive info
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = namely    | 21Nov03  CB
    }
    <I' head subject> = <DP>
    <I' head type impersonal> = +       | impersonal verbs do not agree **24Jul06 CB
    <IP head subject head type> = <DP head type>  | pass DP type features for compounding, regardless of agreement 17Apr03 CB
    <IP head subject head possessor> = <DP head possessor> | pass DP possessor info for compounding, regardless of aggrement 17Apr03 CB
    {<DP head case> = oblique
    <DP head case_for_position> = oblique  | to know normal case for conjoined DPs
     <DP head agr person third> = +
    /<DP head agr person first> = +        | pronouns different case CB 23May19
     <DP head case> = objective
    <DP head case_for_position> = objective  | to know normal case for conjoined DPs
    /<DP head agr person second> = +        | pronouns different case CB 23May19
     <DP head case> = objective
    <DP head case_for_position> = objective  | to know normal case for conjoined DPs
    }
    <DP head type DO_contraction> = -   | 17Feb03 CB
    <DP head type case-marked> = -
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <IP head type initialP> <= <InitP head type initialP> 
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <IP head> == [type:[reciprocal:+]] -> 
                 [subject:[head:[agr:[number:[plural:+]]]]]
    <IP head> == [object:[head:[type:[reciprocal:+]]]] ->
                 [subject:[head:[agr:[number:[plural:+]]]]]
    <IP head> == [object:[head:[infl:[polarity:-]]]] ->   |if the object is negative, the verb must be negative
                 [infl:[polarity:-]]
    <IP head> == [subject:[head:[infl:[polarity:-]]]] ->   |if the subject is negative, the verb must be negative
                 [infl:[polarity:-]]
    <IP head> == ~[object:[head:[type:[conjunction_gloss:initial_ya]]]]   | to restrict splitting between subject and object
||    <IP head> == [subject:[head:[type:[coordination:+]]]] ->
||                ~[type:[initialP:+]]
    <IP head> == (([subject:[head:[participle:[cat:V]]]] / [subject:[head:[possessor:[head:[participle:[cat:V]]]]]])
                   & [type:[no_intervening:+]]) -> 
                 (([type:[auxiliary:-
                         copular:-
                         passive:-]] 
                 / [type:[auxiliary:+
                          participle:+]])        
                 / [type:[participle_passive:+]])  | to force participle to be w/ V or Aux 12-APR-04
    <IP head> == [rootgloss:^1] ->
                 ~ ( [type:[no_intervening:+]] &    
                   (( [subject:[head:[type:[compounds_with1:^1]]]]
                    / [subject:[head:[type:[compounds_with2:^1]]]])
                    / ([subject:[head:[type:[compounds_with3:^1]]]]
                    / [subject:[head:[type:[compounds_with4:^1]]]]) ) )
    <IP head> == [rootgloss:^1] ->
                 ~ ( [type:[no_intervening:+]] & 
                  (( [subject:[head:[possessor:[head:[type:[compounds_with1:^1]]]]]]
                   / [subject:[head:[possessor:[head:[type:[compounds_with2:^1]]]]]]) 
                   / ([subject:[head:[possessor:[head:[type:[compounds_with3:^1]]]]]] 
                   / [subject:[head:[possessor:[head:[type:[compounds_with4:^1]]]]]]) ))
    <IP head> ==   [object:[head:[rootgloss:^1]]]   ->
                  ~(( [subject:[head:[type:[compounds_with1:^1]]]]
                    / [subject:[head:[type:[compounds_with2:^1]]]])
                    / ([subject:[head:[type:[compounds_with3:^1]]]]
                    / [subject:[head:[type:[compounds_with4:^1]]]]) ) 
    <IP head> ==   [object:[head:[rootgloss:^1]]] ->
                 ~ (( [subject:[head:[possessor:[head:[type:[compounds_with1:^1]]]]]]
                   / [subject:[head:[possessor:[head:[type:[compounds_with2:^1]]]]]]) 
                   / ([subject:[head:[possessor:[head:[type:[compounds_with3:^1]]]]]] 
                   / [subject:[head:[possessor:[head:[type:[compounds_with4:^1]]]]]]) )
    <IP rule> = 2cImpersonalVnonroot
    
rule {IP option 2cNon-ImpersonalVNonPastnonroot - subject initial, required, nonroot clause}
IP = (InitP) DP I'
    <IP head> = <I' head>
    <IP head type root> = -
    <InitP head type root> = -
    <IP head type pro-drop> = -
    <IP head subject head agr> = <DP head reflexive head agr> | pass reflexive info
    <I' head subject> = <InitP head subject> | pass reflexive info
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = namely    | 21Nov03  CB
    }
     <I' head type impersonal> = -
     <I' head infl tense past> = -
    {<I' head subject> = <DP>
    /<DP head type human> = -
     <DP head agr person third> = +
     <DP head agr number plural> = +
     <I' head subject head agr number singular> = +
     <I' head subject head agr number plural> = -
     <I' head subject head agr person second> = -       | RL 2Feb02 allow 1st and 3rd person, but not 2nd.
    }
    <IP head subject head type> = <DP head type>  | pass DP type features for compounding, regardless of agreement 17Apr03 CB
    <IP head subject head possessor> = <DP head possessor> | pass DP possessor info for compounding, regardless of aggrement 17Apr03 CB
    <DP head case_for_position> = direct  | to know normal case for conjoined DPs
    <DP head case> = direct
    <DP head type DO_contraction> = -   | 17Feb03 CB
    <DP head type case-marked> = -
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <IP head type initialP> <= <InitP head type initialP> 
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <IP head> == [type:[reciprocal:+]] -> 
                 [subject:[head:[agr:[number:[plural:+]]]]]
    <IP head> == [object:[head:[type:[reciprocal:+]]]] ->
                 [subject:[head:[agr:[number:[plural:+]]]]]
    <IP head> == [object:[head:[infl:[polarity:-]]]] ->   |if the object is negative, the verb must be negative
                 [infl:[polarity:-]]
    <IP head> == [subject:[head:[infl:[polarity:-]]]] ->   |if the subject is negative, the verb must be negative
                 [infl:[polarity:-]]
    <IP head> == ~[object:[head:[type:[conjunction_gloss:initial_ya]]]]   | to restrict splitting between subject and object
||    <IP head> == [subject:[head:[type:[coordination:+]]]] ->
||                ~[type:[initialP:+]]
    <IP head> == (([subject:[head:[participle:[cat:V]]]] / [subject:[head:[possessor:[head:[participle:[cat:V]]]]]])
                   & [type:[no_intervening:+]]) -> 
                 (([type:[auxiliary:-
                         copular:-
                         passive:-]] 
                 / [type:[auxiliary:+
                          participle:+]])        
                 / [type:[participle_passive:+]])  | to force participle to be w/ V or Aux 12-APR-04
    <IP head> == [rootgloss:^1] ->
                 ~ ( [type:[no_intervening:+]] &    
                   (( [subject:[head:[type:[compounds_with1:^1]]]]
                    / [subject:[head:[type:[compounds_with2:^1]]]])
                    / ([subject:[head:[type:[compounds_with3:^1]]]]
                    / [subject:[head:[type:[compounds_with4:^1]]]]) ) )
    <IP head> == [rootgloss:^1] ->
                 ~ ( [type:[no_intervening:+]] & 
                  (( [subject:[head:[possessor:[head:[type:[compounds_with1:^1]]]]]]
                   / [subject:[head:[possessor:[head:[type:[compounds_with2:^1]]]]]]) 
                   / ([subject:[head:[possessor:[head:[type:[compounds_with3:^1]]]]]] 
                   / [subject:[head:[possessor:[head:[type:[compounds_with4:^1]]]]]]) ))
    <IP head> ==   [object:[head:[rootgloss:^1]]]   ->
                  ~(( [subject:[head:[type:[compounds_with1:^1]]]]
                    / [subject:[head:[type:[compounds_with2:^1]]]])
                    / ([subject:[head:[type:[compounds_with3:^1]]]]
                    / [subject:[head:[type:[compounds_with4:^1]]]]) ) 
    <IP head> ==   [object:[head:[rootgloss:^1]]] ->
                 ~ (( [subject:[head:[possessor:[head:[type:[compounds_with1:^1]]]]]]
                   / [subject:[head:[possessor:[head:[type:[compounds_with2:^1]]]]]]) 
                   / ([subject:[head:[possessor:[head:[type:[compounds_with3:^1]]]]]] 
                   / [subject:[head:[possessor:[head:[type:[compounds_with4:^1]]]]]]) )
    <IP rule> = 2cNon-ImpersonalVNonPastnonroot

rule {IP option 2cNon-ImpersonalV-PastIntransitivenonroot - subject initial, required, nonroot clause}
IP = (InitP) DP I'
    <IP head> = <I' head>
    <IP head type root> = -
    <InitP head type root> = -
    <IP head type pro-drop> = -
    <I' head subject> = <InitP head subject> | pass reflexive info
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = namely    | 21Nov03  CB
    }
     <I' head type impersonal> = -
     <I' head infl tense past> = +
    <I' head type transitive> = -
    {<I' head subject> = <DP>
    /<DP head type human> = -
     <DP head agr person third> = +
     <DP head agr number plural> = +
     <I' head subject head agr number singular> = +
     <I' head subject head agr number plural> = -
     <I' head subject head agr person second> = -       | RL 2Feb02 allow 1st and 3rd person, but not 2nd.
    }
    <IP head subject head type> = <DP head type>  | pass DP type features for compounding, regardless of agreement 17Apr03 CB
    <IP head subject head possessor> = <DP head possessor> | pass DP possessor info for compounding, regardless of aggrement 17Apr03 CB
    <DP head case> = direct
    <DP head case_for_position> = direct  | to know normal case for conjoined DPs
    <DP head type DO_contraction> = -   | 17Feb03 CB
    <DP head type case-marked> = -
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <IP head type initialP> <= <InitP head type initialP> 
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <IP head> == [type:[reciprocal:+]] -> 
                 [subject:[head:[agr:[number:[plural:+]]]]]
    <IP head> == [subject:[head:[infl:[polarity:-]]]] ->   |if the subject is negative, the verb must be negative
                 [infl:[polarity:-]]
||    <IP head> == [subject:[head:[type:[coordination:+]]]] ->
||                ~[type:[initialP:+]]
    <IP head> == (([subject:[head:[participle:[cat:V]]]] / [subject:[head:[possessor:[head:[participle:[cat:V]]]]]])
                   & [type:[no_intervening:+]]) -> 
                 (([type:[auxiliary:-
                         copular:-
                         passive:-]] 
                 / [type:[auxiliary:+
                          participle:+]])        
                 / [type:[participle_passive:+]])  | to force participle to be w/ V or Aux 12-APR-04
    <IP head> == [rootgloss:^1] ->
                 ~ ( [type:[no_intervening:+]] &    
                   (( [subject:[head:[type:[compounds_with1:^1]]]]
                    / [subject:[head:[type:[compounds_with2:^1]]]])
                    / ([subject:[head:[type:[compounds_with3:^1]]]]
                    / [subject:[head:[type:[compounds_with4:^1]]]]) ) )
    <IP head> == [rootgloss:^1] ->
                 ~ ( [type:[no_intervening:+]] & 
                  (( [subject:[head:[possessor:[head:[type:[compounds_with1:^1]]]]]]
                   / [subject:[head:[possessor:[head:[type:[compounds_with2:^1]]]]]]) 
                   / ([subject:[head:[possessor:[head:[type:[compounds_with3:^1]]]]]] 
                   / [subject:[head:[possessor:[head:[type:[compounds_with4:^1]]]]]]) ))
    <IP rule> = 2cNon-ImpersonalV-PastIntransitivenonroot

rule {IP option 2cNon-ImpersonalV-PastTransitivenonroot - subject initial, required, nonroot clause}
IP = (InitP) DP I'
    <IP head> = <I' head>
    <IP head type root> = -
    <InitP head type root> = -
    <IP head type pro-drop> = -
    <IP head subject head agr> = <DP head reflexive head agr> | pass reflexive info
    <I' head subject> = <InitP head subject> | pass reflexive info
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = namely    | 21Nov03  CB
    }
     <I' head type impersonal> = -
     <I' head infl tense past> = +
    <I' head type transitive> = +
    {<I' head subject> = <DP>
    /<DP head type human> = -
     <DP head agr person third> = +
     <DP head agr number plural> = +
     <I' head subject head agr number singular> = +
     <I' head subject head agr number plural> = -
     <I' head subject head agr person second> = -       | RL 2Feb02 allow 1st and 3rd person, but not 2nd.
    }
    <IP head subject head type> = <DP head type>  | pass DP type features for compounding, regardless of agreement 17Apr03 CB
    <IP head subject head possessor> = <DP head possessor> | pass DP possessor info for compounding, regardless of aggrement 17Apr03 CB
    {<DP head case> = oblique
    <DP head case_for_position> = oblique  | to know normal case for conjoined DPs
     <DP head agr person third> = +
    /<DP head agr person first> = +        | pronouns different case CB 23May19
     <DP head case> = direct
    <DP head case_for_position> = direct  | to know normal case for conjoined DPs
    /<DP head agr person second> = +        | pronouns different case CB 23May19
     <DP head case> = direct
    <DP head case_for_position> = direct  | to know normal case for conjoined DPs
    }
    <DP head type DO_contraction> = -   | 17Feb03 CB
    <DP head type case-marked> = -
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <IP head type initialP> <= <InitP head type initialP> 
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <IP head> == [type:[reciprocal:+]] -> 
                 [subject:[head:[agr:[number:[plural:+]]]]]
    <IP head> == [object:[head:[type:[reciprocal:+]]]] ->
                 [subject:[head:[agr:[number:[plural:+]]]]]
    <IP head> == [object:[head:[infl:[polarity:-]]]] ->   |if the object is negative, the verb must be negative
                 [infl:[polarity:-]]
    <IP head> == [subject:[head:[infl:[polarity:-]]]] ->   |if the subject is negative, the verb must be negative
                 [infl:[polarity:-]]
    <IP head> == ~[object:[head:[type:[conjunction_gloss:initial_ya]]]]   | to restrict splitting between subject and object
||    <IP head> == [subject:[head:[type:[coordination:+]]]] ->
||                ~[type:[initialP:+]]
    <IP head> == (([subject:[head:[participle:[cat:V]]]] / [subject:[head:[possessor:[head:[participle:[cat:V]]]]]])
                   & [type:[no_intervening:+]]) -> 
                 (([type:[auxiliary:-
                         copular:-
                         passive:-]] 
                 / [type:[auxiliary:+
                          participle:+]])        
                 / [type:[participle_passive:+]])  | to force participle to be w/ V or Aux 12-APR-04
    <IP head> == [rootgloss:^1] ->
                 ~ ( [type:[no_intervening:+]] &    
                   (( [subject:[head:[type:[compounds_with1:^1]]]]
                    / [subject:[head:[type:[compounds_with2:^1]]]])
                    / ([subject:[head:[type:[compounds_with3:^1]]]]
                    / [subject:[head:[type:[compounds_with4:^1]]]]) ) )
    <IP head> == [rootgloss:^1] ->
                 ~ ( [type:[no_intervening:+]] & 
                  (( [subject:[head:[possessor:[head:[type:[compounds_with1:^1]]]]]]
                   / [subject:[head:[possessor:[head:[type:[compounds_with2:^1]]]]]]) 
                   / ([subject:[head:[possessor:[head:[type:[compounds_with3:^1]]]]]] 
                   / [subject:[head:[possessor:[head:[type:[compounds_with4:^1]]]]]]) ))
    <IP head> ==   [object:[head:[rootgloss:^1]]]   ->
                  ~(( [subject:[head:[type:[compounds_with1:^1]]]]
                    / [subject:[head:[type:[compounds_with2:^1]]]])
                    / ([subject:[head:[type:[compounds_with3:^1]]]]
                    / [subject:[head:[type:[compounds_with4:^1]]]]) ) 
    <IP head> ==   [object:[head:[rootgloss:^1]]] ->
                 ~ (( [subject:[head:[possessor:[head:[type:[compounds_with1:^1]]]]]]
                   / [subject:[head:[possessor:[head:[type:[compounds_with2:^1]]]]]]) 
                   / ([subject:[head:[possessor:[head:[type:[compounds_with3:^1]]]]]] 
                   / [subject:[head:[possessor:[head:[type:[compounds_with4:^1]]]]]]) )
    <IP rule> = 2cNon-ImpersonalVPastTransitivenonroot


rule {IP option 2cIInonroot - subject initial, pro-drop, nonroot clauses}
IP = (InitP) I'
    <IP head> = <I' head>
    <IP head type root> = -
    <I' head subject> = <InitP head subject> | pass reflexive info
    <InitP head type root> = -
    <IP head type pro-drop> = +
    <IP head type initialP> <= <InitP head type initialP> 
    <IP head> == [object:[head:[infl:[polarity:-]]]] ->   |if the object is negative, the verb must be negative
                 [infl:[polarity:-]]
||    <IP head> == [object:[head:[type:[coordination:+]]]] ->
||                ~[type:[initialP:+]]
    <IP rule> = 2cIInonroot

|-***********************************************************
rule {I' option 0 - conjoined I's}
I' = I'_1 Conj I'_2
    <I' head> = <I'_1 head>
    <I' conjoined> = +                | limit recursion
    <I'_1 conjoined> = -
    <I'_1 head subject> = <I'_2 head subject>
    <I'_1 head infl mood realis> = <I'_2 head infl mood realis> | 15Jul03 CB
    {
    <I'_1 head type auxiliary> = +      | one of the two verbs has an auxiliary or both do.
    <I'_2 head type auxiliary> = - /
    <I'_1 head type auxiliary> = -
    <I'_2 head type auxiliary> = + /
    <I'_1 head type auxiliary> = +
    <I'_2 head type auxiliary> = +
    }
    <Conj head type conjoins_IP> = +
    <I' rule> = 0

|not for Sdn  
rule {I' option 1 - no auxiliaries}
I' = (AdvP / DP / PP) VP 
    <I' head> = <VP head>
    <I' head type auxiliary> = -
    {<I' head type participle> = -     | the participle is only allowed when followed by an Aux 03Apr03 C
    /<I' head type participle> = +     | OR when the verb is passive
     <I' head type passive> = +
    /<I' head type participle> = +     | OR when the verb has past endings
     <I' head infl tense past> = +     | 17Jul03 CB
     <I' head type passive> = -
    /<I' head type participle> = +     | OR when the verb is present perfective
     <I' head infl tense present> = +    
     <I' head type passive> = -
     <I' head infl aspect perfective> = +     | Apr2020 CB
    } 
    <I' head embedded infl> = <I' head infl>     | enforce any subcategorization requirements from higher verb
    <VP head adjoined> = <PP>
    <VP head adjoined> = <DP>
    <VP head adjoined> = <AdvP>
|    <AdvP head type temporal> = +
    <DP head type temporal> = +
    <DP head case> = direct
    <DP head type no_head_N> = -
    <DP head type comma> = - 
    <PP head type sentential> = -        | added 31Mar03 CB
    <PP head type stranded> = -           | not missing a complement  22Aug2019
    <PP head> == ~[rootgloss: to]         | P not 'to' for IO - testing ***Jun2019
    <VP head> == [adjoined:[head:[type:[locative:+]]]] -> ~[type:[motion:+]] |not motion VP with locative PP/AdvP/DP testing 29Jan2020
    <VP head> == ~[rootgloss:become]
    <VP head> == ~[rootgloss_V_2: become]            | 12-APR-04
    <I' rule> = 1

rule {I' option 1Sdn - no auxiliaries}
I' = (AdvP / DP / PP) VP
    <I' head> = <VP head>
    <I' head type auxiliary> = -
    {<VP head rootgloss> = become
    /<VP head rootgloss_V_2> = become               | 12-APR-04
    }
    {<I' head type participle> = -     | the participle is only allowed when followed by an Aux 03Apr03 CB
    / <VP head type compound> = +       | OR when Sdn is compound 17Apr03 CB
     <I' head type participle> = +
    } 
|    <AdvP head type temporal> = +
    <DP head type temporal> = +
    <DP head case> = direct
    <DP head type no_head_N> = -
    <DP head type comma> = - 
    <PP head type sentential> = -        | added 31Mar03 CB
    <PP head type stranded> = -           | not missing a complement  22Aug2019
    <PP head> == ~[rootgloss: to]         | P not 'to' for IO - testing ***Jun2019
    <I' head embedded infl> = <I' head infl>     | enforce any subcategorization requirements from higher verb
    <I' rule> = 1Sdn

rule {I' option 3 - Aux final, required}
I' = VP (AdvP / DP / PP) Aux
    <I' head> = <VP head>
    <I' head type auxiliary> = +
    <I' head subject head agr> = <Aux head subject head agr>
    <VP head adjoined> = <PP>
    <VP head adjoined> = <DP>
    <VP head adjoined> = <AdvP>
    <VP head type comma> = -
|    <AdvP head type temporal> = +
    <DP head type temporal> = +
    <DP head case> = direct
    <DP head type no_head_N> = -
    <DP head type comma> = - 
    <PP head type sentential> = -        | added 31Mar03 CB
    <PP head type stranded> = -           | not missing a complement  22Aug2019
    <VP head type participle> = +          | all auxiliaries require the verb to be in participle form (not future--different rule V F)
   <Aux head type object_agr_suffix> = -   |CB 4Feb2020   no object agr
   <Aux head type copular_suffix> = -      |CB 4Feb2020   not copular form
   <Aux head infl aspect perfective> = -   |CB 4Feb2020   perfective uses V V rule
    |<I' head infl> = <Aux head infl>  | RL 13Feb02
    <PP head> == ~[rootgloss: to]         | P not 'to' for IO - testing ***Jun2019
    <VP head> == [adjoined:[head:[type:[locative:+]]]] -> ~[type:[motion:+]] |not motion VP with locative PP/AdvP/DP testing 29Jan2020
    <I' head embedded infl> = <I' head infl>     | enforce any subcategorization requirements from higher verb
    <I' rule> = 3

rule {I' option 4pst - Aux initial, required - for be.able.pst, requires embedded subjunctive}
I' = (AdvP_1) Aux (AdvP / DP / PP) VP
    <I' head> = <VP head>
    <VP head adjoined> = <PP>
    <VP head adjoined> = <DP>
    <VP head adjoined> = <AdvP>
    <I' head type auxiliary> = +
    <Aux rootgloss> = be.able
    <Aux head infl tense past> = +          | Aux is past tense for this rule
    <VP head auxiliaryH infl tense past> = <Aux head infl tense past>
    <VP head auxiliaryH rootgloss> = <Aux rootgloss>
    <I' head subject head agr> = <Aux head subject head agr>
    <VP head type comma> = -
|    <AdvP head type temporal> = +
    <DP head type temporal> = +
    <DP head case> = direct
    <DP head type no_head_N> = -
    <DP head type comma> = - 
    <PP head type sentential> = -        | added 31Mar03 CB
    <PP head type stranded> = -           | not missing a complement  22Aug2019
    <PP head> == ~[rootgloss: to]         | P not 'to' for IO - testing ***Jun2019
    <VP head> == [adjoined:[head:[type:[locative:+]]]] -> ~[type:[motion:+]] |not motion VP with locative PP testing 29Jan2020
    <VP head infl mood subjunctive> = +       | embedded verb is present subjunctive
    <VP head infl mood realis> = -            | embedded verb is present subjunctive
    <VP head infl tense present> = +          | embedded verb is present subjunctive
   <Aux head type object_agr_suffix> = -   |CB 4Feb2020   no object agr
   <Aux head type copular_suffix> = -      |CB 4Feb2020   not copular form
   <Aux head infl aspect perfective> = -   |CB 4Feb2020   perfective uses V V rule
    <I' head infl tense past> <= +         | tense is from Aux
    |<I' head infl> = <Aux head infl>  | RL 13Feb02
    <I' head infl polarity> <= <Aux head infl polarity>  | negation on Aux  Feb2020 CB
||    <I' head embedded infl> = <I' head infl>     | enforce any subcategorization requirements from higher verb
    <I' rule> = 4pst

rule {I' option 4prs - Aux initial, required - for be.able.prs, requires embedded subjunctive}
I' = (AdvP_1) Aux (AdvP / DP / PP) VP
    <I' head> = <VP head>
    <VP head adjoined> = <PP>
    <VP head adjoined> = <DP>
    <VP head adjoined> = <AdvP>
    <I' head type auxiliary> = +
    <Aux rootgloss> = be.able
    <Aux head infl tense present> = +          | Aux is present tense for this rule
    <VP head auxiliaryH infl tense present> = <Aux head infl tense past>
    <VP head auxiliaryH rootgloss> = <Aux rootgloss>
    <I' head subject head agr> = <Aux head subject head agr>
    <VP head type comma> = -
|    <AdvP head type temporal> = +
    <DP head type temporal> = +
    <DP head case> = direct
    <DP head type no_head_N> = -
    <DP head type comma> = - 
    <VP head subject> = <PP head reflexive> | pass reflexive info
    <VP head adjoined> = <PP>
    <PP head type sentential> = -        | added 31Mar03 CB
    <PP head type stranded> = -           | not missing a complement  22Aug2019
    <PP head> == ~[rootgloss: to]         | P not 'to' for IO - testing ***Jun2019
    <VP head> == [adjoined:[head:[type:[locative:+]]]] -> ~[type:[motion:+]] |not motion VP with locative PP testing 29Jan2020
    <VP head infl mood subjunctive> = +       | embedded verb is present subjunctive
    <VP head infl mood realis> = -            | embedded verb is present subjunctive
    <VP head infl tense present> = +          | embedded verb is present subjunctive
    <Aux head type object_agr_suffix> = -   |CB 4Feb2020   no object agr
    <VP head type object_agr_suffix> = -   |CB Apr2020   no object agr on V
    <Aux head type copular_suffix> = -      |CB 4Feb2020   not copular form
    <Aux head infl aspect perfective> = -   |CB 4Feb2020   perfective uses V V rule
    |<I' head infl> = <Aux head infl>  | RL 13Feb02
    <I' head infl polarity> <= <Aux head infl polarity>  | negation on Aux  Feb2020 CB
||    <I' head embedded infl> = <I' head infl>     | enforce any subcategorization requirements from higher verb
    <I' rule> = 4prs

|-***********************************************************
rule {VP option 0adj - adjoined CP}
VP = VP_1 CP
    <VP head> = <VP_1 head>
    <CP head type root> = -
    <CP head type relcl> = -          | 21Nov03 CB
    <VP_1 head type sentential> = -
    <VP head type comma> <= <CP head type comma>  | 04Apr03 CB
    <VP rule> = 0adj

rule {VP option 0conj - conjoined VPs}
VP = VP_1 Conj VP_2
    <VP head rootgloss> = <VP_1 head rootgloss>     | for compounding constraints 12-APR-04
    <VP head rootgloss_V_2> <= <VP_2 head rootgloss> | for Sdn Aux constraints
    <VP head subject> = <VP_1 head subject> | CB 16Jan03
    <VP_1 head subject> = <VP_2 head subject>  | subjects agree
    <VP head type participle> = <VP_1 head type participle> | CB 16Jan03
    <VP_1 head type participle> = <VP_2 head type participle>
    <VP head type relcl> = <VP_1 head type relcl> | CB 10Dec03
    <VP_1 head type relcl> = <VP_2 head type relcl>
    <VP head infl> = <VP_1 head infl> | CB 16Jan03
    <VP head type no_intervening> = -   | for compounding constraint 15Apr03 CB
    <VP conjoined> = +                | limit recursion
    <VP_1 conjoined> = -
    <Conj head type conjoins_IP> = +
|    <VP_2 head infl mood realis> = +  | for subjunctive, use embedded rule  | removed  27Jan03
    <VP_2 head infl mood realis> = <VP_1 head infl mood realis>     | added instead 27Jan03 CB
    <VP_1 head type conj_suffix> = -                | 09-APR-04 
    <VP head type conj_suffix> = <VP_2 head type conj_suffix> | pass to IP 0b
    <VP head type comma> <= <VP_2 head type comma>  | 04Apr03 CB
    <VP rule> = 0conj

|rule {VP option 1Adv - adjoined AdvP}
|VP = AdvP VP_1
|    <VP head> = <VP_1 head>
|    <VP_1 head type auxiliary> <= <VP head type auxiliary>  | trying to make something work
|    <VP_1 head auxiliaryH rootgloss> <= <VP head auxiliaryH rootgloss> | passing down Aux info 
|    <VP_1 head auxiliaryH rootgloss> = <VP head auxiliaryH rootgloss> | passing down Aux info
|    <VP_1 head auxiliaryH> <= <VP head auxiliaryH> | passing down Aux info
|    <VP_1 head auxiliaryH> = <VP head auxiliaryH> | passing down Aux info
|    <AdvP head type comma> = -
||    <AdvP head type manner> = +         | removed this restriction and eliminated AdvP w/in |VP 20Feb03 CB
|    {<AdvP head infl polarity> = +	 | either the adverb is not negative - 07-APR-04
|    /<AdvP head infl polarity> = -	 | or the adverb is negative
|     <VP_1 head infl polarity> = -	 | and the verb must be negative
|    /<AdvP head infl polarity> = -	 | or the adverb is negative
|     <VP_1 head infl polarity> = +	 | and the verb is subjuctive
|     <VP_1 head infl mood realis> = -
|    }
|    <VP head type no_intervening> <= -   | for compounding constraint
|    <VP rule> = 1Adv

||added for Ability24 "every day"
|rule {VP option 1TempDP - adjoined DP, temporal only}
|VP = DP VP_1
|    <VP head> = <VP_1 head>
|    <VP_1 head type auxiliary> <= <VP head type auxiliary>  | trying to make something work
|    <VP_1 head auxiliaryH rootgloss> <= <VP head auxiliaryH rootgloss> | passing down Aux info 
|    <VP_1 head auxiliaryH rootgloss> = <VP head auxiliaryH rootgloss> | passing down Aux info
|    <VP_1 head auxiliaryH> <= <VP head auxiliaryH> | passing down Aux info
|    <VP_1 head auxiliaryH> = <VP head auxiliaryH> | passing down Aux info
|    <DP head type temporal> = +
|    <DP head case> = direct
|    <DP head type no_head_N> = -
|    <DP head type comma> = -
|    <VP head type no_intervening> <= -   | for compounding constraint
|    <VP rule> = 1TempDP

||VP_1 already compound or intervening material 
|rule {VP option 1PPno - adjoined PP, no need for compound test}
|VP = PP VP_1
|    <VP head> = <VP_1 head>
|    <VP head subject> = <PP head reflexive> | pass reflexive info
|    <VP head adjoined> = <PP>
|    {<PP head type comma> = -
|    /<PP head type comma> = +		 | PP may have comma if object contains apposition |07-APR-04
|     <PP head object head type apposition> = +
|    }
|    <PP head type sentential> = -        | added 31Mar03 CB
|    <PP head type stranded> = -           | not missing a complement  22Aug2019
|    {<VP_1 head type no_intervening> = -  | for compounding constraint
|    /<VP_1 head type no_intervening> = +
|     <VP_1 head type compounded> = +      | or already compounded
|    }
|    <PP head> == ~[rootgloss: to]         | P not 'to' for IO - testing ***Jun2019
|    <VP head> == [adjoined:[head:[type:[locative:+]]]] -> ~[type:[motion:+]] |not motion VP |with locative PP testing 29Jan2020
|    <VP rule> = 1PPno

|rule {VP option 1PP - adjoined PP, possible compound situation}
|VP = PP VP_1
|    <VP head> = <VP_1 head>
|    <VP head subject> = <PP head reflexive> | pass reflexive info
|    <VP head adjoined> = <PP>
|    {<PP head type comma> = -
|    /<PP head type comma> = +		 | PP may have comma if object contains apposition |07-APR-04
|     <PP head object head type apposition> = +
|    }
|    <PP head type sentential> = -        | added 31Mar03 CB
|    <VP_1 head type no_intervening> = +
|    <VP_1 head type compounded> = -      | not already compounded
|    <VP head type no_intervening> <= -   | for compounding constraint
|    <PP head object head type> == [modifier-final:+] -> ~[compound:+]  | PPs with modified |objects whose final element is marked compound, must compound 16Jul03 CB
|    <PP head> == ~[rootgloss: to]         | P not 'to' for IO - testing ***Jun2019
|    <VP head> == [adjoined:[head:[type:[locative:+]]]] -> ~[type:[motion:+]] |not motion VP |with locative PP testing 29Jan2020
|    <VP rule> = 1PP

rule {VP option 2a - V initial/final, intransitive or copular}
VP = V
    <VP head> = <V head>
    <VP head rootgloss> = <V rootgloss>
    {<V head type transitive> = -
    /<V head type transitive> = +  | or transitive within a relative clause
     <VP head type relcl> = +    | 20Nov03 CB
    }
    <V head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <V head type passive> = -
    <VP head type no_intervening> = +   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <VP rule> = 2a


rule {VP option 3b - V final, motion intransitive with locative}
VP = DP V 
    <VP head> = <V head>
    <VP head rootgloss> = <V rootgloss>
    <V head subject> = <DP head reflexive>  | pass reflexive info
    <DP head case> = oblique          | changed from direct per Ron 8Jan2020 CB
    <DP head type locative> = +
    <DP head type coordination> = - | don't allow coordinate DPs 12Feb03 CB
    <DP head type nonfinalcoordination> = -
    <V head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <V head type transitive> = -
||    <V head type copular> = -   |testing 28Jan2020 for be + participle 
    <V head type motion> = +
    <V head type passive> = -
    <VP head type no_intervening> = -   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <VP rule> = 3b

|added 30May19
rule {VP option 3bPP - V final, motion intransitive with locative PP or AdvP}
VP = {PP / AdvP} V 
    <VP head> = <V head>
    <VP head rootgloss> = <V rootgloss>
    <PP head type locative> = +
    <PP head type location_PP> = +    | to rule out PP IO  22Aug2019
    <AdvP head type locative> = +
    <V head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <V head type transitive> = -
||    <V head type copular> = -   |testing 28Jan2020 for be + participle 
    <V head type motion> = +
    <V head type passive> = -
    <VP head type no_intervening> = -   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <VP rule> = 3bPP

|added Feb2020 for Ability 5-6 CB  split for past, then generic and definite
rule {VP option 3cTRpast - motion transitive}
VP = DP_1 {PP / AdvP / DP_2} V
     <VP head> = <V head>
     <VP head object> = <DP_1>
     <VP head location> = <PP>
     <VP head location> = <AdvP>
     <VP head location> = <DP_2>
     <VP head type pro-drop> = -    | DP_1 should not be the subject Apr2020
    {<V head infl tense past> = +
    /<V head infl tense past> = -
     <VP head auxiliaryH rootgloss> = be.able    |tense from Aux  Feb2020
     <VP head auxiliaryH infl tense past> = +    |tense from Aux  Feb2020
     <VP head auxiliaryH infl tense present> = -    |tense from Aux  Feb2020
     <VP head type auxiliary> = +             | Aux must be present Apr2020
     <VP head infl mood subjunctive> = +        | Apr2020
    }
     <DP_1 head type temporal> = -       |Apr2020
    {<DP_1 head case> = direct         
     <DP_1 head type pronoun> = -
     <DP_1 head case_for_position> = direct  | to know normal case for conjoined DPs
    /<DP_1 head case> = direct
     <DP_1 head type pronoun> = +
     <DP_1 head agr person third> = +  
     <DP_1 head agr person first> = -  
     <DP_1 head agr person second> = -  
     <DP_1 head case_for_position> = direct  | to know normal case for conjoined DPs
    /<DP_1 head case> = objective
     <DP_1 head type pronoun> = +        | pronouns different case CB 23May19
     <DP_1 head agr person first> = +
     <DP_1 head agr person third> = -  
     <DP_1 head agr person second> = -  
     <DP_1 head case_for_position> = objective  | to know normal case for conjoined DPs
    /<DP_1 head case> = objective
     <DP_1 head type pronoun> = +        | pronouns different case CB 23May19
     <DP_1 head agr person second> = +  
     <DP_1 head agr person third> = -  
     <DP_1 head agr person first> = -  
     <DP_1 head case_for_position> = objective  | to know normal case for conjoined DPs
    }
     <PP head type locative> = +
     <PP head type location_PP> = +    | to rule out PP IO  22Aug2019
     <PP head type sentential> = -
     <DP_2 head type locative> = +
     <DP_2 head case> = oblique
     <AdvP head type locative> = +
     <V head type copular> = -
     <V head type passive> = -
     <V head type motion> = +
    {<V head type transitive_motion> = +  | activated Apr2020, V must have transitive_motion
    /<V head infl valence causative> = +  | or motion verb + causative
    }
     <V head type object_agr_suffix> = +   |CB 24May19   must have object agreement
     <VP rule> = 3cTRpast

rule {VP option 3cTRNonPastGeneric - motion transitive}
VP = DP_1 {PP / AdvP / DP_2} V
     <VP head> = <V head>
     <VP head object> = <DP_1>
     <VP head location> = <PP>
     <VP head location> = <AdvP>
     <VP head location> = <DP_2>
     <VP head type pro-drop> = -    | DP_1 should not be the subject Apr2020
     <V head infl tense past> = -
     <DP_1 head type generic> = +      | 30May19
     <DP_1 head type temporal> = -       |Apr2020
    {<DP_1 head case> = direct         
     <DP_1 head type pronoun> = -
     <DP_1 head case_for_position> = direct  | to know normal case for conjoined DPs
    /<DP_1 head case> = oblique
     <DP_1 head type pronoun> = +
     <DP_1 head agr person third> = +  
     <DP_1 head agr person first> = -  
     <DP_1 head agr person second> = -  
     <DP_1 head case_for_position> = oblique  | to know normal case for conjoined DPs
    /<DP_1 head case> = objective
     <DP_1 head type pronoun> = +        | pronouns different case CB 23May19
     <DP_1 head agr person first> = +
     <DP_1 head agr person third> = -  
     <DP_1 head agr person second> = -  
     <DP_1 head case_for_position> = objective  | to know normal case for conjoined DPs
    /<DP_1 head case> = objective
     <DP_1 head type pronoun> = +        | pronouns different case CB 23May19
     <DP_1 head agr person second> = +  
     <DP_1 head agr person third> = -  
     <DP_1 head agr person first> = -  
     <DP_1 head case_for_position> = objective  | to know normal case for conjoined DPs
    }
     <PP head type locative> = +
     <PP head type location_PP> = +    | to rule out PP IO  22Aug2019
     <PP head type sentential> = -
     <DP_2 head type locative> = +
     <DP_2 head case> = oblique
     <AdvP head type locative> = +
     <V head type copular> = -
     <V head type passive> = -
     <V head type motion> = +
    {<V head type transitive_motion> = +  | activated Apr2020, V must have transitive_motion
    /<V head infl valence causative> = +  | or motion verb + causative
    }
     <V head type object_agr_suffix> = -   |CB 24May19   cannot have object agreement
     <VP head auxiliaryH> == ~([rootgloss:be.able] &
                              [infl:[tense:[past:+]]])   | no past Aux to change tense Feb2020
     <VP rule> = 3cTRNonPastGeneric

rule {VP option 3cTRNonPastNonGenericIndefinite - motion transitive}
VP = DP_1 {PP / AdvP / DP_2} V
     <VP head> = <V head>
     <VP head object> = <DP_1>
     <VP head location> = <PP>
     <VP head location> = <AdvP>
     <VP head location> = <DP_2>
     <VP head type pro-drop> = -    | DP_1 should not be the subject Apr2020
     <V head infl tense past> = -
     <DP_1 head type generic> = -      | 30May19
     <DP_1 head type indefinite> = +
     <DP_1 head type temporal> = -       |Apr2020
    {<DP_1 head case> = direct         
     <DP_1 head type pronoun> = -
     <DP_1 head case_for_position> = direct  | to know normal case for conjoined DPs
    /<DP_1 head case> = oblique
     <DP_1 head type pronoun> = +
     <DP_1 head agr person third> = +  
     <DP_1 head agr person first> = -  
     <DP_1 head agr person second> = -  
     <DP_1 head case_for_position> = oblique  | to know normal case for conjoined DPs
    /<DP_1 head case> = objective
     <DP_1 head type pronoun> = +        | pronouns different case CB 23May19
     <DP_1 head agr person first> = +
     <DP_1 head agr person third> = -  
     <DP_1 head agr person second> = -  
     <DP_1 head case_for_position> = objective  | to know normal case for conjoined DPs
    /<DP_1 head case> = objective
     <DP_1 head type pronoun> = +        | pronouns different case CB 23May19
     <DP_1 head agr person second> = +  
     <DP_1 head agr person third> = -  
     <DP_1 head agr person first> = -  
     <DP_1 head case_for_position> = objective  | to know normal case for conjoined DPs
    }
     <PP head type locative> = +
     <PP head type location_PP> = +    | to rule out PP IO  22Aug2019
     <PP head type sentential> = -
     <DP_2 head type locative> = +
     <DP_2 head case> = oblique
     <AdvP head type locative> = +
     <V head type copular> = -
     <V head type passive> = -
     <V head type motion> = +
    {<V head type transitive_motion> = +  | activated Apr2020, V must have transitive_motion
    /<V head infl valence causative> = +  | or motion verb + causative
    }
     <V head type object_agr_suffix> = -   |CB 24May19   cannot have object agreement
     <VP head auxiliaryH> == ~([rootgloss:be.able] &
                              [infl:[tense:[past:+]]])   | no past Aux to change tense Feb2020
     <VP rule> = 3cTRNonPastNonGenericIndefinite

rule {VP option 3cTRNonPastNonGenericDefinite - motion transitive}
VP = DP_1 {PP / AdvP / DP_2} V
     <VP head> = <V head>
     <VP head object> = <DP_1>
     <VP head location> = <PP>
     <VP head location> = <AdvP>
     <VP head location> = <DP_2>
     <VP head type pro-drop> = -    | DP_1 should not be the subject Apr2020
     <V head infl tense past> = -
     <DP_1 head type generic> = -      | 30May19
     <DP_1 head type indefinite> = -
     <DP_1 head type temporal> = -       |Apr2020
    {<DP_1 head case> = oblique         
     <DP_1 head type pronoun> = -
     <DP_1 head case_for_position> = oblique  | to know normal case for conjoined DPs
    /<DP_1 head case> = oblique
     <DP_1 head type pronoun> = +
     <DP_1 head agr person third> = +  
     <DP_1 head agr person first> = -  
     <DP_1 head agr person second> = -  
     <DP_1 head case_for_position> = oblique  | to know normal case for conjoined DPs
    /<DP_1 head case> = objective
     <DP_1 head type pronoun> = +        | pronouns different case CB 23May19
     <DP_1 head agr person first> = +
     <DP_1 head agr person third> = -  
     <DP_1 head agr person second> = -  
     <DP_1 head case_for_position> = objective  | to know normal case for conjoined DPs
    /<DP_1 head case> = objective
     <DP_1 head type pronoun> = +        | pronouns different case CB 23May19
     <DP_1 head agr person second> = +  
     <DP_1 head agr person third> = -  
     <DP_1 head agr person first> = -  
     <DP_1 head case_for_position> = objective  | to know normal case for conjoined DPs
    }
     <PP head type locative> = +
     <PP head type location_PP> = +    | to rule out PP IO  22Aug2019
     <PP head type sentential> = -
     <DP_2 head type locative> = +
     <DP_2 head case> = oblique
     <AdvP head type locative> = +
     <V head type copular> = -
     <V head type passive> = -
     <V head type motion> = +
    {<V head type transitive_motion> = +  | activated Apr2020, V must have transitive_motion
    /<V head infl valence causative> = +  | or motion verb + causative
    }
     <V head type object_agr_suffix> = -   |CB 24May19   cannot have object agreement
     <VP head auxiliaryH> == ~([rootgloss:be.able] &
                              [infl:[tense:[past:+]]])   | no past Aux to change tense Feb2020
     <VP rule> = 3cTRNonPastNonGenericDefinite


rule {VP option 4badj - V final, copular w/ adj, not passive}
VP = AdjP V
    <VP head> = <V head>
    <VP head rootgloss> = <V rootgloss>
    <V head type copular> = +
    <AdjP head type comma> = -
    <AdjP head case> = direct
    <AdjP head type genitive_suffix> = -   |CB 16Aug19 Predicate adjectives not genitive suffix
    <AdjP head type attributive> = -   |CB 9May19 Predicate adjectives not attributive
    <V head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <VP head type passive> = -
    <VP head type no_intervening> = -   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
||    <AdjP head type> == ~[compound:+]     | AdjPs which are marked compound, must compound 22Aug2019 for 3rdPn2Dir
    <VP rule> = 4badj

|rule added 19Nov03 CB 
rule {VP option 4bPcop_sfx - V final, copular_suffix w/ P, not passive}
VP = P V
    <VP head> = <V head>
    <VP head rootgloss> = <V rootgloss>
    <V head type copular_suffix> = +
    <V head type compounded> = -      | 06-APR-04 CB to eliminate P [N V]-copsfx
    <V head case> = direct    | case for pronoun copular_suffix attached to
    <P head type comma> = -
    <V head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <VP head type passive> = -
    <VP head type no_intervening> = -   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <VP rule> = 4bPcop_sfx

rule {VP option 4badjPP - V final, copular w/ adj then PP, not passive}
VP = AdjP PP V
    <VP head> = <V head>
    <VP head rootgloss> = <V rootgloss>
    <V head type copular> = +
    <V head subject> = <PP head reflexive>  | pass reflexive info
    <PP head type comma> = -
    <AdjP head type comma> = -
    <AdjP head case> = direct
    <AdjP head type attributive> = -   |CB 9May19 Predicate adjectives not attributive
    <PP head type sentential> = -
    <V head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <VP head type passive> = -
    <VP head type no_intervening> = -   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <PP head object head type> == [modifier-final:+] -> ~[compound:+]  | PPs with modified objects whose final element is marked compound, must compound 16Jul03 CB
    <VP rule> = 4badjPP

rule {VP option 4bnom - V final, copular with predicate nominative, not passive}
VP = DP V
    <VP head> = <V head>
    <VP head rootgloss> = <V rootgloss>
    <V head type copular> = +
||    <V head type copular_suffix> = -   | copular_suffix use 4bnomCop_sfx for correct case ||08Jan2020 CB
    <V head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <V head subject> = <DP head reflexive>  | pass reflexive info
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = namely    | 21Nov03  CB
    /<DP head type relcl> = +        | can have comma if relcl 27Jan03 CB
     <DP head type comma> = +
     <DP head type apposition> = -
    }
    <DP head case_for_position> = direct  | to know normal case for conjoined DPs
    <DP head case> = direct
    <VP head type passive> = -
    <V head object> = <DP>   | for constraint on negative agreement, etc.
    <VP head type no_intervening> = -   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type> == [modifier-final:-] -> ~[sentential:+]   | nouns marked w/ sentential should be compound, unless modified 29Jan03CB
    <DP head type> == [modifier-final:+] -> ~[compound:+]  | modified DPs whose final element is marked compound, must compound 16Jul03 CB
    <VP head object head participle> = none   | to force participle to be w/ V or Aux 12-APR-04
    <VP head object head possessor head participle> = none   | to force participle to be w/ V or Aux 12-APR-04
    <VP head> == [rootgloss:^1] -> 
                  ~([object:[head:[type:[modifier-final:-]]]] &
                   (( [object:[head:[type:[compounds_with1:^1]]]]
                    / [object:[head:[type:[compounds_with2:^1]]]])
                    / ([object:[head:[type:[compounds_with3:^1]]]]
                    / [object:[head:[type:[compounds_with4:^1]]]]) ) ) |21Jul03
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <VP rule> = 4bnom

|optional Adv added **19Jul06 CB DP_1 temporal added 24Jul2019 
|removed 20Aug2019  (Adv / DP_1), reactivated Apr2020 all transitive rules
|*****split rule for past and then generic and definite*****
rule {VP option 5cPast - V final, transitive}
VP = DP (Adv / DP_1) V 
    <VP head> = <V head>
||    <VP head type pro-drop> = -     | subject must be overt Ron says true only for Balochi Feb2020
    <VP head rootgloss> = <V rootgloss>
    <VP head object> = <DP>
    <VP head type transitive> = +  
    <V head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use
   {<VP head infl tense past> = +
    <VP head infl tense present> = - 
   /<VP head infl tense past> = -
    <VP head infl mood subjunctive> = +        | Apr2020
    <VP head auxiliaryH rootgloss> = be.able  |tense from Aux  Feb2020
    <VP head auxliairy infl tense past> = +  | must be past Aux Apr2020
    <VP head type auxiliary> = +             | Aux must be present Apr2020
   }
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <V head type copular> = -
    <V head type passive> = -
|    <Adv head type manner> = +	     | manner Adv in this position ** 19Jul06 CB, enable after feature added to dictionary
    <Adv head type locative> = -
    <Adv head type temporal> = +
    <DP_1 head type locative> = -
    <DP_1 head type temporal> = +
    <DP_1 head case> = direct         
    <DP_1 head type modifier-final> = -
    <DP_1 head type pronoun> = -
    <V head subject> = <DP head reflexive>  | pass reflexive info
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = namely    | 21Nov03  CB
    /<DP head type relcl> = +        | can have comma if relcl 27Jan03 CB
     <DP head type comma> = +
     <DP head type apposition> = -
    }
     <DP head type temporal> = -       |Apr2020
    {<DP head case> = direct         
     <DP head type pronoun> = -
    <DP head case_for_position> = direct  | to know normal case for conjoined DPs
    /<DP head case> = direct
     <DP head type pronoun> = +
     <DP head agr person third> = +  
     <DP head agr person first> = -  
     <DP head agr person second> = -  
    <DP head case_for_position> = direct  | to know normal case for conjoined DPs
    /<DP head case> = objective
     <DP head type pronoun> = +        | pronouns different case CB 23May19
     <DP head agr person first> = +
     <DP head agr person third> = -  
     <DP head agr person second> = -  
    <DP head case_for_position> = objective  | to know normal case for conjoined DPs
    /<DP head case> = objective
     <DP head type pronoun> = +        | pronouns different case CB 23May19
     <DP head agr person second> = +  
     <DP head agr person third> = -  
     <DP head agr person first> = -  
    <DP head case_for_position> = objective  | to know normal case for conjoined DPs
    }
    <VP head type no_intervening> = -   | for compounding constraint
    <DP head type nonfinalcoordination> = -
    <V head type object_agr_suffix> = +   |CB 24May19   must have object agreement
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type> == [modifier-final:+] -> ~[compound:+]  | modified DPs whose final element is marked compound, must compound 16Jul03 CB
    <VP head> == [rootgloss:^1] -> 
                  ~(([object:[head:[type:[modifier-final:-]]]] 
                    &[object:[head:[type:[case-marked:-]]]] ) &
                   (( [object:[head:[type:[compounds_with1:^1]]]]
                    / [object:[head:[type:[compounds_with2:^1]]]])
                    /([object:[head:[type:[compounds_with3:^1]]]]
                    / [object:[head:[type:[compounds_with4:^1]]]]) ) ) |21Jul03
    <VP head> == [rootgloss:^1] ->
                  ~(([object:[head:[relativity:[conjoined:+]]]] ) &
                   (( [object:[head:[relativity:[compounds_with1:^1]]]]
                    / [object:[head:[relativity:[compounds_with2:^1]]]])
                    /([object:[head:[relativity:[compounds_with3:^1]]]]
                    / [object:[head:[relativity:[compounds_with4:^1]]]]) ) ) |20Oct03  for special case of relcl2+kh and 0a-DP
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <VP rule> = 5cPast

rule {VP option 5cNonPastGeneric - V final, transitive}
VP = DP (Adv / DP_1) V
    <VP head> = <V head>
    <VP head rootgloss> = <V rootgloss>
    <V head object> = <DP>
    <V head type transitive> = +
    <V head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl tense past> = -
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <DP head type generic> = +       | 30May19
    <V head type copular> = -
    <V head type passive> = -
|    <Adv head type manner> = +	     | manner Adv in this position ** 19Jul06 CB, enable after feature added to dictionary
    <Adv head type locative> = -
    <Adv head type temporal> = +
    <DP_1 head type locative> = -
    <DP_1 head type temporal> = +
    <DP_1 head case> = direct         
    <DP_1 head type modifier-final> = -
    <DP_1 head type pronoun> = -
    <V head subject> = <DP head reflexive>  | pass reflexive info
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = namely    | 21Nov03  CB
    /<DP head type relcl> = +        | can have comma if relcl 27Jan03 CB
     <DP head type comma> = +
     <DP head type apposition> = -
    }
     <DP head type temporal> = -       |Apr2020
    {<DP head case> = direct         
    <DP head case_for_position> = direct   | to know normal case for conjoined DPs
     <DP head type pronoun> = -
    /<DP head case> = oblique          | pronouns different case CB 23May19
    <DP head case_for_position> = oblique   | to know normal case for conjoined DPs
     <DP head type pronoun> = +
     <DP head agr person third> = +  
     <DP head agr person first> = -  
     <DP head agr person second> = -  
    /<DP head case> = objective
    <DP head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type pronoun> = +        | pronouns different case CB 23May19
     <DP head agr person first> = +
     <DP head agr person third> = -  
     <DP head agr person second> = -  
    /<DP head case> = objective
    <DP head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type pronoun> = +        | pronouns different case CB 23May19
     <DP head agr person second> = +  
     <DP head agr person third> = -  
     <DP head agr person first> = -  
    }
    <VP head type no_intervening> = -   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type> == [modifier-final:+] -> ~[compound:+]  | modified DPs whose final element is marked compound, must compound 16Jul03 CB
    <VP head> == [rootgloss:^1] -> 
                  ~(([object:[head:[type:[modifier-final:-]]]] 
                    &[object:[head:[type:[case-marked:-]]]] ) &
                   (( [object:[head:[type:[compounds_with1:^1]]]]
                    / [object:[head:[type:[compounds_with2:^1]]]])
                    /([object:[head:[type:[compounds_with3:^1]]]]
                    / [object:[head:[type:[compounds_with4:^1]]]]) ) ) |21Jul03
    <VP head> == [rootgloss:^1] ->
                  ~(([object:[head:[relativity:[conjoined:+]]]] ) &
                   (( [object:[head:[relativity:[compounds_with1:^1]]]]
                    / [object:[head:[relativity:[compounds_with2:^1]]]])
                    /([object:[head:[relativity:[compounds_with3:^1]]]]
                    / [object:[head:[relativity:[compounds_with4:^1]]]]) ) ) |20Oct03  for special case of relcl2+kh and 0a-DP
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
     <VP head auxiliaryH> == ~([rootgloss:be.able] &
                              [infl:[tense:[past:+]]])   | no past Aux to change tense Feb2020
    <VP rule> = 5cNonPastGeneric

rule {VP option 5cNonPastNonGenericIndefinite - V final, transitive}
VP = DP (Adv / DP_1) V                        
    <VP head> = <V head>
    <VP head rootgloss> = <V rootgloss>
    <V head object> = <DP>
    <V head type transitive> = +
    <V head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl tense past> = -
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <DP head type generic> = -       | 30May19
    <V head type copular> = -
    <V head type passive> = -
|    <Adv head type manner> = +	     | manner Adv in this position ** 19Jul06 CB, enable after feature added to dictionary
    <Adv head type locative> = -
    <Adv head type temporal> = +
    <DP_1 head type locative> = -
    <DP_1 head type temporal> = +
    <DP_1 head case> = direct         
    <DP_1 head type modifier-final> = -
    <DP_1 head type pronoun> = -
    <V head subject> = <DP head reflexive>  | pass reflexive info
    <DP head type indefinite> = +
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = namely    | 21Nov03  CB
    /<DP head type relcl> = +        | can have comma if relcl 27Jan03 CB
     <DP head type comma> = +
     <DP head type apposition> = -
    }
     <DP head type temporal> = -       |Apr2020
    {<DP head case> = direct         
    <DP head case_for_position> = direct  | to know normal case for conjoined DPs
     <DP head type pronoun> = -
    /<DP head case> = oblique          | pronouns different case CB 23May19
    <DP head case_for_position> = oblique  | to know normal case for conjoined DPs
     <DP head type pronoun> = +
     <DP head agr person third> = +  
     <DP head agr person first> = -  
     <DP head agr person second> = -  
    /<DP head case> = objective
    <DP head case_for_position> = objective  | to know normal case for conjoined DPs
     <DP head type pronoun> = +        | pronouns different case CB 23May19
     <DP head agr person first> = +
     <DP head agr person third> = -  
     <DP head agr person second> = -  
    /<DP head case> = objective
    <DP head case_for_position> = objective  | to know normal case for conjoined DPs
     <DP head type pronoun> = +        | pronouns different case CB 23May19
     <DP head agr person second> = +  
     <DP head agr person third> = -  
     <DP head agr person first> = -  
    }
    <VP head type no_intervening> = -   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type> == [modifier-final:+] -> ~[compound:+]  | modified DPs whose final element is marked compound, must compound 16Jul03 CB
    <VP head> == [rootgloss:^1] -> 
                  ~(([object:[head:[type:[modifier-final:-]]]] 
                    &[object:[head:[type:[case-marked:-]]]] ) &
                   (( [object:[head:[type:[compounds_with1:^1]]]]
                    / [object:[head:[type:[compounds_with2:^1]]]])
                    /([object:[head:[type:[compounds_with3:^1]]]]
                    / [object:[head:[type:[compounds_with4:^1]]]]) ) ) |21Jul03
    <VP head> == [rootgloss:^1] ->
                  ~(([object:[head:[relativity:[conjoined:+]]]] ) &
                   (( [object:[head:[relativity:[compounds_with1:^1]]]]
                    / [object:[head:[relativity:[compounds_with2:^1]]]])
                    /([object:[head:[relativity:[compounds_with3:^1]]]]
                    / [object:[head:[relativity:[compounds_with4:^1]]]]) ) ) |20Oct03  for special case of relcl2+kh and 0a-DP
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
     <VP head auxiliaryH> == ~([rootgloss:be.able] &
                              [infl:[tense:[past:+]]])   | no past Aux to change tense Feb2020
    <VP rule> = 5cNonPastNonGenericIndefinite

rule {VP option 5cNonPastNonGenericDefinite - V final, transitive}
VP = DP (Adv / DP_1) V                         
    <VP head> = <V head>
    <VP head rootgloss> = <V rootgloss>
    <V head object> = <DP>
    <V head type transitive> = +
    <V head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl tense past> = -
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <DP head type generic> = -      | 30May19
    <V head type copular> = -
    <V head type passive> = -
|    <Adv head type manner> = +	     | manner Adv in this position ** 19Jul06 CB, enable after feature added to dictionary
    <Adv head type locative> = -
    <Adv head type temporal> = +
    <DP_1 head type locative> = -
    <DP_1 head type temporal> = +
    <DP_1 head case> = direct         
    <DP_1 head type modifier-final> = -
    <DP_1 head type pronoun> = -
    <V head subject> = <DP head reflexive>  | pass reflexive info
    <DP head type indefinite> = -
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = namely    | 21Nov03  CB
    /<DP head type relcl> = +        | can have comma if relcl 27Jan03 CB
     <DP head type comma> = +
     <DP head type apposition> = -
    }
     <DP head type temporal> = -       |Apr2020
    {<DP head case> = oblique         
    <DP head case_for_position> = oblique    | to know normal case for conjoined DPs
     <DP head type pronoun> = -
    /<DP head case> = oblique          | pronouns different case CB 23May19
    <DP head case_for_position> = oblique    | to know normal case for conjoined DPs
     <DP head type pronoun> = +
     <DP head agr person third> = +  
     <DP head agr person first> = -  
     <DP head agr person second> = -  
    /<DP head case> = objective
    <DP head case_for_position> = objective  | to know normal case for conjoined DPs
     <DP head type pronoun> = +        | pronouns different case CB 23May19
     <DP head agr person first> = +
     <DP head agr person third> = -  
     <DP head agr person second> = -  
    /<DP head case> = objective
    <DP head case_for_position> = objective  | to know normal case for conjoined DPs
     <DP head type pronoun> = +        | pronouns different case CB 23May19
     <DP head agr person second> = +  
     <DP head agr person third> = -  
     <DP head agr person first> = -  
    }
    <VP head type no_intervening> = -   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type> == [modifier-final:+] -> ~[compound:+]  | modified DPs whose final element is marked compound, must compound 16Jul03 CB
    <VP head> == [rootgloss:^1] -> 
                  ~(([object:[head:[type:[modifier-final:-]]]] 
                    &[object:[head:[type:[case-marked:-]]]] ) &
                   (( [object:[head:[type:[compounds_with1:^1]]]]
                    / [object:[head:[type:[compounds_with2:^1]]]])
                    /([object:[head:[type:[compounds_with3:^1]]]]
                    / [object:[head:[type:[compounds_with4:^1]]]]) ) ) |21Jul03
    <VP head> == [rootgloss:^1] ->
                  ~(([object:[head:[relativity:[conjoined:+]]]] ) &
                   (( [object:[head:[relativity:[compounds_with1:^1]]]]
                    / [object:[head:[relativity:[compounds_with2:^1]]]])
                    /([object:[head:[relativity:[compounds_with3:^1]]]]
                    / [object:[head:[relativity:[compounds_with4:^1]]]]) ) ) |20Oct03  for special case of relcl2+kh and 0a-DP
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
     <VP head auxiliaryH> == ~([rootgloss:be.able] &
                              [infl:[tense:[past:+]]])   | no past Aux to change tense Feb2020
    <VP rule> = 5cNonPastNonGenericDefinite


|***Splitting this rule 26Jun2019 for case marking***adding object agreement for past only requirement 28Jun2019**All ditransitives now split Jan 2020**
rule {VP option 6cIPPpast - V final, DP initial and ditransitive with PP, past only}
VP = DP PP V
    <VP head> = <V head>
   {<VP head infl tense past> = +
   /<V head infl tense past> = -
    <VP head auxiliaryH rootgloss> = be.able  |tense from Aux
   }
    <VP head rootgloss> = <V rootgloss>
    <V head object> = <DP>
    <V head indirectobject> = <PP head object>
    <PP head rootgloss> = to
    <V head type ditransitive> = +
    <V head type transitive> = +
    <V head case> = direct       | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <V head type copular> = -
    <V head type motion> = -     | Feb2020
    <V head subject> = <DP head reflexive>  | pass reflexive info
    <V head subject> = <PP head reflexive> | pass reflexive info
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = namely    | 21Nov03  CB
    /<DP head type relcl> = +        | can have comma if relcl 27Jan03 CB
     <DP head type comma> = +
     <DP head type apposition> = -
    }
    <PP head type comma> = -
     <DP head type temporal> = -       |Apr2020
    {<DP head case> = direct          | 17Feb03 CB
    <DP head case_for_position> = direct   | to know normal case for conjoined DPs
     <DP head type pronoun> = -
    /<DP head case> = direct
    <DP head case_for_position> = direct   | to know normal case for conjoined DPs
     <DP head type pronoun> = +
     <DP head agr person third> = +
     <DP head agr person first> = -
     <DP head agr person second> = -
    /<DP head case> = objective       | first and second person pronouns get objective case
    <DP head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type pronoun> = +
     <DP head agr person third> = -
     <DP head agr person first> = +
     <DP head agr person second> = -
    /<DP head case> = objective
    <DP head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type pronoun> = +
     <DP head agr person third> = -
     <DP head agr person first> = -
     <DP head agr person second> = +
   }
    <PP head object head case_for_position> = objective   | to know normal case for conjoined DPs 
    <PP head object head case> = objective  | IO always objective case in past
    <PP head type sentential> = -
    <VP head type passive> = -
    <VP head type no_intervening> = -   | for compounding constraint
    <V head type object_agr_suffix> = +   |CB 28Jun19   must have object agr
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <PP head object head type> == [modifier-final:+] -> ~[compound:+]  | PPs with modified objects whose final element is marked compound, must compound 16Jul03 CB
    <VP rule> = 6cIPPpast

|split for past then generic and definite
rule {VP option 6cIPPnonPastGeneric - V final, DP initial and ditransitive with PP}
VP = DP PP V
    <VP head> = <V head>
    <VP head infl tense past> = -
    <VP head rootgloss> = <V rootgloss>
    <V head object> = <DP>
    <V head indirectobject> = <PP head object>    | 22Aug2019
    <PP head rootgloss> = to
    <V head type ditransitive> = +
    <V head type transitive> = +
    <V head type motion> = -     | Feb2020
    <V head case> = direct       | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <DP head type generic> = +       | 30May19
    <V head type copular> = -
    <V head type passive> = -
    <V head subject> = <DP head reflexive>  | pass reflexive info
    <V head subject> = <PP head reflexive> | pass reflexive info
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = namely    | 21Nov03  CB
    /<DP head type relcl> = +        | can have comma if relcl 27Jan03 CB
     <DP head type comma> = +
     <DP head type apposition> = -
    }
    <PP head type comma> = -
     <DP head type temporal> = -       |Apr2020
    {<DP head case> = direct         
    <DP head case_for_position> = direct   | to know normal case for conjoined DPs
     <DP head type pronoun> = -
    /<DP head case> = oblique          | pronouns different case CB 23May19
    <DP head case_for_position> = oblique   | to know normal case for conjoined DPs
     <DP head type pronoun> = +
     <DP head agr person third> = +  
     <DP head agr person first> = -  
     <DP head agr person second> = -  
    /<DP head case> = objective
    <DP head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type pronoun> = +        | pronouns different case CB 23May19
     <DP head agr person first> = +
     <DP head agr person third> = -  
     <DP head agr person second> = -  
    /<DP head case> = objective
    <DP head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type pronoun> = +        | pronouns different case CB 23May19
     <DP head agr person second> = +  
     <DP head agr person third> = -  
     <DP head agr person first> = -  
    }
    {<PP head object head case> = objective
     <PP head object head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type animate> = +
     <PP head object head type pronoun> = -
    /<PP head object head case> = oblique  
     <PP head object head case_for_position> = oblique   | to know normal case for conjoined DPs
     <DP head type animate> = -
     <PP head object head type pronoun> = -
    /<PP head object head case> = oblique          | pronouns different case CB 23May19
     <PP head object head case_for_position> = oblique   | to know normal case for conjoined DPs
     <DP head type animate> = -
     <PP head object head type pronoun> = +
     <PP head object head agr person third> = +  
     <PP head object head agr person first> = -  
     <PP head object head agr person second> = -  
    /<PP head object head case> = objective          | pronouns different case CB 23May19
     <PP head object head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type animate> = +
     <PP head object head type pronoun> = +
     <PP head object head agr person third> = +  
     <PP head object head agr person first> = -  
     <PP head object head agr person second> = -  
    /<PP head object head case> = objective
     <PP head object head case_for_position> = objective   | to know normal case for conjoined DPs
     <PP head object head type pronoun> = +        | pronouns different case CB 23May19
     <PP head object head agr person first> = +
     <PP head object head agr person third> = -  
     <PP head object head agr person second> = -  
    /<PP head object head case> = objective
     <PP head object head case_for_position> = objective   | to know normal case for conjoined DPs
     <PP head object head type pronoun> = +        | pronouns different case CB 23May19
     <PP head object head agr person second> = +  
     <PP head object head agr person third> = -  
     <PP head object head agr person first> = -  
    }
     <PP head type sentential> = -
     <VP head type passive> = -
     <VP head type no_intervening> = -   | for compounding constraint
     <V head type object_agr_suffix> = -   |CB 24May19   no object agr
     <DP head type nonfinalcoordination> = -
     <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
     <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
     <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
     <PP head object head type> == [modifier-final:+] -> ~[compound:+]  | PPs with modified objects whose final element is marked compound, must compound 16Jul03 CB
     <VP head auxiliaryH> == ~([rootgloss:be.able] &
                              [infl:[tense:[past:+]]])   | no past Aux to change tense Feb2020
     <VP rule> = 6cIPPnonPastGeneric

rule {VP option 6cIPPnonPastNonGenericIndefinite - V final, DP initial and ditransitive with PP}
VP = DP PP V
    <VP head> = <V head>
    <VP head infl tense past> = -
    <VP head rootgloss> = <V rootgloss>
    <V head object> = <DP>
    <V head indirectobject> = <PP head object>    | 22Aug2019
    <PP head rootgloss> = to
    <DP head type generic> = -       | 30May19
    <DP head type indefinite> = +
    <V head type ditransitive> = +
    <V head type transitive> = +
    <V head type motion> = -     | Feb2020
    <V head case> = direct       | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <V head type copular> = -
    <V head subject> = <DP head reflexive>  | pass reflexive info
    <V head subject> = <PP head reflexive> | pass reflexive info
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = namely    | 21Nov03  CB
    /<DP head type relcl> = +        | can have comma if relcl 27Jan03 CB
     <DP head type comma> = +
     <DP head type apposition> = -
    }
    <PP head type comma> = -
     <DP head type temporal> = -       |Apr2020
    {<DP head case> = direct         
    <DP head case_for_position> = direct   | to know normal case for conjoined DPs
     <DP head type pronoun> = -
    /<DP head case> = oblique          | pronouns different case CB 23May19
    <DP head case_for_position> = oblique   | to know normal case for conjoined DPs
     <DP head type pronoun> = +
     <DP head agr person third> = +  
     <DP head agr person first> = -  
     <DP head agr person second> = -  
    /<DP head case> = objective
    <DP head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type pronoun> = +        | pronouns different case CB 23May19
     <DP head agr person first> = +
     <DP head agr person third> = -  
     <DP head agr person second> = -  
    /<DP head case> = objective
    <DP head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type pronoun> = +        | pronouns different case CB 23May19
     <DP head agr person second> = +  
     <DP head agr person third> = -  
     <DP head agr person first> = -  
    }
    {<PP head object head case> = objective  
     <PP head object head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type animate> = +
     <PP head object head type pronoun> = -
    /<PP head object head case> = oblique  
     <PP head object head case_for_position> = oblique   | to know normal case for conjoined DPs
     <DP head type animate> = -
     <PP head object head type pronoun> = -
    /<PP head object head case> = oblique          | pronouns different case CB 23May19
     <PP head object head case_for_position> = oblique   | to know normal case for conjoined DPs
     <DP head type animate> = -
     <PP head object head type pronoun> = +
     <PP head object head agr person third> = +  
     <PP head object head agr person first> = -  
     <PP head object head agr person second> = -  
    /<PP head object head case> = objective          | pronouns different case CB 23May19
     <PP head object head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type animate> = +
     <PP head object head type pronoun> = +
     <PP head object head agr person third> = +  
     <PP head object head agr person first> = -  
     <PP head object head agr person second> = -  
    /<PP head object head case> = objective
     <PP head object head case_for_position> = objective   | to know normal case for conjoined DPs
     <PP head object head type pronoun> = +        | pronouns different case CB 23May19
     <PP head object head agr person first> = +
     <PP head object head agr person third> = -  
     <PP head object head agr person second> = -  
    /<PP head object head case> = objective
     <PP head object head case_for_position> = objective   | to know normal case for conjoined DPs
     <PP head object head type pronoun> = +        | pronouns different case CB 23May19
     <PP head object head agr person second> = +  
     <PP head object head agr person third> = -  
     <PP head object head agr person first> = -  
    }
    <PP head type sentential> = -
    <VP head type passive> = -
    <VP head type no_intervening> = -   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <PP head object head type> == [modifier-final:+] -> ~[compound:+]  | PPs with modified objects whose final element is marked compound, must compound 16Jul03 CB
     <VP head auxiliaryH> == ~([rootgloss:be.able] &
                              [infl:[tense:[past:+]]])   | no past Aux to change tense Feb2020
    <VP rule> = 6cIPPnonPastNonGenericIndefinite

rule {VP option 6cIPPnonPastNonGenericDefinite - V final, DP initial and ditransitive with PP}
VP = DP PP V
    <VP head> = <V head>
    <VP head infl tense past> = -
    <VP head rootgloss> = <V rootgloss>
    <V head object> = <DP>
    <V head indirectobject> = <PP head object>    | 22Aug2019
    <PP head rootgloss> = to
    <DP head type generic> = -
    <DP head type indefinite> = -
    <V head type ditransitive> = +
    <V head type transitive> = +
    <V head type motion> = -     | Feb2020
    <V head case> = direct       | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <V head type copular> = -
    <V head subject> = <DP head reflexive>  | pass reflexive info
    <V head subject> = <PP head reflexive> | pass reflexive info
|    {<DP head type comma> = -
|     <DP head type apposition> = -
|    /<DP head type apposition> = +    | 17Jan03  CB
|    /<DP head type apposition> = namely    | 21Nov03  CB
|    /<DP head type relcl> = +        | can have comma if relcl 27Jan03 CB
|     <DP head type comma> = +
|     <DP head type apposition> = -
|    }
    <PP head type comma> = -
     <DP head type temporal> = -       |Apr2020
    {<DP head case> = oblique         
    <DP head case_for_position> = oblique    | to know normal case for conjoined DPs
     <DP head type pronoun> = -
    /<DP head case> = oblique          | pronouns different case CB 23May19
    <DP head case_for_position> = oblique    | to know normal case for conjoined DPs
     <DP head type pronoun> = +
     <DP head agr person third> = +  
     <DP head agr person first> = -  
     <DP head agr person second> = -  
    /<DP head case> = objective
    <DP head case_for_position> = objective    | to know normal case for conjoined DPs
     <DP head type pronoun> = +        | pronouns different case CB 23May19
     <DP head agr person first> = +
     <DP head agr person third> = -  
     <DP head agr person second> = -  
    /<DP head case> = objective
    <DP head case_for_position> = objective    | to know normal case for conjoined DPs
     <DP head type pronoun> = +        | pronouns different case CB 23May19
     <DP head agr person second> = +  
     <DP head agr person third> = -  
     <DP head agr person first> = -  
    }
    {<PP head object head case> = objective        
     <PP head object head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type animate> = +
     <PP head object head type pronoun> = -
    /<PP head object head case> = oblique  
     <PP head object head case_for_position> = oblique   | to know normal case for conjoined DPs
     <DP head type animate> = -
     <PP head object head type pronoun> = -
    /<PP head object head case> = oblique          | pronouns different case CB 23May19
     <PP head object head case_for_position> = oblique   | to know normal case for conjoined DPs
     <DP head type animate> = -
     <PP head object head type pronoun> = +
     <PP head object head agr person third> = +  
     <PP head object head agr person first> = -  
     <PP head object head agr person second> = -  
    /<PP head object head case> = objective          | pronouns different case CB 23May19
     <PP head object head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type animate> = +
     <PP head object head type pronoun> = +
     <PP head object head agr person third> = +  
     <PP head object head agr person first> = -  
     <PP head object head agr person second> = -  
    /<PP head object head case> = objective
     <PP head object head case_for_position> = objective   | to know normal case for conjoined DPs
     <PP head object head type pronoun> = +        | pronouns different case CB 23May19
     <PP head object head agr person first> = +
     <PP head object head agr person third> = -  
     <PP head object head agr person second> = -  
    /<PP head object head case> = objective
     <PP head object head case_for_position> = objective   | to know normal case for conjoined DPs
     <PP head object head type pronoun> = +        | pronouns different case CB 23May19
     <PP head object head agr person second> = +  
     <PP head object head agr person third> = -  
     <PP head object head agr person first> = -  
    }
    <PP head type sentential> = -
    <VP head type passive> = -
    <VP head type no_intervening> = -   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <PP head object head type> == [modifier-final:+] -> ~[compound:+]  | PPs with modified objects whose final element is marked compound, must compound 16Jul03 CB
     <VP head auxiliaryH> == ~([rootgloss:be.able] &
                              [infl:[tense:[past:+]]])   | no past Aux to change tense Feb2020
    <VP rule> = 6cIPPnonPastNonGenericDefinite

|***added 30May19 CB  For Object 3 *** split 26Jun2019
rule {VP option 6cIDPpast - V final, PP initial and ditransitive with DP}
VP = PP DP V
    <VP head> = <V head>
   {<VP head infl tense past> = +
   /<V head infl tense past> = -
    <VP head auxiliaryH rootgloss> = be.able  |tense from Aux
   }
    <VP head rootgloss> = <V rootgloss>
    <V head object> = <DP>
    <V head indirectobject> = <PP head object>
    <PP head rootgloss> = to
    <V head type ditransitive> = +
    <V head type transitive> = +
    <V head case> = direct       | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <V head type copular> = -
    <V head subject> = <DP head reflexive>  | pass reflexive info
    <V head subject> = <PP head reflexive> | pass reflexive info
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = namely    | 21Nov03  CB
    /<DP head type relcl> = +        | can have comma if relcl 27Jan03 CB
     <DP head type comma> = +
     <DP head type apposition> = -
    }
    <PP head type comma> = -
     <DP head type temporal> = -       |Apr2020
    {<DP head case> = direct          | 17Feb03 CB
    <DP head case_for_position> = direct   | to know normal case for conjoined DPs
     <DP head type pronoun> = -
    /<DP head case> = direct
    <DP head case_for_position> = direct   | to know normal case for conjoined DPs
     <DP head type pronoun> = +
     <DP head agr person third> = +
     <DP head agr person first> = -
     <DP head agr person second> = -
    /<DP head case> = objective       | first and second person pronouns get objective case
    <DP head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type pronoun> = +
     <DP head agr person third> = -
     <DP head agr person first> = +
     <DP head agr person second> = -
    /<DP head case> = objective
    <DP head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type pronoun> = +
     <DP head agr person third> = -
     <DP head agr person first> = -
     <DP head agr person second> = +
   }
    <PP head object head case_for_position> = objective   | to know normal case for conjoined DPs
    <PP head object head case> = objective  | IO always objective case  
    <PP head type sentential> = -
    <VP head type passive> = -
    <VP head type no_intervening> = -   | for compounding constraint
    <V head type object_agr_suffix> = +   |CB 28Jun19   must have object agr
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <PP head object head type> == [modifier-final:+] -> ~[compound:+]  | PPs with modified objects whose final element is marked compound, must compound 16Jul03 CB
    <VP rule> = 6cIDPpast

|split for past then generic and definite
rule {VP option 6cIDPnonPastGeneric - V final, PP initial and ditransitive with DP}
VP = PP DP V
    <VP head> = <V head>
    <VP head infl tense past> = -
    <VP head rootgloss> = <V rootgloss>
    <V head object> = <DP>
    <V head indirectobject> = <PP head object>    | 22Aug2019
    <PP head rootgloss> = to
    <DP head type generic> = +       | 30May19
    <V head type ditransitive> = +
    <V head type transitive> = +
    <V head case> = direct       | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <V head type copular> = -
    <V head subject> = <DP head reflexive>  | pass reflexive info
    <V head subject> = <PP head reflexive> | pass reflexive info
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = namely    | 21Nov03  CB
    /<DP head type relcl> = +        | can have comma if relcl 27Jan03 CB
     <DP head type comma> = +
     <DP head type apposition> = -
    }
    <PP head type comma> = -
     <DP head type temporal> = -       |Apr2020
    {<DP head case> = direct         
    <DP head case_for_position> = direct   | to know normal case for conjoined DPs
     <DP head type pronoun> = -
    /<DP head case> = oblique          | pronouns different case CB 23May19
    <DP head case_for_position> = oblique   | to know normal case for conjoined DPs
     <DP head type pronoun> = +
     <DP head agr person third> = +  
     <DP head agr person first> = -  
     <DP head agr person second> = -  
    /<DP head case> = objective
    <DP head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type pronoun> = +        | pronouns different case CB 23May19
     <DP head agr person first> = +
     <DP head agr person third> = -  
     <DP head agr person second> = -  
    /<DP head case> = objective
    <DP head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type pronoun> = +        | pronouns different case CB 23May19
     <DP head agr person second> = +  
     <DP head agr person third> = -  
     <DP head agr person first> = -  
    }
    {<PP head object head case> = objective  
    <PP head object head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type animate> = +
     <PP head object head type pronoun> = -
    /<PP head object head case> = oblique      
    <PP head object head case_for_position> = oblique   | to know normal case for conjoined DPs
     <DP head type animate> = -
     <PP head object head type pronoun> = -
    /<PP head object head case> = oblique          | pronouns different case CB 23May19
    <PP head object head case_for_position> = oblique   | to know normal case for conjoined DPs
     <DP head type animate> = -
     <PP head object head type pronoun> = +
     <PP head object head agr person third> = +  
     <PP head object head agr person first> = -  
     <PP head object head agr person second> = -  
    /<PP head object head case> = objective          | pronouns different case CB 23May19
    <PP head object head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type animate> = +
     <PP head object head type pronoun> = +
     <PP head object head agr person third> = +  
     <PP head object head agr person first> = -  
     <PP head object head agr person second> = -  
    /<PP head object head case> = objective
    <PP head object head case_for_position> = objective   | to know normal case for conjoined DPs
     <PP head object head type pronoun> = +        | pronouns different case CB 23May19
     <PP head object head agr person first> = +
     <PP head object head agr person third> = -  
     <PP head object head agr person second> = -  
    /<PP head object head case> = objective
    <PP head object head case_for_position> = objective   | to know normal case for conjoined DPs
     <PP head object head type pronoun> = +        | pronouns different case CB 23May19
     <PP head object head agr person second> = +  
     <PP head object head agr person third> = -  
     <PP head object head agr person first> = -  
    }
    <PP head type sentential> = -
    <VP head type passive> = -
    <VP head type no_intervening> = -   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <PP head object head type> == [modifier-final:+] -> ~[compound:+]  | PPs with modified objects whose final element is marked compound, must compound 16Jul03 CB
     <VP head auxiliaryH> == ~([rootgloss:be.able] &
                              [infl:[tense:[past:+]]])   | no past Aux to change tense Feb2020
    <VP rule> = 6cIDPnonPastGeneric

rule {VP option 6cIDPnonPastNonGenericIndefinite - V final, PP initial and ditransitive with DP}
VP = PP DP V
    <VP head> = <V head>
    <VP head infl tense past> = -
    <VP head rootgloss> = <V rootgloss>
    <V head object> = <DP>
    <V head indirectobject> = <PP head object>    | 22Aug2019
    <PP head rootgloss> = to
    <DP head type generic> = -       | 30May19
    <DP head type indefinite> = +
    <V head type ditransitive> = +
    <V head type transitive> = +
    <V head case> = direct       | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <V head type copular> = -
    <V head subject> = <DP head reflexive>  | pass reflexive info
    <V head subject> = <PP head reflexive> | pass reflexive info
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = namely    | 21Nov03  CB
    /<DP head type relcl> = +        | can have comma if relcl 27Jan03 CB
     <DP head type comma> = +
     <DP head type apposition> = -
    }
    <PP head type comma> = -
     <DP head type temporal> = -       |Apr2020
    {<DP head case> = direct         
    <DP head case_for_position> = direct   | to know normal case for conjoined DPs
     <DP head type pronoun> = -
    /<DP head case> = oblique          | pronouns different case CB 23May19
    <DP head case_for_position> = oblique   | to know normal case for conjoined DPs
     <DP head type pronoun> = +
     <DP head agr person third> = +  
     <DP head agr person first> = -  
     <DP head agr person second> = -  
    /<DP head case> = objective
    <DP head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type pronoun> = +        | pronouns different case CB 23May19
     <DP head agr person first> = +
     <DP head agr person third> = -  
     <DP head agr person second> = -  
    /<DP head case> = objective
    <DP head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type pronoun> = +        | pronouns different case CB 23May19
     <DP head agr person second> = +  
     <DP head agr person third> = -  
     <DP head agr person first> = -  
    }
    {<PP head object head case> = objective  
     <PP head object head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type animate> = +
     <PP head object head type pronoun> = -
    /<PP head object head case> = oblique
     <PP head object head case_for_position> = oblique   | to know normal case for conjoined DPs
     <DP head type animate> = -
     <PP head object head type pronoun> = -
    /<PP head object head case> = oblique          | pronouns different case CB 23May19
     <PP head object head case_for_position> = oblique   | to know normal case for conjoined DPs
     <DP head type animate> = -
     <PP head object head type pronoun> = +
     <PP head object head agr person third> = +  
     <PP head object head agr person first> = -  
     <PP head object head agr person second> = -  
    /<PP head object head case> = objective          | pronouns different case CB 23May19
     <PP head object head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type animate> = +
     <PP head object head type pronoun> = +
     <PP head object head agr person third> = +  
     <PP head object head agr person first> = -  
     <PP head object head agr person second> = -  
    /<PP head object head case> = objective
     <PP head object head case_for_position> = objective   | to know normal case for conjoined DPs
     <PP head object head type pronoun> = +        | pronouns different case CB 23May19
     <PP head object head agr person first> = +
     <PP head object head agr person third> = -  
     <PP head object head agr person second> = -  
    /<PP head object head case> = objective
     <PP head object head case_for_position> = objective   | to know normal case for conjoined DPs
     <PP head object head type pronoun> = +        | pronouns different case CB 23May19
     <PP head object head agr person second> = +  
     <PP head object head agr person third> = -  
     <PP head object head agr person first> = -  
    }
    <PP head type sentential> = -
    <VP head type passive> = -
    <VP head type no_intervening> = -   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <PP head object head type> == [modifier-final:+] -> ~[compound:+]  | PPs with modified objects whose final element is marked compound, must compound 16Jul03 CB
     <VP head auxiliaryH> == ~([rootgloss:be.able] &
                              [infl:[tense:[past:+]]])   | no past Aux to change tense Feb2020
    <VP rule> = 6cIDPnonPastNonGenericIndefinite

rule {VP option 6cIDPnonPastNonGenericDefinite - V final, PP initial and ditransitive with DP}
VP = PP DP V
    <VP head> = <V head>
    <VP head infl tense past> = -
    <VP head rootgloss> = <V rootgloss>
    <V head object> = <DP>
    <V head indirectobject> = <PP head object>    | 22Aug2019
    <PP head rootgloss> = to
    <DP head type generic> = -       | 30May19
    <DP head type indefinite> = -
    <V head type ditransitive> = +
    <V head type transitive> = +
    <V head case> = direct       | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <V head type copular> = -
    <V head subject> = <DP head reflexive>  | pass reflexive info
    <V head subject> = <PP head reflexive> | pass reflexive info
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = namely    | 21Nov03  CB
    /<DP head type relcl> = +        | can have comma if relcl 27Jan03 CB
     <DP head type comma> = +
     <DP head type apposition> = -
    }
    <PP head type comma> = -
     <DP head type temporal> = -       |Apr2020
    {<DP head case> = oblique         
    <DP head case_for_position> = oblique    | to know normal case for conjoined DPs
     <DP head type pronoun> = -
    /<DP head case> = oblique          | pronouns different case CB 23May19
    <DP head case_for_position> = oblique    | to know normal case for conjoined DPs
     <DP head type pronoun> = +
     <DP head agr person third> = +  
     <DP head agr person first> = -  
     <DP head agr person second> = -  
    /<DP head case> = objective
    <DP head case_for_position> = objective    | to know normal case for conjoined DPs
     <DP head type pronoun> = +        | pronouns different case CB 23May19
     <DP head agr person first> = +
     <DP head agr person third> = -  
     <DP head agr person second> = -  
    /<DP head case> = objective
    <DP head case_for_position> = objective    | to know normal case for conjoined DPs
     <DP head type pronoun> = +        | pronouns different case CB 23May19
     <DP head agr person second> = +  
     <DP head agr person third> = -  
     <DP head agr person first> = -  
    }
    {<PP head object head case> = objective  
     <PP head object head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type animate> = +
     <PP head object head type pronoun> = -
    /<PP head object head case> = oblique 
     <PP head object head case_for_position> = oblique   | to know normal case for conjoined DPs
     <DP head type animate> = -
     <PP head object head type pronoun> = -
    /<PP head object head case> = oblique          | pronouns different case CB 23May19
     <PP head object head case_for_position> = oblique   | to know normal case for conjoined DPs
     <DP head type animate> = -
     <PP head object head type pronoun> = +
     <PP head object head agr person third> = +  
     <PP head object head agr person first> = -  
     <PP head object head agr person second> = -  
    /<PP head object head case> = objective          | pronouns different case CB 23May19
     <PP head object head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type animate> = +
     <PP head object head type pronoun> = +
     <PP head object head agr person third> = +  
     <PP head object head agr person first> = -  
     <PP head object head agr person second> = -  
    /<PP head object head case> = objective
     <PP head object head case_for_position> = objective   | to know normal case for conjoined DPs
     <PP head object head type pronoun> = +        | pronouns different case CB 23May19
     <PP head object head agr person first> = +
     <PP head object head agr person third> = -  
     <PP head object head agr person second> = -  
    /<PP head object head case> = objective
     <PP head object head case_for_position> = objective   | to know normal case for conjoined DPs
     <PP head object head type pronoun> = +        | pronouns different case CB 23May19
     <PP head object head agr person second> = +  
     <PP head object head agr person third> = -  
     <PP head object head agr person first> = -  
    }
    <PP head type sentential> = -
    <VP head type passive> = -
    <VP head type no_intervening> = -   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <PP head object head type> == [modifier-final:+] -> ~[compound:+]  | PPs with modified objects whose final element is marked compound, must compound 16Jul03 CB
     <VP head auxiliaryH> == ~([rootgloss:be.able] &
                              [infl:[tense:[past:+]]])   | no past Aux to change tense Feb2020
    <VP rule> = 6cIDPnonPastNonGenericDefinite

|*****************
rule {VP option 6cIPP_1past - V final, DP initial and ditransitive with PP and PP_1, past only}
VP = DP PP_1 PP V
    <VP head> = <V head>
   {<VP head infl tense past> = +
   /<V head infl tense past> = -
    <VP head auxiliaryH rootgloss> = be.able  |tense from Aux
   }
    <VP head rootgloss> = <V rootgloss>
    <V head object> = <DP>
    <V head indirectobject> = <PP head object>
    <PP head rootgloss> = to
    <V head type ditransitive> = +
    <V head type transitive> = +
    <V head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <V head type copular> = -
    <V head subject> = <DP head reflexive>  | pass reflexive info
    <V head subject> = <PP_1 head reflexive> | pass reflexive info
    <V head subject> = <PP head reflexive> | pass reflexive info
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = namely   | 21Nov03  CB
    /<DP head type relcl> = +        | can have comma if relcl 27Jan03 CB
     <DP head type comma> = +
     <DP head type apposition> = -
    }
    <PP head type comma> = -
    <PP_1 head type comma> = -
     <DP head type temporal> = -       |Apr2020
    {<DP head case> = direct          | 17Feb03 CB
    <DP head case_for_position> = direct   | to know normal case for conjoined DPs
     <DP head type pronoun> = -
    /<DP head case> = direct
    <DP head case_for_position> = direct   | to know normal case for conjoined DPs
     <DP head type pronoun> = +
     <DP head agr person third> = +
     <DP head agr person first> = -
     <DP head agr person second> = -
    /<DP head case> = objective       | first and second person pronouns get objective case
    <DP head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type pronoun> = +
     <DP head agr person third> = -
     <DP head agr person first> = +
     <DP head agr person second> = -
    /<DP head case> = objective
    <DP head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type pronoun> = +
     <DP head agr person third> = -
     <DP head agr person first> = -
     <DP head agr person second> = +
   }
    <PP head object head case_for_position> = objective   | to know normal case for conjoined DPs 
    <PP head object head case> = objective  | IO always objective case in past
    <PP head type sentential> = -
    <PP_1 head type sentential> = -
    <VP head type passive> = -
    <VP head type no_intervening> = -   | for compounding constraint
    <V head type object_agr_suffix> = +   |CB 28Jun19   must have object agr
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <PP head object head type> == [modifier-final:+] -> ~[compound:+]  | PPs with modified objects whose final element is marked compound, must compound 16Jul03 CB
    <VP rule> = 6cIPP_1past

|split for past then generic and definite
rule {VP option 6cIPP_1nonPastGeneric - V final, DP initial and ditransitive with PP and PP_1}
VP = DP PP_1 PP V
    <VP head> = <V head>
    <VP head rootgloss> = <V rootgloss>
    <VP head infl tense past> = -
    <V head object> = <DP>
    <V head indirectobject> = <PP head object>    | 22Aug2019
    <PP head rootgloss> = to
    <V head type ditransitive> = +
    <V head type transitive> = +
    <V head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <DP head type generic> = +       | 30May19
    <V head type copular> = -
    <V head type passive> = -
    <V head subject> = <DP head reflexive>  | pass reflexive info
    <V head subject> = <PP_1 head reflexive> | pass reflexive info
    <V head subject> = <PP head reflexive> | pass reflexive info
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = namely    | 21Nov03  CB
    /<DP head type relcl> = +        | can have comma if relcl 27Jan03 CB
     <DP head type comma> = +
     <DP head type apposition> = -
    }
    <PP head type comma> = -
    <PP_1 head type comma> = -
     <DP head type temporal> = -       |Apr2020
    {<DP head case> = direct         
    <DP head case_for_position> = direct   | to know normal case for conjoined DPs
     <DP head type pronoun> = -
    /<DP head case> = oblique          | pronouns different case CB 23May19
    <DP head case_for_position> = oblique   | to know normal case for conjoined DPs
     <DP head type pronoun> = +
     <DP head agr person third> = +  
     <DP head agr person first> = -  
     <DP head agr person second> = -  
    /<DP head case> = objective
    <DP head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type pronoun> = +        | pronouns different case CB 23May19
     <DP head agr person first> = +
     <DP head agr person third> = -  
     <DP head agr person second> = -  
    /<DP head case> = objective
    <DP head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type pronoun> = +        | pronouns different case CB 23May19
     <DP head agr person second> = +  
     <DP head agr person third> = -  
     <DP head agr person first> = -  
    }
    {<PP head object head case> = objective
     <PP head object head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type animate> = +
     <PP head object head type pronoun> = -
    /<PP head object head case> = oblique  
     <PP head object head case_for_position> = oblique   | to know normal case for conjoined DPs
     <DP head type animate> = -
     <PP head object head type pronoun> = -
    /<PP head object head case> = oblique          | pronouns different case CB 23May19
     <PP head object head case_for_position> = oblique   | to know normal case for conjoined DPs
     <DP head type animate> = -
     <PP head object head type pronoun> = +
     <PP head object head agr person third> = +  
     <PP head object head agr person first> = -  
     <PP head object head agr person second> = -  
    /<PP head object head case> = objective          | pronouns different case CB 23May19
     <PP head object head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type animate> = +
     <PP head object head type pronoun> = +
     <PP head object head agr person third> = +  
     <PP head object head agr person first> = -  
     <PP head object head agr person second> = -  
    /<PP head object head case> = objective
     <PP head object head case_for_position> = objective   | to know normal case for conjoined DPs
     <PP head object head type pronoun> = +        | pronouns different case CB 23May19
     <PP head object head agr person first> = +
     <PP head object head agr person third> = -  
     <PP head object head agr person second> = -  
    /<PP head object head case> = objective
     <PP head object head case_for_position> = objective   | to know normal case for conjoined DPs
     <PP head object head type pronoun> = +        | pronouns different case CB 23May19
     <PP head object head agr person second> = +  
     <PP head object head agr person third> = -  
     <PP head object head agr person first> = -  
    }
    <PP head type sentential> = -
    <PP_1 head type sentential> = -
    <VP head type passive> = -
    <VP head type no_intervening> = -   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <PP head object head type> == [modifier-final:+] -> ~[compound:+]  | PPs with modified objects whose final element is marked compound, must compound 16Jul03 CB
     <VP head auxiliaryH> == ~([rootgloss:be.able] &
                              [infl:[tense:[past:+]]])   | no past Aux to change tense Feb2020
    <VP rule> = 6cIPP_1nonPastGeneric

rule {VP option 6cIPP_1nonPastNonGenericIndefinite - V final, DP initial and ditransitive with PP and PP_1}
VP = DP PP_1 PP V
    <VP head> = <V head>
    <VP head rootgloss> = <V rootgloss>
    <VP head infl tense past> = -
    <V head object> = <DP>
    <V head indirectobject> = <PP head object>    | 22Aug2019
    <PP head rootgloss> = to
    <DP head type generic> = -       | 30May19
    <DP head type indefinite> = +
    <V head type ditransitive> = +
    <V head type transitive> = +
    <V head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <V head type copular> = -
    <V head subject> = <DP head reflexive>  | pass reflexive info
    <V head subject> = <PP_1 head reflexive> | pass reflexive info
    <V head subject> = <PP head reflexive> | pass reflexive info
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = namely    | 21Nov03  CB
    /<DP head type relcl> = +        | can have comma if relcl 27Jan03 CB
     <DP head type comma> = +
     <DP head type apposition> = -
    }
    <PP head type comma> = -
    <PP_1 head type comma> = -
     <DP head type temporal> = -       |Apr2020
    {<DP head case> = direct         
    <DP head case_for_position> = direct   | to know normal case for conjoined DPs
     <DP head type pronoun> = -
    /<DP head case> = oblique          | pronouns different case CB 23May19
    <DP head case_for_position> = oblique   | to know normal case for conjoined DPs
     <DP head type pronoun> = +
     <DP head agr person third> = +  
     <DP head agr person first> = -  
     <DP head agr person second> = -  
    /<DP head case> = objective
    <DP head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type pronoun> = +        | pronouns different case CB 23May19
     <DP head agr person first> = +
     <DP head agr person third> = -  
     <DP head agr person second> = -  
    /<DP head case> = objective
    <DP head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type pronoun> = +        | pronouns different case CB 23May19
     <DP head agr person second> = +  
     <DP head agr person third> = -  
     <DP head agr person first> = -  
    }
    {<PP head object head case> = objective  
     <PP head object head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type animate> = +
     <PP head object head type pronoun> = -
    /<PP head object head case> = oblique  
     <PP head object head case_for_position> = oblique   | to know normal case for conjoined DPs
     <DP head type animate> = -
     <PP head object head type pronoun> = -
    /<PP head object head case> = oblique          | pronouns different case CB 23May19
     <PP head object head case_for_position> = oblique   | to know normal case for conjoined DPs
     <DP head type animate> = -
     <PP head object head type pronoun> = +
     <PP head object head agr person third> = +  
     <PP head object head agr person first> = -  
     <PP head object head agr person second> = -  
    /<PP head object head case> = objective          | pronouns different case CB 23May19
     <PP head object head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type animate> = +
     <PP head object head type pronoun> = +
     <PP head object head agr person third> = +  
     <PP head object head agr person first> = -  
     <PP head object head agr person second> = -  
    /<PP head object head case> = objective
     <PP head object head case_for_position> = objective   | to know normal case for conjoined DPs
     <PP head object head type pronoun> = +        | pronouns different case CB 23May19
     <PP head object head agr person first> = +
     <PP head object head agr person third> = -  
     <PP head object head agr person second> = -  
    /<PP head object head case> = objective
     <PP head object head case_for_position> = objective   | to know normal case for conjoined DPs
     <PP head object head type pronoun> = +        | pronouns different case CB 23May19
     <PP head object head agr person second> = +  
     <PP head object head agr person third> = -  
     <PP head object head agr person first> = -  
    }
    <PP head type sentential> = -
    <PP_1 head type sentential> = -
    <VP head type passive> = -
    <VP head type no_intervening> = -   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <PP head object head type> == [modifier-final:+] -> ~[compound:+]  | PPs with modified objects whose final element is marked compound, must compound 16Jul03 CB
     <VP head auxiliaryH> == ~([rootgloss:be.able] &
                              [infl:[tense:[past:+]]])   | no past Aux to change tense Feb2020
    <VP rule> = 6cIPP_1nonPastNonGenericIndefinite

rule {VP option 6cIPP_1nonPastNonGenericDefinite - V final, DP initial and ditransitive with PP and PP_1}
VP = DP PP_1 PP V
    <VP head> = <V head>
    <VP head rootgloss> = <V rootgloss>
    <VP head infl tense past> = -
    <V head object> = <DP>
    <V head indirectobject> = <PP head object>    | 22Aug2019
    <PP head rootgloss> = to
    <DP head type generic> = -
    <DP head type indefinite> = -
    <V head type ditransitive> = +
    <V head type transitive> = +
    <V head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <V head type copular> = -
    <V head subject> = <DP head reflexive>  | pass reflexive info
    <V head subject> = <PP_1 head reflexive> | pass reflexive info
    <V head subject> = <PP head reflexive> | pass reflexive info
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = namely    | 21Nov03  CB
    /<DP head type relcl> = +        | can have comma if relcl 27Jan03 CB
     <DP head type comma> = +
     <DP head type apposition> = -
    }
    <PP head type comma> = -
    <PP_1 head type comma> = -
     <DP head type temporal> = -       |Apr2020
    {<DP head case> = oblique         
    <DP head case_for_position> = oblique    | to know normal case for conjoined DPs
     <DP head type pronoun> = -
    /<DP head case> = oblique          | pronouns different case CB 23May19
    <DP head case_for_position> = oblique    | to know normal case for conjoined DPs
     <DP head type pronoun> = +
     <DP head agr person third> = +  
     <DP head agr person first> = -  
     <DP head agr person second> = -  
    /<DP head case> = objective
    <DP head case_for_position> = objective    | to know normal case for conjoined DPs
     <DP head type pronoun> = +        | pronouns different case CB 23May19
     <DP head agr person first> = +
     <DP head agr person third> = -  
     <DP head agr person second> = -  
    /<DP head case> = objective
    <DP head case_for_position> = objective    | to know normal case for conjoined DPs
     <DP head type pronoun> = +        | pronouns different case CB 23May19
     <DP head agr person second> = +  
     <DP head agr person third> = -  
     <DP head agr person first> = -  
    }
    {<PP head object head case> = objective        
     <PP head object head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type animate> = +
     <PP head object head type pronoun> = -
    /<PP head object head case> = oblique  
     <PP head object head case_for_position> = oblique   | to know normal case for conjoined DPs
     <DP head type animate> = -
     <PP head object head type pronoun> = -
    /<PP head object head case> = oblique          | pronouns different case CB 23May19
     <PP head object head case_for_position> = oblique   | to know normal case for conjoined DPs
     <DP head type animate> = -
     <PP head object head type pronoun> = +
     <PP head object head agr person third> = +  
     <PP head object head agr person first> = -  
     <PP head object head agr person second> = -  
    /<PP head object head case> = objective          | pronouns different case CB 23May19
     <PP head object head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type animate> = +
     <PP head object head type pronoun> = +
     <PP head object head agr person third> = +  
     <PP head object head agr person first> = -  
     <PP head object head agr person second> = -  
    /<PP head object head case> = objective
     <PP head object head case_for_position> = objective   | to know normal case for conjoined DPs
     <PP head object head type pronoun> = +        | pronouns different case CB 23May19
     <PP head object head agr person first> = +
     <PP head object head agr person third> = -  
     <PP head object head agr person second> = -  
    /<PP head object head case> = objective
     <PP head object head case_for_position> = objective   | to know normal case for conjoined DPs
     <PP head object head type pronoun> = +        | pronouns different case CB 23May19
     <PP head object head agr person second> = +  
     <PP head object head agr person third> = -  
     <PP head object head agr person first> = -  
    }
    <PP head type sentential> = -
    <PP_1 head type sentential> = -
    <VP head type passive> = -
    <VP head type no_intervening> = -   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <PP head object head type> == [modifier-final:+] -> ~[compound:+]  | PPs with modified objects whose final element is marked compound, must compound 16Jul03 CB
     <VP head auxiliaryH> == ~([rootgloss:be.able] &
                              [infl:[tense:[past:+]]])   | no past Aux to change tense Feb2020
    <VP rule> = 6cIPP_1nonPastNonGenericDefinite

|*************
rule {VP option 6cIPP_2past - V final, DP initial and ditransitive with PP & PP_1 & PP_2, past only}
VP = DP PP_1 PP_2 PP V
    <VP head> = <V head>
   {<VP head infl tense past> = +
   /<V head infl tense past> = -
    <VP head auxiliaryH rootgloss> = be.able  |tense from Aux
   }
    <VP head rootgloss> = <V rootgloss>
    <V head object> = <DP>
    <V head indirectobject> = <PP head object>
    <PP head rootgloss> = to
    <V head type ditransitive> = +
    <V head type transitive> = +
    <V head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <V head type copular> = -
    <V head subject> = <DP head reflexive>  | pass reflexive info
    <V head subject> = <PP head reflexive> | pass reflexive info
    <V head subject> = <PP_1 head reflexive> | pass reflexive info
    <V head subject> = <PP_2 head reflexive> | pass reflexive info
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = namely    | 21Nov03  CB
    /<DP head type relcl> = +        | can have comma if relcl 27Jan03 CB
     <DP head type comma> = +
     <DP head type apposition> = -
    }
    <PP head type comma> = -
    <PP_1 head type comma> = -
    <PP_2 head type comma> = -
     <DP head type temporal> = -       |Apr2020
    {<DP head case> = direct          | 17Feb03 CB
    <DP head case_for_position> = direct   | to know normal case for conjoined DPs
     <DP head type pronoun> = -
    /<DP head case> = direct
    <DP head case_for_position> = direct   | to know normal case for conjoined DPs
     <DP head type pronoun> = +
     <DP head agr person third> = +
     <DP head agr person first> = -
     <DP head agr person second> = -
    /<DP head case> = objective       | first and second person pronouns get objective case
    <DP head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type pronoun> = +
     <DP head agr person third> = -
     <DP head agr person first> = +
     <DP head agr person second> = -
    /<DP head case> = objective
    <DP head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type pronoun> = +
     <DP head agr person third> = -
     <DP head agr person first> = -
     <DP head agr person second> = +
   }
    <PP head object head case_for_position> = objective   | to know normal case for conjoined DPs 
    <PP head object head case> = objective  | IO always objective case in past
    <PP head type sentential> = -
    <PP_1 head type sentential> = -
    <PP_2 head type sentential> = -
    <VP head type passive> = -
    <VP head type no_intervening> = -   | for compounding constraint
    <V head type object_agr_suffix> = +   |CB 28Jun19   must have object agr
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <PP head object head type> == [modifier-final:+] -> ~[compound:+]  | PPs with modified objects whose final element is marked compound, must compound 16Jul03 CB
    <VP rule> = 6cIPP_2past

|split for past then generic and definite
rule {VP option 6cIPP_2nonPastGeneric - V final, DP initial and ditransitive with PP & PP_1 & PP_2}
VP = DP PP_1 PP_2 PP V
    <VP head> = <V head>
    <VP head infl tense past> = -
    <VP head rootgloss> = <V rootgloss>
    <VP head infl tense past> = -
    <V head object> = <DP>
    <V head indirectobject> = <PP head object>    | 22Aug2019
    <PP head rootgloss> = to
    <V head type ditransitive> = +
    <V head type transitive> = +
    <V head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <DP head type generic> = +       | 30May19
    <V head type copular> = -
    <V head subject> = <DP head reflexive>  | pass reflexive info
    <V head subject> = <PP head reflexive> | pass reflexive info
    <V head subject> = <PP_1 head reflexive> | pass reflexive info
    <V head subject> = <PP_2 head reflexive> | pass reflexive info
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = namely    | 21Nov03  CB
    /<DP head type relcl> = +        | can have comma if relcl 27Jan03 CB
     <DP head type comma> = +
     <DP head type apposition> = -
    }
    <PP head type comma> = -
    <PP_1 head type comma> = -
    <PP_2 head type comma> = -
     <DP head type temporal> = -       |Apr2020
    {<DP head case> = direct         
    <DP head case_for_position> = direct   | to know normal case for conjoined DPs
     <DP head type pronoun> = -
    /<DP head case> = oblique          | pronouns different case CB 23May19
    <DP head case_for_position> = oblique   | to know normal case for conjoined DPs
     <DP head type pronoun> = +
     <DP head agr person third> = +  
     <DP head agr person first> = -  
     <DP head agr person second> = -  
    /<DP head case> = objective
    <DP head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type pronoun> = +        | pronouns different case CB 23May19
     <DP head agr person first> = +
     <DP head agr person third> = -  
     <DP head agr person second> = -  
    /<DP head case> = objective
    <DP head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type pronoun> = +        | pronouns different case CB 23May19
     <DP head agr person second> = +  
     <DP head agr person third> = -  
     <DP head agr person first> = -  
    }
    {<PP head object head case> = objective
     <PP head object head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type animate> = +
     <PP head object head type pronoun> = -
    /<PP head object head case> = oblique  
     <PP head object head case_for_position> = oblique   | to know normal case for conjoined DPs
     <DP head type animate> = -
     <PP head object head type pronoun> = -
    /<PP head object head case> = oblique          | pronouns different case CB 23May19
     <PP head object head case_for_position> = oblique   | to know normal case for conjoined DPs
     <DP head type animate> = -
     <PP head object head type pronoun> = +
     <PP head object head agr person third> = +  
     <PP head object head agr person first> = -  
     <PP head object head agr person second> = -  
    /<PP head object head case> = objective          | pronouns different case CB 23May19
     <PP head object head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type animate> = +
     <PP head object head type pronoun> = +
     <PP head object head agr person third> = +  
     <PP head object head agr person first> = -  
     <PP head object head agr person second> = -  
    /<PP head object head case> = objective
     <PP head object head case_for_position> = objective   | to know normal case for conjoined DPs
     <PP head object head type pronoun> = +        | pronouns different case CB 23May19
     <PP head object head agr person first> = +
     <PP head object head agr person third> = -  
     <PP head object head agr person second> = -  
    /<PP head object head case> = objective
     <PP head object head case_for_position> = objective   | to know normal case for conjoined DPs
     <PP head object head type pronoun> = +        | pronouns different case CB 23May19
     <PP head object head agr person second> = +  
     <PP head object head agr person third> = -  
     <PP head object head agr person first> = -  
     }
    <PP head type sentential> = -
    <PP_1 head type sentential> = -
    <PP_2 head type sentential> = -
    <VP head type passive> = -
    <VP head type no_intervening> = -   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <PP head object head type> == [modifier-final:+] -> ~[compound:+]  | PPs with modified objects whose final element is marked compound, must compound 16Jul03 CB
     <VP head auxiliaryH> == ~([rootgloss:be.able] &
                              [infl:[tense:[past:+]]])   | no past Aux to change tense Feb2020
    <VP rule> = 6cIPP_2nonPastGeneric

rule {VP option 6cIPP_2nonPastNonGenericIndefinite - V final, DP initial and ditransitive with PP & PP_1 & PP_2}
VP = DP PP_1 PP_2 PP V
    <VP head> = <V head>
    <VP head infl tense past> = -
    <VP head rootgloss> = <V rootgloss>
    <V head object> = <DP>
    <V head indirectobject> = <PP head object>    | 22Aug2019
    <PP head rootgloss> = to
    <DP head type generic> = -       | 30May19
    <DP head type indefinite> = +
    <V head type ditransitive> = +
    <V head type transitive> = +
    <V head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <V head type copular> = -
    <V head subject> = <DP head reflexive>  | pass reflexive info
    <V head subject> = <PP head reflexive> | pass reflexive info
    <V head subject> = <PP_1 head reflexive> | pass reflexive info
    <V head subject> = <PP_2 head reflexive> | pass reflexive info
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = namely    | 21Nov03  CB
    /<DP head type relcl> = +        | can have comma if relcl 27Jan03 CB
     <DP head type comma> = +
     <DP head type apposition> = -
    }
    <PP head type comma> = -
    <PP_1 head type comma> = -
    <PP_2 head type comma> = -
     <DP head type temporal> = -       |Apr2020
    {<DP head case> = direct         
    <DP head case_for_position> = direct   | to know normal case for conjoined DPs
     <DP head type pronoun> = -
    /<DP head case> = oblique          | pronouns different case CB 23May19
    <DP head case_for_position> = oblique   | to know normal case for conjoined DPs
     <DP head type pronoun> = +
     <DP head agr person third> = +  
     <DP head agr person first> = -  
     <DP head agr person second> = -  
    /<DP head case> = objective
    <DP head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type pronoun> = +        | pronouns different case CB 23May19
     <DP head agr person first> = +
     <DP head agr person third> = -  
     <DP head agr person second> = -  
    /<DP head case> = objective
    <DP head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type pronoun> = +        | pronouns different case CB 23May19
     <DP head agr person second> = +  
     <DP head agr person third> = -  
     <DP head agr person first> = -  
    }
    {<PP head object head case> = objective  
     <PP head object head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type animate> = +
     <PP head object head type pronoun> = -
    /<PP head object head case> = oblique  
     <PP head object head case_for_position> = oblique   | to know normal case for conjoined DPs
     <DP head type animate> = -
     <PP head object head type pronoun> = -
    /<PP head object head case> = oblique          | pronouns different case CB 23May19
     <PP head object head case_for_position> = oblique   | to know normal case for conjoined DPs
     <DP head type animate> = -
     <PP head object head type pronoun> = +
     <PP head object head agr person third> = +  
     <PP head object head agr person first> = -  
     <PP head object head agr person second> = -  
    /<PP head object head case> = objective          | pronouns different case CB 23May19
     <PP head object head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type animate> = +
     <PP head object head type pronoun> = +
     <PP head object head agr person third> = +  
     <PP head object head agr person first> = -  
     <PP head object head agr person second> = -  
    /<PP head object head case> = objective
     <PP head object head case_for_position> = objective   | to know normal case for conjoined DPs
     <PP head object head type pronoun> = +        | pronouns different case CB 23May19
     <PP head object head agr person first> = +
     <PP head object head agr person third> = -  
     <PP head object head agr person second> = -  
    /<PP head object head case> = objective
     <PP head object head case_for_position> = objective   | to know normal case for conjoined DPs
     <PP head object head type pronoun> = +        | pronouns different case CB 23May19
     <PP head object head agr person second> = +  
     <PP head object head agr person third> = -  
     <PP head object head agr person first> = -  
    }
    <PP head type sentential> = -
    <PP_1 head type sentential> = -
    <PP_2 head type sentential> = -
    <VP head type passive> = -
    <VP head type no_intervening> = -   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <PP head object head type> == [modifier-final:+] -> ~[compound:+]  | PPs with modified objects whose final element is marked compound, must compound 16Jul03 CB
     <VP head auxiliaryH> == ~([rootgloss:be.able] &
                              [infl:[tense:[past:+]]])   | no past Aux to change tense Feb2020
    <VP rule> = 6cIPP_2nonPastNonGenericIndefinite

rule {VP option 6cIPP_2nonPastNonGenericDefinite - V final, DP initial and ditransitive with PP & PP_1 & PP_2}
VP = DP PP_1 PP_2 PP V
    <VP head> = <V head>
    <VP head infl tense past> = -
    <VP head rootgloss> = <V rootgloss>
    <V head object> = <DP>
    <V head indirectobject> = <PP head object>    | 22Aug2019
    <PP head rootgloss> = to
    <DP head type generic> = -
    <DP head type indefinite> = -
    <V head type ditransitive> = +
    <V head type transitive> = +
    <V head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <V head type copular> = -
    <V head subject> = <DP head reflexive>  | pass reflexive info
    <V head subject> = <PP head reflexive> | pass reflexive info
    <V head subject> = <PP_1 head reflexive> | pass reflexive info
    <V head subject> = <PP_2 head reflexive> | pass reflexive info
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = namely    | 21Nov03  CB
    /<DP head type relcl> = +        | can have comma if relcl 27Jan03 CB
     <DP head type comma> = +
     <DP head type apposition> = -
    }
    <PP head type comma> = -
    <PP_1 head type comma> = -
    <PP_2 head type comma> = -
     <DP head type temporal> = -       |Apr2020
    {<DP head case> = oblique         
    <DP head case_for_position> = oblique    | to know normal case for conjoined DPs
     <DP head type pronoun> = -
    /<DP head case> = oblique          | pronouns different case CB 23May19
    <DP head case_for_position> = oblique    | to know normal case for conjoined DPs
     <DP head type pronoun> = +
     <DP head agr person third> = +  
     <DP head agr person first> = -  
     <DP head agr person second> = -  
    /<DP head case> = objective
    <DP head case_for_position> = objective    | to know normal case for conjoined DPs
     <DP head type pronoun> = +        | pronouns different case CB 23May19
     <DP head agr person first> = +
     <DP head agr person third> = -  
     <DP head agr person second> = -  
    /<DP head case> = objective
    <DP head case_for_position> = objective    | to know normal case for conjoined DPs
     <DP head type pronoun> = +        | pronouns different case CB 23May19
     <DP head agr person second> = +  
     <DP head agr person third> = -  
     <DP head agr person first> = -  
    }
    {<PP head object head case> = objective        
     <PP head object head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type animate> = +
     <PP head object head type pronoun> = -
    /<PP head object head case> = oblique  
     <PP head object head case_for_position> = oblique   | to know normal case for conjoined DPs
     <DP head type animate> = -
     <PP head object head type pronoun> = -
    /<PP head object head case> = oblique          | pronouns different case CB 23May19
     <PP head object head case_for_position> = oblique   | to know normal case for conjoined DPs
     <DP head type animate> = -
     <PP head object head type pronoun> = +
     <PP head object head agr person third> = +  
     <PP head object head agr person first> = -  
     <PP head object head agr person second> = -  
    /<PP head object head case> = objective          | pronouns different case CB 23May19
     <PP head object head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type animate> = +
     <PP head object head type pronoun> = +
     <PP head object head agr person third> = +  
     <PP head object head agr person first> = -  
     <PP head object head agr person second> = -  
    /<PP head object head case> = objective
     <PP head object head case_for_position> = objective   | to know normal case for conjoined DPs
     <PP head object head type pronoun> = +        | pronouns different case CB 23May19
     <PP head object head agr person first> = +
     <PP head object head agr person third> = -  
     <PP head object head agr person second> = -  
    /<PP head object head case> = objective
     <PP head object head case_for_position> = objective   | to know normal case for conjoined DPs
     <PP head object head type pronoun> = +        | pronouns different case CB 23May19
     <PP head object head agr person second> = +  
     <PP head object head agr person third> = -  
     <PP head object head agr person first> = -  
    }
    <PP head type sentential> = -
    <PP_1 head type sentential> = -
    <PP_2 head type sentential> = -
    <VP head type passive> = -
    <VP head type no_intervening> = -   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <PP head object head type> == [modifier-final:+] -> ~[compound:+]  | PPs with modified objects whose final element is marked compound, must compound 16Jul03 CB
     <VP head auxiliaryH> == ~([rootgloss:be.able] &
                              [infl:[tense:[past:+]]])   | no past Aux to change tense Feb2020
    <VP rule> = 6cIPP_2nonPastNonGenericDefinite

|rule added 31May19 for pn (1st/2nd) Object Case #3 ****assume pronoun IO only* split 28Jun2019***
rule {VP option 6cIIDPpast - V final, pronoun DP_1 IO (not NPrep) and DP object}
VP = DP_1 DP V
    <VP head> = <V head>
   {<VP head infl tense past> = +
   /<V head infl tense past> = -
    <VP head auxiliaryH rootgloss> = be.able  |tense from Aux
   }
    <VP head rootgloss> = <V rootgloss>
    <V head object> = <DP>
    <V head indirectobject> = <DP_1>
    <V head type ditransitive> = +
    <V head type transitive> = +
    <V head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <V head type copular> = -
    <V head subject> = <DP head reflexive>  | pass reflexive info
    <V head subject> = <DP_1 head reflexive> | pass reflexive info
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = namely    | 21Nov03  CB
    /<DP head type relcl> = +        | can have comma if relcl 27Jan03 CB
     <DP head type comma> = +
     <DP head type apposition> = -
    }
     <DP head type temporal> = -       |Apr2020
    {<DP head case> = direct          | 17Feb03 CB
    <DP head case_for_position> = direct   | to know normal case for conjoined DPs
     <DP head type pronoun> = -
    /<DP head case> = direct
    <DP head case_for_position> = direct   | to know normal case for conjoined DPs
     <DP head type pronoun> = +
     <DP head agr person third> = +
     <DP head agr person first> = -
     <DP head agr person second> = -
    /<DP head case> = objective       | first and second person pronouns get objective case
    <DP head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type pronoun> = +
     <DP head agr person third> = -
     <DP head agr person first> = +
     <DP head agr person second> = -
    /<DP head case> = objective
    <DP head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type pronoun> = +
     <DP head agr person third> = -
     <DP head agr person first> = -
     <DP head agr person second> = +
   }
    <DP_1 head type comma> = -
    <DP_1 head type pronoun> = +
    <DP_1 head type apposition> = -
    <DP_1 head type case-marked> = -
    <DP_1 head type DO_contraction> = -
    <DP_1 head case> = objective
    <DP_1 head type genitive_suffix> = -
    <DP_1 head type locative> = -
    <VP head type passive> = -
    <VP head type no_intervening> = -   | for compounding constraint
    <V head type object_agr_suffix> = +   |CB 28Jun19   must have object agr
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type> == [modifier-final:+] -> ~[compound:+]  | modified DPs whose final element is marked compound, must compound 16Jul03 CB
    <VP head> == [rootgloss:^1] -> 
                  ~(([object:[head:[type:[modifier-final:-]]]] 
                    &[object:[head:[type:[case-marked:-]]]] ) &
                   (( [object:[head:[type:[compounds_with1:^1]]]]
                    / [object:[head:[type:[compounds_with2:^1]]]])
                    / ([object:[head:[type:[compounds_with3:^1]]]]
                    / [object:[head:[type:[compounds_with4:^1]]]]) ) ) |21Jul03
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP_1 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <VP head> == [subject:[head:[agr:[person:[first:+]]]]] -> ~[indirectobject:[head:[agr:[person:[first:+]]]]]  |22Jan2020 for Pn3Obl1  
    <VP head> == [subject:[head:[agr:[person:[second:+]]]]] -> ~[indirectobject:[head:[agr:[person:[second:+]]]]]
    <VP rule> = 6cIIDPpast

|split for past then generic and definite
rule {VP option 6cIIDPnonPastGeneric - V final, pronoun DP_1 IO (not NPrep) and DP object}
VP = DP_1 DP V
    <VP head> = <V head>
    <VP head infl tense past> = -
    <VP head rootgloss> = <V rootgloss>
    <V head object> = <DP>
    <v head indirectobject> = <DP_1>
    <DP head type generic> = +       | 30May19
    <V head indirectobject> = <DP_1>
    <V head type ditransitive> = +
    <V head type transitive> = +
    <V head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <V head type copular> = -
    <V head subject> = <DP head reflexive>  | pass reflexive info
    <V head subject> = <DP_1 head reflexive> | pass reflexive info
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = namely    | 21Nov03  CB
    /<DP head type relcl> = +        | can have comma if relcl 27Jan03 CB
     <DP head type comma> = +
     <DP head type apposition> = -
    }
     <DP head type temporal> = -       |Apr2020
    {<DP head case> = direct         
   <DP head case_for_position> = direct   | to know normal case for conjoined DPs
     <DP head type pronoun> = -
    /<DP head case> = oblique          | pronouns different case CB 23May19
   <DP head case_for_position> = oblique   | to know normal case for conjoined DPs
     <DP head type pronoun> = +
     <DP head agr person third> = +  
     <DP head agr person first> = -  
     <DP head agr person second> = -  
    /<DP head case> = objective
   <DP head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type pronoun> = +        | pronouns different case CB 23May19
     <DP head agr person first> = +
     <DP head agr person third> = -  
     <DP head agr person second> = -  
    /<DP head case> = objective
   <DP head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type pronoun> = +        | pronouns different case CB 23May19
     <DP head agr person second> = +  
     <DP head agr person third> = -  
     <DP head agr person first> = -  
    }
     <DP_1 head type comma> = -
     <DP_1 head type pronoun> = +
    {<DP_1 head case> = objective
     <DP_1 head agr person first> = +
     <DP_1 head agr person third> = -  
     <DP_1 head agr person second> = -  
    /<DP_1 head case> = objective
     <DP_1 head agr person second> = +  
     <DP_1 head agr person third> = -  
     <DP_1 head agr person first> = -  
    /<DP_1 head case> = oblique          | pronouns different case CB 23May19
     <DP head type animate> = -
     <DP_1 head agr person third> = +  
     <DP_1 head agr person first> = -  
     <DP_1 head agr person second> = -  
    /<DP_1 head case> = objective          | pronouns different case CB 23May19
     <DP head type animate> = +
     <DP_1 head agr person third> = +  
     <DP_1 head agr person first> = -  
     <DP_1 head agr person second> = -  
    }
    <DP_1 head type apposition> = -
    <DP_1 head type case-marked> = -
    <DP_1 head type DO_contraction> = -
    <DP_1 head type genitive_suffix> = -
    <DP_1 head type locative> = -
    <VP head type passive> = -
    <VP head type no_intervening> = -   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type> == [modifier-final:+] -> ~[compound:+]  | modified DPs whose final element is marked compound, must compound 16Jul03 CB
    <VP head> == [rootgloss:^1] -> 
                  ~(([object:[head:[type:[modifier-final:-]]]] 
                    &[object:[head:[type:[case-marked:-]]]] ) &
                   (( [object:[head:[type:[compounds_with1:^1]]]]
                    / [object:[head:[type:[compounds_with2:^1]]]])
                    / ([object:[head:[type:[compounds_with3:^1]]]]
                    / [object:[head:[type:[compounds_with4:^1]]]]) ) ) |21Jul03
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP_1 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <VP head> == [subject:[head:[agr:[person:[first:+]]]]] -> ~[indirectobject:[head:[agr:[person:[first:+]]]]]  |22Jan2020 for Pn3Obl1  
    <VP head> == [subject:[head:[agr:[person:[second:+]]]]] -> ~[indirectobject:[head:[agr:[person:[second:+]]]]]
     <VP head auxiliaryH> == ~([rootgloss:be.able] &
                              [infl:[tense:[past:+]]])   | no past Aux to change tense Feb2020
    <VP rule> = 6cIIDPnonPastGeneric

rule {VP option 6cIIDPnonPastNonGenericIndefinite - V final, pronoun DP_1 IO (not NPrep) and DP object}
VP = DP_1 DP V
    <VP head> = <V head>
    <VP head infl tense past> = -
    <VP head rootgloss> = <V rootgloss>
    <V head object> = <DP>
    <V head indirectobject> = <DP_1>
    <DP head type generic> = -       | 30May19
    <DP head type indefinite> = +
    <V head type ditransitive> = +
    <V head type transitive> = +
    <V head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <V head type copular> = -
    <V head subject> = <DP head reflexive>  | pass reflexive info
    <V head subject> = <DP_1 head reflexive> | pass reflexive info
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = namely    | 21Nov03  CB
    /<DP head type relcl> = +        | can have comma if relcl 27Jan03 CB
     <DP head type comma> = +
     <DP head type apposition> = -
    }
     <DP head type temporal> = -       |Apr2020
    {<DP head case> = direct         
    <DP head case_for_position> = direct   | to know normal case for conjoined DPs
     <DP head type pronoun> = -
    /<DP head case> = oblique          | pronouns different case CB 23May19
    <DP head case_for_position> = oblique   | to know normal case for conjoined DPs
     <DP head type pronoun> = +
     <DP head agr person third> = +  
     <DP head agr person first> = -  
     <DP head agr person second> = -  
    /<DP head case> = objective
    <DP head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type pronoun> = +        | pronouns different case CB 23May19
     <DP head agr person first> = +
     <DP head agr person third> = -  
     <DP head agr person second> = -  
    /<DP head case> = objective
    <DP head case_for_position> = objective   | to know normal case for conjoined DPs
     <DP head type pronoun> = +        | pronouns different case CB 23May19
     <DP head agr person second> = +  
     <DP head agr person third> = -  
     <DP head agr person first> = -  
    }
     <DP_1 head type comma> = -
     <DP_1 head type pronoun> = +
    {<DP_1 head case> = objective
     <DP_1 head agr person first> = +
     <DP_1 head agr person third> = -  
     <DP_1 head agr person second> = -  
    /<DP_1 head case> = objective
     <DP_1 head agr person second> = +  
     <DP_1 head agr person third> = -  
     <DP_1 head agr person first> = -  
    /<DP_1 head case> = oblique          | pronouns different case CB 23May19
     <DP head type animate> = -
     <DP_1 head agr person third> = +  
     <DP_1 head agr person first> = -  
     <DP_1 head agr person second> = -  
    /<DP_1 head case> = objective          | pronouns different case CB 23May19
     <DP head type animate> = +
     <DP_1 head agr person third> = +  
     <DP_1 head agr person first> = -  
     <DP_1 head agr person second> = -  
    }
    <DP_1 head type apposition> = -
    <DP_1 head type case-marked> = -
    <DP_1 head type DO_contraction> = -
    <DP_1 head type genitive_suffix> = -
    <DP_1 head type locative> = -
    <VP head type passive> = -
    <VP head type no_intervening> = -   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type> == [modifier-final:+] -> ~[compound:+]  | modified DPs whose final element is marked compound, must compound 16Jul03 CB
    <VP head> == [rootgloss:^1] -> 
                  ~(([object:[head:[type:[modifier-final:-]]]] 
                    &[object:[head:[type:[case-marked:-]]]] ) &
                   (( [object:[head:[type:[compounds_with1:^1]]]]
                    / [object:[head:[type:[compounds_with2:^1]]]])
                    / ([object:[head:[type:[compounds_with3:^1]]]]
                    / [object:[head:[type:[compounds_with4:^1]]]]) ) ) |21Jul03
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP_1 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <VP head> == [subject:[head:[agr:[person:[first:+]]]]] -> ~[indirectobject:[head:[agr:[person:[first:+]]]]]  |22Jan2020 for Pn3Obl1  
    <VP head> == [subject:[head:[agr:[person:[second:+]]]]] -> ~[indirectobject:[head:[agr:[person:[second:+]]]]]
     <VP head auxiliaryH> == ~([rootgloss:be.able] &
                              [infl:[tense:[past:+]]])   | no past Aux to change tense Feb2020
    <VP rule> = 6cIIDPnonPastNonGenericIndefinite

rule {VP option 6cIIDPnonPastNonGenericDefinite - V final, pronoun DP_1 IO (not NPrep) and DP object}
VP = DP_1 DP V
    <VP head> = <V head>
    <VP head infl tense past> = -
    <VP head rootgloss> = <V rootgloss>
    <V head object> = <DP>
    <V head indirectobject> = <DP_1>
    <DP head type generic> = -       | 30May19
    <DP head type indefinite> = -
    <V head indirectobject> = <DP_1>
    <V head type ditransitive> = +
    <V head type transitive> = +
    <V head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <V head type copular> = -
    <V head subject> = <DP head reflexive>  | pass reflexive info
    <V head subject> = <DP_1 head reflexive> | pass reflexive info
    {<DP head type comma> = -
     <DP head type apposition> = -
    /<DP head type apposition> = +    | 17Jan03  CB
    /<DP head type apposition> = namely    | 21Nov03  CB
    /<DP head type relcl> = +        | can have comma if relcl 27Jan03 CB
     <DP head type comma> = +
     <DP head type apposition> = -
    }
     <DP head type temporal> = -       |Apr2020
    {<DP head case> = oblique         
    <DP head case_for_position> = oblique    | to know normal case for conjoined DPs
     <DP head type pronoun> = -
    /<DP head case> = oblique          | pronouns different case CB 23May19
    <DP head case_for_position> = oblique    | to know normal case for conjoined DPs
     <DP head type pronoun> = +
     <DP head agr person third> = +  
     <DP head agr person first> = -  
     <DP head agr person second> = -  
    /<DP head case> = objective
    <DP head case_for_position> = objective    | to know normal case for conjoined DPs
     <DP head type pronoun> = +        | pronouns different case CB 23May19
     <DP head agr person first> = +
     <DP head agr person third> = -  
     <DP head agr person second> = -  
    /<DP head case> = objective
    <DP head case_for_position> = objective    | to know normal case for conjoined DPs
     <DP head type pronoun> = +        | pronouns different case CB 23May19
     <DP head agr person second> = +  
     <DP head agr person third> = -  
     <DP head agr person first> = -  
    }
     <DP_1 head type comma> = -
     <DP_1 head type pronoun> = +
    {<DP_1 head case> = objective
     <DP_1 head agr person first> = +
     <DP_1 head agr person third> = -  
     <DP_1 head agr person second> = -  
    /<DP_1 head case> = objective
     <DP_1 head agr person second> = +  
     <DP_1 head agr person third> = -  
     <DP_1 head agr person first> = -  
    /<DP_1 head case> = oblique          | pronouns different case CB 23May19
     <DP head type animate> = -
     <DP_1 head agr person third> = +  
     <DP_1 head agr person first> = -  
     <DP_1 head agr person second> = -  
    /<DP_1 head case> = objective          | pronouns different case CB 23May19
     <DP head type animate> = +
     <DP_1 head agr person third> = +  
     <DP_1 head agr person first> = -  
     <DP_1 head agr person second> = -  
    }
    <DP_1 head type apposition> = -
    <DP_1 head type case-marked> = -
    <DP_1 head type DO_contraction> = -
    <DP_1 head type genitive_suffix> = -
    <DP_1 head type locative> = -
    <VP head type passive> = -
    <VP head type no_intervening> = -   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type> == [modifier-final:+] -> ~[compound:+]  | modified DPs whose final element is marked compound, must compound 16Jul03 CB
    <VP head> == [rootgloss:^1] -> 
                  ~(([object:[head:[type:[modifier-final:-]]]] 
                    &[object:[head:[type:[case-marked:-]]]] ) &
                   (( [object:[head:[type:[compounds_with1:^1]]]]
                    / [object:[head:[type:[compounds_with2:^1]]]])
                    / ([object:[head:[type:[compounds_with3:^1]]]]
                    / [object:[head:[type:[compounds_with4:^1]]]]) ) ) |21Jul03
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP_1 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <VP head> == [subject:[head:[agr:[person:[first:+]]]]] -> ~[indirectobject:[head:[agr:[person:[first:+]]]]]  |22Jan2020 for Pn3Obl1  
    <VP head> == [subject:[head:[agr:[person:[second:+]]]]] -> ~[indirectobject:[head:[agr:[person:[second:+]]]]]
     <VP head auxiliaryH> == ~([rootgloss:be.able] &
                              [infl:[tense:[past:+]]])   | no past Aux to change tense Feb2020
    <VP rule> = 6cIIDPnonPastNonGenericDefinite


| 8a and 8aQ separated 06-APR-04 to account for embedded questions with kh Aya where the main verb requires embedded_subjunctive, but not in questions
rule {VP option 8a - V initial, sentential complement - non question}
VP = V {IP / CP}
    <VP head> = <V head>
    <VP head rootgloss> = <V rootgloss>
    <V head type comma> = -
    <IP head type root> = -
    <CP head type root> = -
    <CP head type question> = -
    <VP head type no_intervening> = +   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <V embedded> = <IP head embedded>     | pass down and check on verb
    <V embedded> = <CP head embedded>     | pass down and check on verb
    <V head case> = direct       | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <V head type sentential> = +
    <IP head type relcl> = -            | not a rel clause 21Nov03 CB
    <CP head type relcl> = -            | not a rel clause 21Nov03 CB
    <VP head type comma> <= <IP head type comma>
    <VP head type comma> <= <CP head type comma>
    <VP rule> = 8a

rule {VP option 8aQ - V initial, question complement}
VP = V CP
    <VP head> = <V head>
    <VP head rootgloss> = <V rootgloss>
    <V head type comma> = -
    <CP head type root> = -
    <CP head type question> = +
    <VP head type no_intervening> = +   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <V head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <V head type sentential> = +
    <CP head type relcl> = -            | not a rel clause 21Nov03 CB
    <VP head type comma> <= <CP head type comma>
    <VP rule> = 8aQ

| added 07-APR-04 CB for mmkn ast yxyy hman msyx baSd.
rule {VP option 8adj - V final, copular w/ adj, plus sentential}
VP = AdjP V IP
    <VP head> = <V head>
    <VP head rootgloss> = <V rootgloss>
    <V head type copular> = +
    <AdjP head type comma> = -
    <AdjP head case> = direct
    <V head infl finite> = +        | don't allow short or regular infinitive at end of verb phrase
    <VP head type passive> = -
    <VP head type no_intervening> = -   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <IP head type root> = -
    <AdjP embedded> = <IP head embedded>     | pass down and check on verb, sentential & embedded from Adj
    <AdjP head type sentential> = +
    <V head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = +            | don't allow short or regular infinitive at end of verb phrase
    <IP head type relcl> = -            | not a rel clause 21Nov03 CB
    <VP head type comma> <= <IP head type comma>
    <AdjP head type> == ~[compound:+]     | AdjPs which are marked compound, must compound
    <VP rule> = 8adj

rule {VP option 9passI - V participle, passive}
VP = V_1 V_2
    <VP head> = <V_2 head>
    <VP head rootgloss> = <V_1 rootgloss>     | 12-APR-04 for compounding constraints
    <VP head rootgloss_V_2> <= <V_2 rootgloss> | 12-APR-04 for no Aux rule
    <VP head subject> = <V_1 head subject>
|    <V_2 head type comma> = -     | 03Apr03 CB need , at end of relcl
    <V_2 head type passive> = +
    <V_1 head type participle> = +
    <V_1 head case> = direct       | 09-APR-04 since allow case on V+participle for adjective use
    <V_2 head case> = direct       | 09-APR-04 since allow case on V+participle for adjective use
|      <V_1 head type compounded> = -         | RL 29Mar03  Need compounding for sentences like: bh^^wasvhE aw parsa Smrdh my^Swd
    <V_2 head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <VP head type no_intervening> = +   | for compounding constraint
    <V_1 head type object_agr_suffix> = -   |CB 24May19   no object agr
    <V_2 head type object_agr_suffix> = -   |CB 24May19   no object agr
    <VP head type participle_passive> <= +       | 12-APR-04 to restrict V+participle
    <VP rule> = 9passI

rule {VP option 9f - V final, passive}
VP = V
    <VP head> = <V head>
    <VP head rootgloss> = <V rootgloss>
    <V head type passive> = +
    <V head case> = direct       | 09-APR-04 since allow case on V+participle for adjective use
    <V head infl finite> = + | don't allow short or regular infinitive at end of verb phrase
    <VP head type no_intervening> = +   | for compounding constraint
    <V head type object_agr_suffix> = -   |CB 24May19   no object agr
    <VP rule> = 9f

| F and Fcop were identical, except for copular feature, so combined 10Dec03
rule {V option F - Aux initial, required -- Future}
V = Aux V_1 
    <V head> = <Aux head>
    <Aux head type comma> = -
    <V_1 head case> = direct       | 09-APR-04 since allow case on V+participle for adjective use
    <V_1 head infl finite> = short   | requires the verb to have the feature short_infinitive
    <Aux head infl tense future> = + | requires that the auxillary have the future feature.
    <V rootgloss> = <V_1 rootgloss>  | RL 16Jan03 pass up the root gloss so compounding works.
    <V head type> <= <V_1 head type> | type features come from V, agr from Aux
    <V head rootgloss_V_2> = <V_1 head rootgloss_V_2> | 13-APR-04 restrict Aux 
    <V_1 head type object_agr_suffix> = -   |CB 24May19   no object agr
    <Aux head type object_agr_suffix> = -   |CB 24May19   no object agr
    <V head infl finite> <= +        | future adds finiteness, then can fit other rules 03Apr03 CB
    <V rule> = F

|Added22Jan2020 for Pn3Obl3 **split by transitive & intransitive for object agr marking*
rule {V option Prt - Participle & perfective Aux(V)}
V = (V_2 Conj) V_1 Aux 
    <V head> = <Aux head>
    <V_1 head type comma> = -
    <V_2 head type comma> = -
    <Conj head type comma> = -
    <V_1 head case> = direct       | 09-APR-04 since allow case on V+participle for adjective use
    <V_2 head case> = direct       | 09-APR-04 since allow case on V+participle for adjective use
    <V rootgloss> = <Aux rootgloss>  | RL 16Jan03 pass up the root gloss so compounding works.
    <V head rootgloss_V_2> = none   | to prevent become rule Feb2020
    <V_1 head type transitive> = -
    <V_2 head type transitive> = -
    <V_1 head type object_agr_suffix> = -   |CB 24May19   no object agr
    <V_2 head type object_agr_suffix> = -   |CB 24May19   no object agr
    <Aux head type object_agr_suffix> = -   |CB 24May19   no object agr
    <V_1 head type participle> = + 
    <V_2 head type participle> = + 
    <Aux head infl aspect perfective> = +    |changed from copular 29Jan2020
    <V head type copular> = -              | V construction not copular 31Jan2020 
    <V head type motion> <= <V_1 head type motion>   | changed 27Jan2020 for Pn3Gen2  
    <V head type transitive> <= -   | changed 27Jan2020 for Pn3Gen2  
    <V head infl tense past> <= +   | changed 27Jan2020 for Pn3Gen2  
    <V head type participle> <= +   | changed 27Jan2020 for Pn3Gen2  
    <V rule> = Prt

rule {V option PrtTrPst - Transitive Participle & perfective Aux Pst} 
V = (V_2 Conj) V_1 Aux 
    <V head> = <Aux head>
    <V_1 head type comma> = -
    <V_2 head type comma> = -
    <Conj head type comma> = -
    <V_1 head case> = direct       | 09-APR-04 since allow case on V+participle for adjective use
    <V_2 head case> = direct       | 09-APR-04 since allow case on V+participle for adjective use
    <V rootgloss> = <Aux rootgloss>  | RL 16Jan03 pass up the root gloss so compounding works.
    <V head rootgloss_V_2> = none   | to prevent become rule Feb2020
    <V_1 head type transitive> = +
    <V_2 head type transitive> = +
    <V_1 head type object_agr_suffix> = -   |CB 24May19   no object agr
    <V_2 head type object_agr_suffix> = -   |CB 24May19   no object agr
    <Aux head type object_agr_suffix> = +   |CB 24May19   must have object agr
    <Aux head infl tense past> = +
    <V_1 head type participle> = + 
    <V_2 head type participle> = + 
    <Aux head infl aspect perfective> = +    |changed from copular 29Jan2020
    <V head type copular> = -              | V construction not copular 31Jan2020 
    <V head type motion> <= <V_1 head type motion>   | changed 27Jan2020 for Pn3Gen2  
    <V head type transitive> <= +   | changed 27Jan2020 for Pn3Gen2  
    <V head infl tense past> <= +   | changed 27Jan2020 for Pn3Gen2  
    <V head type participle> <= +   | changed 27Jan2020 for Pn3Gen2  
    <V rule> = PrtTrPst

|new rule Apr2020 split for V-Participle 3,15
rule {V option PrtTrPrs - Transitive Participle & perfective Aux Pres} 
V = (V_2 Conj) V_1 Aux 
    <V head> = <Aux head>
    <V_1 head type comma> = -
    <V_2 head type comma> = -
    <Conj head type comma> = -
    <V_1 head case> = direct       | 09-APR-04 since allow case on V+participle for adjective use
    <V_2 head case> = direct       | 09-APR-04 since allow case on V+participle for adjective use
    <V rootgloss> = <Aux rootgloss>  | RL 16Jan03 pass up the root gloss so compounding works.
    <V head rootgloss_V_2> = none   | to prevent become rule Feb2020
    <V_1 head type transitive> = +
    <V_2 head type transitive> = +
    <V_1 head type object_agr_suffix> = -   |CB 24May19   no object agr
    <V_2 head type object_agr_suffix> = -   |CB 24May19   no object agr
    <Aux head type object_agr_suffix> = -   |CB 24May19   no object agr
    <Aux head infl tense present> = +
    <V_1 head type participle> = + 
    <V_2 head type participle> = + 
    <Aux head infl aspect perfective> = +    |changed from copular 29Jan2020
    <V head type copular> = -              | V construction not copular 31Jan2020 
    <V head type motion> <= <V_1 head type motion>   | changed 27Jan2020 for Pn3Gen2  
    <V head type transitive> <= +   | changed 27Jan2020 for Pn3Gen2  
    <V head infl tense past> <= -   | changed 27Jan2020 for Pn3Gen2  
    <V head infl tense present> <= +   | changed 27Jan2020 for Pn3Gen2  
    <V head type participle> <= +   | changed 27Jan2020 for Pn3Gen2  
    <V rule> = PrtTrPrs


|This did not work so compound optional in two rules above |participles split off  
|rule {V option conjoinedPart}
|V = V_1 Conj V_2
|    <V head> = <V_2 head>                 | all V's share most features
|    <V head rootgloss> = <V_1 rootgloss>  | rootgloss from V_1 for compounding info
|    <V head rootgloss_V_2> <= <V_2 rootgloss> | for Aux constraints 12-APR-04 
|    <V head infl> = <V_1 head infl>       | all V's share most features
|    <V head subject> = <V_1 head subject>    
|    <V_1 head type transitive> = +
|    <V_2 head type transitive> = +
|    <V_1 head case> = direct       | 09-APR-04 since allow case on V+participle for adjective use
|    <V_2 head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use
|    <V_1 head type participle> = +
|    <V_2 head type participle> = +
|    <V head type copular> = <V_1 head type copular>
|    <V head type passive> = <V_1 head type passive>
|    <V head type motion> = <V_1 head type motion>
|    <V_1 head type object_agr_suffix> = -   |obj suffixes only on aux  6Feb2020
|    <V_2 head type object_agr_suffix> = -
|    <Conj gloss> = and
|    <V conjoined> <= +       | for compounding constraint in V rule 1
|    <V rule> = conjoinedPart

| object agreement restrictions not added below here for now. SHould not need since all V's marked above 05May19

rule {V option 1 - compound with noun}
V = N V_1
    <V head> = <V_1 head>
    <V rootgloss> = <V_1 rootgloss>
    <N head type comma> = -
    <N head type relative> = -
    <N head type reflexivity> = -
    <N head type indefinite> = -
    <N head type proper> = -
    <N head infl finite> = +
    <N head case> = direct | case marking getting through #3 Apr2020????
    <N head case_for_position> = direct  |Apr2020
    <N head agr number plural> = -
    <N head type copular_suffix> = -
    <N head type genitive_suffix> = -  |Apr2020
    <N head type modifier_required> = -  |Apr2020
    <V_1 head case> = direct       | 09-APR-04 since allow case on V+participle for adjective use
    <V_1 conjoined> = -                | not conjoined V's
    <V head type compound> = + 
   {<N head type compounds_with1> = <V_1 rootgloss>
    /<N head type compounds_with2> = <V_1 rootgloss>
    /<N head type compounds_with3> = <V_1 rootgloss>
    /<N head type compounds_with4> = <V_1 rootgloss>}
    <V_1 head type compounded> = - | to prevent double compounding
    <V head type compounded> <= +   | to prevent double compounding
    <V head type sentential> <= <N head type sentential>
    <V head type transitive> <= <N head type transitive> 
    <V head type transitive> <= <N head type ditransitive>  |Apr2020 
    <V head type passive>    <= <N head type passive>      | let N override passive RL 20Mar03
    <V head type copular> <= -      | RL 28Mar03 compound verbs are never copular
    <V embedded> <= <N embedded>
    <N head type> == ~[compound:-]  | words which never compound should be marked -compound
    <V rule> = 1

| rule added **19Jul06 CB
rule {V option 1dblN - double compound with noun}
V = N_1 Conj N_2 V_1
    <V head> = <V_1 head>
    <V rootgloss> = <V_1 rootgloss>
    <Conj gloss> = and
    <N_1 head type comma> = -
    <N_1 head type relative> = -
    <N_1 head type reflexivity> = -
    <N_1 head type indefinite> = -
    <N_1 head type proper> = -
    <N_1 head infl finite> = +
    <N_1 head case> = direct 
    <N_1 head agr number plural> = -
    <N_1 head type copular_suffix> = -
    <N_2 head type comma> = -
    <N_2 head type relative> = -
    <N_2 head type reflexivity> = -
    <N_2 head type indefinite> = -
    <N_2 head type proper> = -
    <N_2 head infl finite> = +
    <N_2 head case> = direct 
    <N_2 head agr number plural> = -
    <N_2 head type copular_suffix> = -
    <V_1 head case> = direct       | 09-APR-04 since allow case on V+participle for adjective use
    <V_1 conjoined> = -                | not conjoined V's
    <V head type compound> = + 
    {<N_1 head type compounds_with1> = <V_1 rootgloss>
    /<N_1 head type compounds_with2> = <V_1 rootgloss>
    /<N_1 head type compounds_with3> = <V_1 rootgloss>
    /<N_1 head type compounds_with4> = <V_1 rootgloss>}
    {<N_1 head type compounds_with1> = <V_1 rootgloss>
    /<N_1 head type compounds_with2> = <V_1 rootgloss>
    /<N_1 head type compounds_with3> = <V_1 rootgloss>
    /<N_1 head type compounds_with4> = <V_1 rootgloss>}
    <V_1 head type compounded> = - | to prevent double compounding
    <V head type compounded> <= +   | to prevent double compounding
    <V head type sentential> <= <N_2 head type sentential>
    <V head type transitive> <= <N_2 head type transitive> 
    <V head type passive>    <= <N_2 head type passive>      | let N override passive RL 20Mar03
    <V head type copular> <= -      | RL 28Mar03 compound verbs are never copular
    <V embedded> <= <N_2 embedded>
    <N_1 head type> == ~[compound:-]  | words which never compound should be marked -compound
    <N_2 head type> == ~[compound:-]  | words which never compound should be marked -compound
    <V rule> = 1dblN

rule {V option 2 - compound with adjective}
V = Adj V_1
    <V head> = <V_1 head>
    <V rootgloss> = <V_1 rootgloss>
    <Adj head type comma> = -
    <Adj head type relative> = -
    <Adj head type indefinite> = -
    <Adj head type attributive> = -    | CB 23May2019 assuming like predicate adjectives
    <Adj head case> = direct 
    <Adj head agr number plural> = - |RL 22Apr202
    <Adj head type copular_suffix> = -
    {<Adj head type compounds_with1> = <V_1 rootgloss>
    /<Adj head type compounds_with2> = <V_1 rootgloss>
    /<Adj head type compounds_with3> = <V_1 rootgloss>
    /<Adj head type compounds_with4> = <V_1 rootgloss>}
    <V_1 head case> = direct       | 09-APR-04 since allow case on V+participle for adjective use
    <V head type compound> = +
    <V_1 head type compounded> = - | to prevent double compounding
    <V head type compounded> <= + | to prevent double compounding
    <V head type sentential> <= <Adj head type sentential>
    <V head type transitive> <= <Adj head type transitive>
    <V head type ditransitive> <= <Adj head type ditransitive>  
    <V head type passive>    <= <Adj head type passive>      | let Adj override passive RL 20Mar03
    <V head type copular> <= -      | RL 28Mar03 compound verbs are never copular
    <V embedded> <= <Adj embedded>
    <Adj head type> == ~[compound:-]  | words which never compound should be marked -compound
    <V rule> = 2

| rule added **19Jul06 CB
rule {V option 2dblAdj - double compound with adjective}
V = Adj_1 Conj Adj_2 V_1
    <V head> = <V_1 head>
    <V rootgloss> = <V_1 rootgloss>
    <Conj gloss> = and
    <Adj_1 head type comma> = -
    <Adj_1 head type relative> = -
    <Adj_1 head type indefinite> = -
    <Adj_1 head case> = direct
    <Adj_1 head type copular_suffix> = -
    <Adj_2 head type comma> = -
    <Adj_2 head type relative> = -
    <Adj_2 head type indefinite> = -
    <Adj_2 head case> = direct
    <Adj_2 head type copular_suffix> = -
    {<Adj_1 head type compounds_with1> = <V_1 rootgloss>
    /<Adj_1 head type compounds_with2> = <V_1 rootgloss>
    /<Adj_1 head type compounds_with3> = <V_1 rootgloss>
    /<Adj_1 head type compounds_with4> = <V_1 rootgloss>}
    {<Adj_2 head type compounds_with1> = <V_1 rootgloss>
    /<Adj_2 head type compounds_with2> = <V_1 rootgloss>
    /<Adj_2 head type compounds_with3> = <V_1 rootgloss>
    /<Adj_2 head type compounds_with4> = <V_1 rootgloss>}
    <V_1 head case> = direct       | 09-APR-04 since allow case on V+participle for adjective use
    <V head type compound> = +
    <V_1 head type compounded> = - | to prevent double compounding
    <V head type compounded> <= + | to prevent double compounding
    <V head type sentential> <= <Adj_2 head type sentential>
    <V head type transitive> <= <Adj_2 head type transitive>
    <V head type passive>    <= <Adj_2 head type passive>      | let Adj override passive RL 20Mar03
    <V head type copular> <= -      | RL 28Mar03 compound verbs are never copular
    <V embedded> <= <Adj_2 embedded>
    <Adj_1 head type> == ~[compound:-]  | words which never compound should be marked -compound
    <Adj_2 head type> == ~[compound:-]  | words which never compound should be marked -compound
    <V rule> = 2dblAdj

|does this need to be changed for compound as above??  If so, check DP rules.
rule {V option 3 - compound with 'alone'}
V = Deg V_1
    <V head> = <V_1 head>
    <V rootgloss> = <V_1 rootgloss>
    <Deg head type compound> = +
    <V_1 head case> = direct       | 09-APR-04 since allow case on V+participle for adjective use
    <V_1 head type compounded> = - | to prevent double compounding
    <V head type compounded> <= + | to prevent double compounding
    <V rule> = 3    

|conjoined V's  added 20Oct03 CB |may need to add participle and/or other type features
|04Dec03 RL Require the verbs to be transitive. I think this is the situation that created
|the need for this rule. Acts 14:5. For the intransitive case like Acts 13:9 compounding works
|fine with VP rule 0conj
|Not for participles  Feb2020
rule {V option conjoined}
V = V_1 Conj V_2
    <V head> = <V_2 head>                 | all V's share most features
    <V head rootgloss> = <V_1 rootgloss>  | rootgloss from V_1 for compounding info
    <V head rootgloss_V_2> <= <V_2 rootgloss> | for Aux constraints 12-APR-04 
    <V head infl> = <V_1 head infl>       | all V's share most features
    <V head subject> = <V_1 head subject>    
    <V_1 head type transitive> = +
    <V_2 head type transitive> = +
    <V_1 head type participle> = -
    <V_2 head type participle> = -
    <V_1 head case> = direct       | 09-APR-04 since allow case on V+participle for adjective use
    <V_2 head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use
    <V head type copular> = <V_1 head type copular>
    <V head type passive> = <V_1 head type passive>
    <V head type motion> = <V_1 head type motion>
    <Conj gloss> = and
    <V conjoined> <= +       | for compounding constraint in V rule 1
    <V rule> = conjoined


|-****Coordinate DPs without recursion
rule {DP option Sand - single with 'and'}
DP = (Conj_1) DP_1 Conj DP_2
    <DP head reflexive> = <DP_1 head reflexive> | pass reflexive info
    <DP head reflexive> = <DP_2 head reflexive> | pass reflexive info
    <DP head type coordination> = +
    <DP_1 head type nonfinalcoordination> <= +  | for AdjP case 14Aug03 CB
    <DP_2 head type nonfinalcoordination> = -  | for AdjP case 14Aug03 CB
    <DP head type DO_contraction> = -
    <DP head type case-marked> = -
    <DP_1 head type case-marked> = -
    <DP_2 head type case-marked> = -
    <Conj gloss> = and
    <Conj_1 gloss> = also
    <Conj head type conjoins_DP> = +
    <Conj_1 head type DP-initial> = +
    <DP mother_node> = +          | initial DP in coordination
    <DP_1 mother_node> = -        | not initial DP in coordination
    <DP_2 mother_node> = -        | not initial DP in coordination
    <DP conjoined> = +                 | to restrict recursion
    <DP_1 conjoined> = -
    <DP_2 conjoined> = -
    <DP head type modifier-final> = -        | set feature for mother DP
    <DP head type modifier-initial> = -      | set feature for mother DP
    <DP head type relative> = -              | set feature for mother DP
    <DP head agr person> = <DP_1 head agr person>  | initial DP gives person
    <DP head type human> = <DP_1 head type human>  | initial DP gives human
    <DP head type pronoun> <= <DP_2 head type pronoun> | pronoun from final DP
    <DP head type proper> <= <DP_2 head type proper> | proper from final DP
    <DP head type no_head_N> <= <DP_2 head type no_head_N> | no_head_N from final DP
    <DP head type locative> = <DP_1 head type locative>  | initial DP gives locative Jan03CB**
    <DP head type apposition> = <DP_2 head type apposition> | final DP gives apposition 31Mar03 CB
    <DP head case_for_position> = <DP_2 head case_for_position> | case determined by
                                                      | position in sentence
    <DP head case> = <DP head case_for_position>
    <DP_1 head case_for_position> = <DP head case_for_position>  | for apposition 22Jan03 CB
    <DP_1 head case> = direct       | initial conjuncts unmarked
    <DP_2 head type modifier-final> = -  | final conjuncts have case
    <DP_2 head case> = <DP_2 head case_for_position>
    <DP head agr number plural> <= +      | plural comes from 'and'
    <DP head agr number singular> <= -
    <DP_1 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP_2 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP head type compound> <= <DP_2 head type compound>       
    <DP head type comma> <= <DP_2 head type comma>
    <DP head type relcl> <= <DP_2 head type relcl>    | 24Jul03 CB
    <DP rule> = Sand

rule {DP option Sor - single with 'or'}
DP = (Conj_1) DP_1 Conj DP_2
    <DP head reflexive> = <DP_1 head reflexive> | pass reflexive info
    <DP head reflexive> = <DP_2 head reflexive> | pass reflexive info
    <DP head type coordination> = +
    <DP_1 head type nonfinalcoordination> <= +  | for AdjP case 14Aug03 CB
    <DP_2 head type nonfinalcoordination> = -  | for AdjP case 14Aug03 CB
    <DP head type DO_contraction> = -
    <DP head type case-marked> = -
    <DP_1 head type case-marked> = -
    <DP_2 head type case-marked> = -
    <Conj gloss> = or
    <Conj_1 gloss> = or
    <Conj head type conjoins_DP> = +
    <Conj_1 head type DP-initial> = +
    <DP mother_node> = +          | initial DP in coordination
    <DP_1 mother_node> = -        | not initial DP in coordination
    <DP_2 mother_node> = -        | not initial DP in coordination
    <DP conjoined> = +                 | to restrict recursion
    <DP_1 conjoined> = -
    <DP_2 conjoined> = -
    <DP head type modifier-final> = -        | set feature for mother DP
    <DP head type modifier-initial> = -      | set feature for mother DP
    <DP head type relative> = -              | set feature for mother DP
    <DP head agr person> = <DP_1 head agr person>  | initial DP gives person
    <DP head agr number> = <DP_1 head agr number>  | initial DP gives number
    <DP head type human> = <DP_1 head type human>  | initial DP gives human
    <DP head type pronoun> <= <DP_2 head type pronoun> | pronoun from final DP
    <DP head type proper> <= <DP_2 head type proper> | proper from final DP
    <DP head type no_head_N> <= <DP_2 head type no_head_N> | no_head_N from final DP
    <DP head type locative> = <DP_1 head type locative>  | initial DP gives locative Jan03CB**
    <DP head type apposition> = <DP_2 head type apposition> | final DP gives apposition 31Mar03 CB
    <DP head case_for_position> = <DP_2 head case_for_position> | case determined by
                                                      | position in sentence
    <DP head case> = <DP head case_for_position>
    <DP_1 head case_for_position> = <DP head case_for_position>  | for apposition 22Jan03 CB
    <DP_1 head case> = direct      | initial conjuncts unmarked
    <DP_2 head case> = <DP_2 head case_for_position>  | final conjuncts have case
    <DP_1 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP_2 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP head type compound> <= <DP_2 head type compound>       
    <DP head type comma> <= <DP_2 head type comma>
    <DP head type relcl> <= <DP_2 head type relcl>    | 24Jul03 CB
    <DP rule> = Sor

rule {DP option Swhether - single with 'whether'}
DP = Conj_1 DP_1 Conj DP_2
    <DP head reflexive> = <DP_1 head reflexive> | pass reflexive info
    <DP head reflexive> = <DP_2 head reflexive> | pass reflexive info
    <DP head type coordination> = +
    <DP_1 head type nonfinalcoordination> <= +  | for AdjP case 14Aug03 CB
    <DP_2 head type nonfinalcoordination> = -  | for AdjP case 14Aug03 CB
    <DP head type DO_contraction> = -
    <DP head type case-marked> = -
    <DP_1 head type case-marked> = -
    <DP_2 head type case-marked> = -
    <Conj gloss> = whether
    <Conj_1 gloss> = whether
    <Conj head type conjoins_DP> = +
    <Conj_1 head type DP-initial> = +
    <DP mother_node> = +          | initial DP in coordination
    <DP_1 mother_node> = -        | not initial DP in coordination
    <DP_2 mother_node> = -        | not initial DP in coordination
    <DP conjoined> = +                 | to restrict recursion
    <DP_1 conjoined> = -
    <DP_2 conjoined> = -
    <DP head type modifier-final> = -        | set feature for mother DP
    <DP head type modifier-initial> = -      | set feature for mother DP
    <DP head type relative> = -              | set feature for mother DP
    <DP head agr person> = <DP_1 head agr person>  | initial DP gives person
    <DP head agr number> = <DP_1 head agr number>  | initial DP gives number
    <DP head type human> = <DP_1 head type human>  | initial DP gives human
    <DP head type pronoun> <= <DP_2 head type pronoun> | pronoun from final DP
    <DP head type proper> <= <DP_2 head type proper> | proper from final DP
    <DP head type no_head_N> <= <DP_2 head type no_head_N> | no_head_N from final DP
    <DP head type locative> = <DP_1 head type locative>  | initial DP gives locative Jan03CB**
    <DP head type apposition> = <DP_2 head type apposition> | final DP gives apposition 31Mar03 CB
    <DP head case_for_position> = <DP_2 head case_for_position> | case determined by
                                                      | position in sentence
    <DP head case> = <DP head case_for_position>
    <DP_1 head case_for_position> = <DP head case_for_position>  | for apposition 22Jan03 CB
    <DP_1 head case> = direct      | initial conjuncts unmarked
    <DP_2 head case> = <DP_2 head case_for_position> | final conjuncts have case
    <DP_1 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP_2 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP head type compound> <= <DP_2 head type compound>       
    <DP head type comma> <= <DP_2 head type comma>
    <DP head type relcl> <= <DP_2 head type relcl>    | 24Jul03 CB
    <DP rule> = Swhether

|***************************
|-****Coordinate DPs, initial (with recursion)
rule {DP option Iand - initial with 'and'}
DP = (Conj_1) DP_1 Conj DP_2
    <DP head reflexive> = <DP_1 head reflexive> | pass reflexive info
    <DP head reflexive> = <DP_2 head reflexive> | pass reflexive info
    <DP head type coordination> = initial
    <DP_1 head type nonfinalcoordination> <= +  | for AdjP case 14Aug03 CB
    <DP head type DO_contraction> = -
    <DP head type case-marked> = -
    <DP_1 head type case-marked> = -
    <DP_2 head type case-marked> = -
    <Conj gloss> = and
    <Conj_1 gloss> = also
    <Conj head type conjoins_DP> = +
    <Conj_1 head type DP-initial> = +
    <DP mother_node> = +          | initial DP in coordination
    <DP_1 mother_node> = -        | not initial DP in coordination
    <DP_2 mother_node> = -        | not initial DP in coordination
    <DP conjoined> = +                 | to restrict recursion
    <DP_1 conjoined> = -
    <DP_2 conjoined> = +
    <DP_2 conjunction gloss> = <Conj gloss>  | pass Conj info to DP_2 to correctly restrict Conj possible in recursion
    <DP head type modifier-final> = -        | set feature for mother DP
    <DP head type modifier-initial> = -      | set feature for mother DP
    <DP head type relative> = -              | set feature for mother DP
    <DP head agr person> = <DP_1 head agr person>  | initial DP gives person
    <DP head type human> = <DP_1 head type human>  | initial DP gives human
    <DP head type pronoun> <= <DP_2 head type pronoun> | pronoun from final DP
    <DP head type proper> <= <DP_2 head type proper> | proper from final DP
    <DP head type no_head_N> <= <DP_2 head type no_head_N> | no_head_N from final DP
    <DP head type locative> = <DP_1 head type locative>  | initial DP gives locative Jan03CB**
    <DP head type apposition> = <DP_2 head type apposition> | final DP gives apposition 31Mar03 CB
    <DP head case_for_position> = <DP_2 head case_for_position> | case determined by
                                                      | position in sentence
    <DP_1 head case_for_position> = <DP head case_for_position>  | for apposition 22Jan03 CB
    <DP head case> = <DP_2 head case>     | non-final conjunct
    <DP_1 head case> = direct      | initial conjuncts unmarked
    <DP head agr number plural> <= +      | plural comes from 'and'
    <DP head agr number singular> <= -
    <DP head type coordination> <= <DP_2 head type coordination> | final overrules
    <DP_1 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP_2 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP head type compound> <= <DP_2 head type compound>       
    <DP head type comma> <= <DP_2 head type comma>
    <DP head type relcl> <= <DP_2 head type relcl>    | 24Jul03 CB
    <DP rule> = Iand

rule {DP option I2or - initial with two 'or'}
DP = Conj_1 DP_1 Conj DP_2
    <DP head reflexive> = <DP_1 head reflexive> | pass reflexive info
    <DP head reflexive> = <DP_2 head reflexive> | pass reflexive info
    <DP head type coordination> = initial
    <DP_1 head type nonfinalcoordination> <= +  | for AdjP case 14Aug03 CB
    <DP head type conjunction_gloss> = initial_ya   | to restrict splitting between subject and object
    <DP head type DO_contraction> = -
    <DP head type case-marked> = -
    <DP_1 head type case-marked> = -
    <DP_2 head type case-marked> = -
    <Conj gloss> = or
    <Conj_1 gloss> = or
    <Conj head type conjoins_DP> = +
    <Conj_1 head type DP-initial> = +
    <DP mother_node> = +          | initial DP in coordination
    <DP_1 mother_node> = -        | not initial DP in coordination
    <DP_2 mother_node> = -        | not initial DP in coordination
    <DP conjoined> = +                 | to restrict recursion
    <DP_1 conjoined> = -
    <DP_2 conjoined> = +
    <DP_2 conjunction gloss> = <Conj gloss>  | pass Conj info to DP_2 to correctly restrict Conj possible in recursion
    <DP head type modifier-final> = -        | set feature for mother DP
    <DP head type modifier-initial> = -      | set feature for mother DP
    <DP head type relative> = -              | set feature for mother DP
    <DP head agr person> = <DP_1 head agr person>  | initial DP gives person
    <DP head agr number> = <DP_1 head agr number>  | initial DP gives number
    <DP head type human> = <DP_1 head type human>  | initial DP gives human
    <DP head type pronoun> <= <DP_2 head type pronoun> | pronoun from final DP
    <DP head type proper> <= <DP_2 head type proper> | proper from final DP
    <DP head type no_head_N> <= <DP_2 head type no_head_N> | no_head_N from final DP
    <DP head type locative> = <DP_1 head type locative>  | initial DP gives locative Jan03CB**
    <DP head type apposition> = <DP_2 head type apposition> | final DP gives apposition 31Mar03 CB
    <DP head case_for_position> = <DP_2 head case_for_position> | case determined by
                                                      | position in sentence
    <DP_1 head case_for_position> = <DP head case_for_position>  | for apposition 22Jan03 CB
    <DP head case> = <DP_2 head case>     | non-final conjunct
    <DP_1 head case> = direct      | initial conjuncts unmarked
    <DP head type coordination> <= <DP_2 head type coordination> | final overrules
    <DP_1 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP_2 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP head type compound> <= <DP_2 head type compound>       
    <DP head type comma> <= <DP_2 head type comma>
    <DP head type relcl> <= <DP_2 head type relcl>    | 24Jul03 CB
    <DP rule> = I2or

rule {DP option Ior - initial with 'or'}
DP = DP_1 Conj DP_2
    <DP head reflexive> = <DP_1 head reflexive> | pass reflexive info
    <DP head reflexive> = <DP_2 head reflexive> | pass reflexive info
    <DP head type coordination> = initial
    <DP_1 head type nonfinalcoordination> <= +  | for AdjP case 14Aug03 CB
    <DP head type DO_contraction> = -
    <DP head type case-marked> = -
    <DP_1 head type case-marked> = -
    <DP_2 head type case-marked> = -
    <Conj gloss> = or
    <Conj head type conjoins_DP> = +
    <DP mother_node> = +          | initial DP in coordination
    <DP_1 mother_node> = -        | not initial DP in coordination
    <DP_2 mother_node> = -        | not initial DP in coordination
    <DP conjoined> = +                 | to restrict recursion
    <DP_1 conjoined> = -
    <DP_2 conjoined> = +
    <DP_2 conjunction gloss> = <Conj gloss>  | pass Conj info to DP_2 to correctly restrict Conj possible in recursion
    <DP head type modifier-final> = -        | set feature for mother DP
    <DP head type modifier-initial> = -      | set feature for mother DP
    <DP head type relative> = -              | set feature for mother DP
    <DP head agr person> = <DP_1 head agr person>  | initial DP gives person
    <DP head agr number> = <DP_1 head agr number>  | initial DP gives number
    <DP head type human> = <DP_1 head type human>  | initial DP gives human
    <DP head type pronoun> <= <DP_2 head type pronoun> | pronoun from final DP
    <DP head type proper> <= <DP_2 head type proper> | proper from final DP
    <DP head type no_head_N> <= <DP_2 head type no_head_N> | no_head_N from final DP
    <DP head type locative> = <DP_1 head type locative>  | initial DP gives locative Jan03CB**
    <DP head type apposition> = <DP_2 head type apposition> | final DP gives apposition 31Mar03 CB
    <DP head case_for_position> = <DP_2 head case_for_position> | case determined by
                                                      | position in sentence
    <DP_1 head case_for_position> = <DP head case_for_position>  | for apposition 22Jan03 CB
    <DP head case> = <DP_2 head case>     | non-final conjunct
    <DP_1 head case> = direct      | initial conjuncts unmarked
    <DP head type coordination> <= <DP_2 head type coordination> | final overrules
    <DP_1 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP_2 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP head type compound> <= <DP_2 head type compound>       
    <DP head type comma> <= <DP_2 head type comma>
    <DP head type relcl> <= <DP_2 head type relcl>    | 24Jul03 CB
    <DP rule> = Ior

rule {DP option Iwhether - initial with 'whether'}
DP = Conj_1 DP_1 Conj DP_2
    <DP head reflexive> = <DP_1 head reflexive> | pass reflexive info
    <DP head reflexive> = <DP_2 head reflexive> | pass reflexive info
    <DP head type coordination> = initial
    <DP_1 head type nonfinalcoordination> <= +  | for AdjP case 14Aug03 CB
    <DP head type DO_contraction> = -
    <DP head type case-marked> = -
    <DP_1 head type case-marked> = -
    <DP_2 head type case-marked> = -
    <Conj gloss> = whether
    <Conj_1 gloss> = whether
    <Conj head type conjoins_DP> = +
    <Conj_1 head type DP-initial> = +
    <DP mother_node> = +          | initial DP in coordination
    <DP_1 mother_node> = -        | not initial DP in coordination
    <DP_2 mother_node> = -        | not initial DP in coordination
    <DP conjoined> = +                 | to restrict recursion
    <DP_1 conjoined> = -
    <DP_2 conjoined> = +
    <DP_2 conjunction gloss> = <Conj gloss>  | pass Conj info to DP_2 to correctly restrict Conj possible in recursion
    <DP head type modifier-final> = -        | set feature for mother DP
    <DP head type modifier-initial> = -      | set feature for mother DP
    <DP head type relative> = -              | set feature for mother DP
    <DP head agr person> = <DP_1 head agr person>  | initial DP gives person
    <DP head agr number> = <DP_1 head agr number>  | initial DP gives number
    <DP head type human> = <DP_1 head type human>  | initial DP gives human
    <DP head type pronoun> <= <DP_2 head type pronoun> | pronoun from final DP
    <DP head type proper> <= <DP_2 head type proper> | proper from final DP
    <DP head type no_head_N> <= <DP_2 head type no_head_N> | no_head_N from final DP
    <DP head type locative> = <DP_1 head type locative>  | initial DP gives locative Jan03CB**
    <DP head type apposition> = <DP_2 head type apposition> | final DP gives apposition 31Mar03 CB
    <DP head case_for_position> = <DP_2 head case_for_position> | case determined by
                                                      | position in sentence
    <DP_1 head case_for_position> = <DP head case_for_position>  | for apposition 22Jan03 CB
    <DP head case> = <DP_2 head case>     | non-final conjunct
    <DP_1 head case> = direct      | initial conjuncts unmarked
    <DP head type coordination> <= <DP_2 head type coordination> | final overrules
    <DP_1 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP_2 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP head type compound> <= <DP_2 head type compound>       
    <DP head type comma> <= <DP_2 head type comma>
    <DP head type relcl> <= <DP_2 head type relcl>    | 24Jul03 CB
    <DP rule> = Iwhether

rule {DP option Icomma-or - initial with 'comma', 'or'}
DP = DP_1 DP_2
    <DP head reflexive> = <DP_1 head reflexive> | pass reflexive info
    <DP head reflexive> = <DP_2 head reflexive> | pass reflexive info
    <DP head type coordination> = initial
    <DP_1 head type nonfinalcoordination> <= +  | for AdjP case 14Aug03 CB
    <DP head type DO_contraction> = -
    <DP head type case-marked> = -
    <DP_1 head type case-marked> = -
    <DP_2 head type case-marked> = -
    <DP_1 head type comma> = +
    <DP mother_node> = +          | initial DP in coordination
    <DP_1 mother_node> = -        | not initial DP in coordination
    <DP_2 mother_node> = -        | not initial DP in coordination
    <DP conjoined> = +                 | to restrict recursion
    <DP_1 conjoined> = -
    <DP_2 conjoined> = +
    <DP_2 conjunction gloss> = ending  | pass Conj info to DP_2 to correctly restrict Conj possible in recursion- comma
    <DP head type modifier-final> = -        | set feature for mother DP
    <DP head type modifier-initial> = -      | set feature for mother DP
    <DP head type relative> = -              | set feature for mother DP
    <DP head agr person> = <DP_1 head agr person>  | initial DP gives person
    <DP head type human> = <DP_1 head type human>  | initial DP gives human
    <DP head type pronoun> <= <DP_2 head type pronoun> | pronoun from final DP
    <DP head type proper> <= <DP_2 head type proper> | proper from final DP
    <DP head type no_head_N> <= <DP_2 head type no_head_N> | no_head_N from final DP
    <DP head type locative> = <DP_1 head type locative>  | initial DP gives locative Jan03CB**
    <DP head type apposition> = <DP_2 head type apposition> | final DP gives apposition 31Mar03 CB
    <DP head case_for_position> = <DP_2 head case_for_position> | case determined by
                                                      | position in sentence
    <DP_1 head case_for_position> = <DP head case_for_position>  | for apposition 22Jan03 CB
    <DP head case> = <DP_2 head case>     | non-final conjunct
    <DP_1 head case> = direct      | initial conjuncts unmarked
    <DP_2 final_conjunction gloss> = or
    <DP head type coordination> <= <DP_2 head type coordination> | final overrules
    <DP_1 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP_2 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP head type compound> <= <DP_2 head type compound>       
    <DP head type comma> <= <DP_2 head type comma>
    <DP head type relcl> <= <DP_2 head type relcl>    | 24Jul03 CB
    <DP rule> = Icomma-or

rule {DP option Icomma-and - initial with 'comma', 'and'}
DP = DP_1 DP_2
    <DP head reflexive> = <DP_1 head reflexive> | pass reflexive info
    <DP head reflexive> = <DP_2 head reflexive> | pass reflexive info
    <DP head type coordination> = initial
    <DP_1 head type nonfinalcoordination> <= +  | for AdjP case 14Aug03 CB
    <DP head type DO_contraction> = -
    <DP head type case-marked> = -
    <DP_1 head type case-marked> = -
    <DP_2 head type case-marked> = -
    <DP_1 head type comma> = +
    <DP mother_node> = +          | initial DP in coordination
    <DP_1 mother_node> = -        | not initial DP in coordination
    <DP_2 mother_node> = -        | not initial DP in coordination
    <DP conjoined> = +                 | to restrict recursion
    <DP_1 conjoined> = -
    <DP_2 conjoined> = +
    <DP_2 conjunction gloss> = ending  | pass Conj info to DP_2 to correctly restrict Conj possible in recursion - comma
    <DP head type modifier-final> = -        | set feature for mother DP
    <DP head type modifier-initial> = -      | set feature for mother DP
    <DP head type relative> = -              | set feature for mother DP
    <DP head agr person> = <DP_1 head agr person>  | initial DP gives person
    <DP head type human> = <DP_1 head type human>  | initial DP gives human
    <DP head type pronoun> <= <DP_2 head type pronoun> | pronoun from final DP
    <DP head type proper> <= <DP_2 head type proper> | proper from final DP
    <DP head type no_head_N> <= <DP_2 head type no_head_N> | no_head_N from final DP
    <DP head type locative> = <DP_1 head type locative>  | initial DP gives locative Jan03CB**
    <DP head type apposition> = <DP_2 head type apposition> | final DP gives apposition 31Mar03 CB
    <DP head case_for_position> = <DP_2 head case_for_position> | case determined by
                                                      | position in sentence
    <DP_1 head case_for_position> = <DP head case_for_position>  | for apposition 22Jan03 CB
    <DP head case> = <DP_2 head case>     | non-final conjunct
    <DP_1 head case> = direct      | initial conjuncts unmarked
    <DP_2 final_conjunction gloss> = and
    <DP head agr number plural> <= +      | plural comes from 'and'
    <DP head agr number singular> <= -
    <DP head type coordination> <= <DP_2 head type coordination> | final overrules
    <DP_1 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP_2 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP head type compound> <= <DP_2 head type compound>       
    <DP head type comma> <= <DP_2 head type comma>
    <DP head type relcl> <= <DP_2 head type relcl>    | 24Jul03 CB
    <DP rule> = Icomma-and

|-****Coordinate DPs, medial only
rule {DP option Mand - medial with 'and'}
DP = DP_1 Conj DP_2
    <DP head reflexive> = <DP_1 head reflexive> | pass reflexive info
    <DP head reflexive> = <DP_2 head reflexive> | pass reflexive info
    <DP head type coordination> = medial
    <DP_1 head type nonfinalcoordination> <= +  | for AdjP case 14Aug03 CB
    <DP head type DO_contraction> = -
    <DP head type modifier-final> = <DP_2 head type modifier-final>
    <DP head type case-marked> = -
    <DP_1 head type case-marked> = -
    <DP_2 head type case-marked> = -
    <Conj gloss> = and
    <Conj head type conjoins_DP> = +
    <DP mother_node> = -          | not initial DP in coordination
    <DP_1 mother_node> = -        | not initial DP in coordination
    <DP_2 mother_node> = -        | not initial DP in coordination
    <DP conjoined> = +                 | to restrict recursion
    <DP_1 conjoined> = -
    <DP_2 conjoined> = +
    <DP conjunction gloss> = <Conj gloss>  | require 'and' as upper Conj
    <DP_2 conjunction gloss> = <Conj gloss>  | pass Conj info to DP_2 to correctly restrict Conj possible in recursion
    <DP head case_for_position> = <DP_2 head case_for_position> | case determined by
                                                      | position in sentence
    <DP_1 head case_for_position> = <DP head case_for_position>  | for apposition 22Jan03 CB
    <DP head case> = <DP_2 head case>     | non-final conjunct
    <DP_1 head case> = direct      | non-final conjuncts unmarked
    <DP head type pronoun> <= <DP_2 head type pronoun> | pronoun from final DP
    <DP head type proper> <= <DP_2 head type proper> | proper from final DP
    <DP head type no_head_N> <= <DP_2 head type no_head_N> | no_head_N from final DP
    <DP head type coordination> <= <DP_2 head type coordination> | final overrules
    <DP_1 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP_2 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP head type comma> <= <DP_2 head type comma>
    <DP head type relcl> <= <DP_2 head type relcl>    | 24Jul03 CB
    <DP rule> = Mand

rule {DP option Mor - medial with 'or'}
DP = DP_1 Conj DP_2
    <DP head reflexive> = <DP_1 head reflexive> | pass reflexive info
    <DP head reflexive> = <DP_2 head reflexive> | pass reflexive info
    <DP head type coordination> = medial
    <DP_1 head type nonfinalcoordination> <= +  | for AdjP case 14Aug03 CB
    <DP head type DO_contraction> = -
    <DP head type modifier-final> = <DP_2 head type modifier-final>
    <DP head type case-marked> = -
    <DP_1 head type case-marked> = -
    <DP_2 head type case-marked> = -
    <Conj gloss> = or
    <Conj head type conjoins_DP> = +
    <DP mother_node> = -          | not initial DP in coordination
    <DP_1 mother_node> = -        | not initial DP in coordination
    <DP_2 mother_node> = -        | not initial DP in coordination
    <DP conjoined> = +                 | to restrict recursion
    <DP_1 conjoined> = -
    <DP_2 conjoined> = +
    <DP conjunction gloss> = <Conj gloss>  | require 'or' as upper Conj
    <DP_2 conjunction gloss> = <Conj gloss>  | pass Conj info to DP_2 to correctly restrict Conj possible in recursion
    <DP head case_for_position> = <DP_2 head case_for_position> | case determined by
                                                      | position in sentence
    <DP_1 head case_for_position> = <DP head case_for_position>  | for apposition 22Jan03 CB
    <DP head case> = <DP_2 head case>     | non-final conjunct
    <DP_1 head case> = direct      | non-final conjuncts unmarked
    <DP head type pronoun> <= <DP_2 head type pronoun> | pronoun from final DP
    <DP head type proper> <= <DP_2 head type proper> | proper from final DP
    <DP head type no_head_N> <= <DP_2 head type no_head_N> | no_head_N from final DP
    <DP head type coordination> <= <DP_2 head type coordination>  | final overrules
    <DP_1 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP_2 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP head type comma> <= <DP_2 head type comma>
    <DP head type relcl> <= <DP_2 head type relcl>    | 24Jul03 CB
    <DP rule> = Mor

rule {DP option Mwhether - medial with 'whether'}
DP = DP_1 Conj DP_2
    <DP head reflexive> = <DP_1 head reflexive> | pass reflexive info
    <DP head reflexive> = <DP_2 head reflexive> | pass reflexive info
    <DP head type coordination> = medial
    <DP_1 head type nonfinalcoordination> <= +  | for AdjP case 14Aug03 CB
    <DP head type DO_contraction> = -
    <DP head type modifier-final> = <DP_2 head type modifier-final>
    <DP head type case-marked> = -
    <DP_1 head type case-marked> = -
    <DP_2 head type case-marked> = -
    <Conj gloss> = whether
    <Conj head type conjoins_DP> = +
    <DP mother_node> = -             | not initial in coordination
    <DP_1 mother_node> = -        | not initial DP in coordination
    <DP_2 mother_node> = -        | not initial DP in coordination
    <DP conjoined> = +                 | to restrict recursion
    <DP_1 conjoined> = -
    <DP_2 conjoined> = +               | to require further recursion 
    <DP conjunction gloss> = <Conj gloss>  | require 'whether' as upper Conj
    <DP_2 conjunction gloss> = <Conj gloss>  | pass Conj info to DP_2 to correctly restrict Conj possible in recursion
    <DP head case_for_position> = <DP_2 head case_for_position> | case determined by
                                                      | position in sentence
    <DP_1 head case_for_position> = <DP head case_for_position>  | for apposition 22Jan03 CB
    <DP head case> = <DP_2 head case>     | non-final conjunct
    <DP_1 head case> = direct       | non-final conjuncts unmarked
    <DP head type pronoun> <= <DP_2 head type pronoun> | pronoun from final DP
    <DP head type proper> <= <DP_2 head type proper> | proper from final DP
    <DP head type no_head_N> <= <DP_2 head type no_head_N> | no_head_N from final DP
    <DP head type coordination> <= <DP_2 head type coordination>  |final overrules
    <DP_1 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP_2 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP head type comma> <= <DP_2 head type comma>
    <DP head type relcl> <= <DP_2 head type relcl>    | 24Jul03 CB
    <DP rule> = Mwhether

rule {DP option Mcomma - medial with 'comma'}
DP = DP_1 DP_2
    <DP head reflexive> = <DP_1 head reflexive> | pass reflexive info
    <DP head reflexive> = <DP_2 head reflexive> | pass reflexive info
    <DP head type coordination> = medial
    <DP_1 head type nonfinalcoordination> <= +  | for AdjP case 14Aug03 CB
    <DP head type DO_contraction> = -
    <DP head type modifier-final> = <DP_2 head type modifier-final>
    <DP head type case-marked> = -
    <DP_1 head type case-marked> = -
    <DP_2 head type case-marked> = -
    <DP_1 head type comma> = +
    <DP mother_node> = -             | not initial in coordination
    <DP_1 mother_node> = -        | not initial DP in coordination
    <DP_2 mother_node> = -        | not initial DP in coordination
    <DP conjoined> = +                 | to restrict recursion
    <DP_1 conjoined> = -
    <DP_2 conjoined> = +               | to require further recursion 
    <DP conjunction gloss> = ending  | require 'comma' as upper Conj
    <DP_2 conjunction gloss> = ending  | pass Conj info to DP_2 to correctly restrict Conj possible in recursion - comma
    <DP final_conjunction gloss> = <DP_2 final_conjunction gloss>
    <DP head case_for_position> = <DP_2 head case_for_position> | case determined by
                                                      | position in sentence
    <DP_1 head case_for_position> = <DP head case_for_position>  | for apposition 22Jan03 CB
    <DP head case> = <DP_2 head case>     | non-final conjunct
    <DP_1 head case> = direct       | non-final conjuncts unmarked
    <DP head type pronoun> <= <DP_2 head type pronoun> | pronoun from final DP
    <DP head type proper> <= <DP_2 head type proper> | proper from final DP
    <DP head type no_head_N> <= <DP_2 head type no_head_N> | no_head_N from final DP
    <DP head type coordination> <= <DP_2 head type coordination>  |final overrules
    <DP_1 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP_2 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP head type comma> <= <DP_2 head type comma>
    <DP head type relcl> <= <DP_2 head type relcl>    | 24Jul03 CB
    <DP rule> = Mcomma

|-****Coordinate DPs, final only
rule {DP option Fandor - final with 'and or'}
DP = DP_1 Conj Conj_1 DP_2
    <DP head reflexive> = <DP_1 head reflexive> | pass reflexive info
    <DP head reflexive> = <DP_2 head reflexive> | pass reflexive info
    <DP head type coordination> = +
    <DP_1 head type nonfinalcoordination> <= +  | for AdjP case 14Aug03 CB
    <DP_2 head type nonfinalcoordination> = -  | for AdjP case 14Aug03 CB
    <DP head type DO_contraction> = -
    <DP head type modifier-final> = <DP_2 head type modifier-final>
    <DP head type case-marked> = -
    <DP_1 head type case-marked> = -
    <DP_2 head type case-marked> = -
    <Conj gloss> = and
    <Conj_1 gloss> = or
    <Conj head type conjoins_DP> = +
    <Conj_1 head type conjoins_DP> = +
    <DP mother_node> = -             | not initial in coordination
    <DP_1 mother_node> = -        | not initial DP in coordination
    <DP_2 mother_node> = -        | not initial DP in coordination
    <DP conjoined> = +                 | to restrict recursion
    <DP_1 conjoined> = -
    <DP_2 conjoined> = -               | to stop further recursion
    {<DP conjunction gloss> = and
    /<DP conjunction gloss> = or    | require 'and' or 'or' as upper Conj
    }
    <DP head type pronoun> <= <DP_2 head type pronoun> | pronoun from final DP
    <DP head type proper> <= <DP_2 head type proper> | proper from final DP
    <DP head type no_head_N> <= <DP_2 head type no_head_N> | no_head_N from final DP
    <DP head type apposition> = <DP_2 head type apposition> | final DP gives apposition 31Mar03 CB
    <DP head type locative> = <DP_2 head type locative>  | final DP gives locative Jan03CB**
    <DP head case_for_position> = <DP_2 head case_for_position> | case determined by
                                                      | position in sentence
    <DP_1 head case_for_position> = <DP head case_for_position>  | for apposition 22Jan03 CB
    <DP head case> = <DP head case_for_position>
    <DP_1 head case> = direct      | initial conjuncts unmarked
    <DP_2 head case> = <DP_2 head case_for_position>  | final conjuncts have case
    <DP_1 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP_2 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP head type comma> <= <DP_2 head type comma>
    <DP head type relcl> <= <DP_2 head type relcl>    | 24Jul03 CB
    <DP rule> = Fandor

rule {DP option Fandwhether - final with 'and whether'}
DP = DP_1 Conj Conj_1 DP_2
    <DP head reflexive> = <DP_1 head reflexive> | pass reflexive info
    <DP head reflexive> = <DP_2 head reflexive> | pass reflexive info
    <DP head type coordination> = +
    <DP_1 head type nonfinalcoordination> <= +  | for AdjP case 14Aug03 CB
    <DP_2 head type nonfinalcoordination> = -  | for AdjP case 14Aug03 CB
    <DP head type DO_contraction> = -
    <DP head type modifier-final> = <DP_2 head type modifier-final>
    <DP head type case-marked> = -
    <DP_1 head type case-marked> = -
    <DP_2 head type case-marked> = -
    <Conj gloss> = and
    <Conj_1 gloss> = whether
    <Conj head type conjoins_DP> = +
    <Conj_1 head type conjoins_DP> = +
    <DP mother_node> = -             | not initial in coordination
    <DP_1 mother_node> = -        | not initial DP in coordination
    <DP_2 mother_node> = -        | not initial DP in coordination
    <DP conjoined> = +                 | to restrict recursion
    <DP_1 conjoined> = -
    <DP_2 conjoined> = -               | to stop further recursion
    <DP conjunction gloss> = <Conj_1 gloss>  | require 'whether' as upper Conj
    <DP head type pronoun> <= <DP_2 head type pronoun> | pronoun from final DP
    <DP head type proper> <= <DP_2 head type proper> | proper from final DP
    <DP head type no_head_N> <= <DP_2 head type no_head_N> | no_head_N from final DP
    <DP head type apposition> = <DP_2 head type apposition> | final DP gives apposition 31Mar03 CB
    <DP head type locative> = <DP_2 head type locative>  | final DP gives locative Jan03CB**
    <DP head case_for_position> = <DP_2 head case_for_position> | case determined by
                                                      | position in sentence
    <DP_1 head case_for_position> = <DP head case_for_position>  | for apposition 22Jan03 CB
    <DP head case> = <DP head case_for_position>
    <DP_1 head case> = direct      | initial conjuncts unmarked
    <DP_2 head case> = <DP_2 head case_for_position>  | final conjuncts have case
    <DP_1 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP_2 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP head type comma> <= <DP_2 head type comma>
    <DP head type relcl> <= <DP_2 head type relcl>    | 24Jul03 CB
    <DP rule> = Fandwhether

rule {DP option Fandalso - final with 'and also'}
DP = DP_1 Conj Conj_1 DP_2
    <DP head reflexive> = <DP_1 head reflexive> | pass reflexive info
    <DP head reflexive> = <DP_2 head reflexive> | pass reflexive info
    <DP head type coordination> = +
    <DP_1 head type nonfinalcoordination> <= +  | for Adj case info 14Aug03 CB
    <DP_2 head type nonfinalcoordination> = -  | for AdjP case 14Aug03 CB
    <DP head type DO_contraction> = -
    <DP head type modifier-final> = <DP_2 head type modifier-final>
    <DP head type case-marked> = -
    <DP_1 head type case-marked> = -
    <DP_2 head type case-marked> = -
    <Conj gloss> = and
    <Conj_1 gloss> = also
    <Conj head type conjoins_DP> = +
    <Conj_1 head type conjoins_DP> = +
    <DP mother_node> = -             | not initial in coordination
    <DP_1 mother_node> = -        | not initial DP in coordination
    <DP_2 mother_node> = -        | not initial DP in coordination
    <DP conjoined> = +                 | to restrict recursion
    <DP_1 conjoined> = -
    <DP_2 conjoined> = -               | to stop further recursion
    <DP final_conjunction gloss> = and  | pass info for plural agreement
    <DP conjunction gloss> = ending    | require comma as upper Conj
||    <DP conjunction gloss> = <Conj gloss>  | require 'and' as upper Conj
    <DP head type pronoun> <= <DP_2 head type pronoun> | pronoun from final DP
    <DP head type proper> <= <DP_2 head type proper> | proper from final DP
    <DP head type no_head_N> <= <DP_2 head type no_head_N> | no_head_N from final DP
    <DP head type apposition> = <DP_2 head type apposition> | final DP gives apposition 31Mar03 CB
    <DP head type locative> = <DP_2 head type locative>  | final DP gives locative Jan03CB**
    <DP head case_for_position> = <DP_2 head case_for_position> | case determined by
                                                      | position in sentence
    <DP_1 head case_for_position> = <DP head case_for_position>  | for apposition 22Jan03 CB
    <DP head case> = <DP head case_for_position>
    <DP_1 head case> = direct      | initial conjuncts unmarked
    <DP_2 head case> = <DP_2 head case_for_position>  | final conjuncts have case
    <DP_1 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP_2 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP head type comma> <= <DP_2 head type comma>
    <DP head type relcl> <= <DP_2 head type relcl>    | 24Jul03 CB
    <DP rule> = Fandalso

rule {DP option Fand - final with 'and'}
DP = DP_1 Conj DP_2
    <DP head reflexive> = <DP_1 head reflexive> | pass reflexive info
    <DP head reflexive> = <DP_2 head reflexive> | pass reflexive info
    <DP head type coordination> = +
    <DP_1 head type nonfinalcoordination> <= +  | for AdjP case 14Aug03 CB
    <DP_2 head type nonfinalcoordination> = -  | for AdjP case 14Aug03 CB
    <DP head type DO_contraction> = -
    <DP head type modifier-final> = <DP_2 head type modifier-final>
    <DP head type case-marked> = -
    <DP_1 head type case-marked> = -
    <DP_2 head type case-marked> = -
    <Conj gloss> = and
    <Conj head type conjoins_DP> = +
    <DP mother_node> = -             | not initial in coordination
    <DP_1 mother_node> = -        | not initial DP in coordination
    <DP_2 mother_node> = -        | not initial DP in coordination
    <DP conjoined> = +                 | to restrict recursion
    <DP_1 conjoined> = -
    <DP_2 conjoined> = -               | to stop further recursion
    <DP final_conjunction gloss> = and  | pass info for plural agreement
   {<DP conjunction gloss> = ending    | require comma as upper Conj
   /<DP conjunction gloss> = and         | require 'and' as upper Conj
   }
    <DP head type pronoun> <= <DP_2 head type pronoun> | pronoun from final DP
    <DP head type proper> <= <DP_2 head type proper> | proper from final DP
    <DP head type no_head_N> <= <DP_2 head type no_head_N> | no_head_N from final DP
    <DP head type apposition> = <DP_2 head type apposition> | final DP gives apposition 31Mar03 CB
    <DP head type locative> = <DP_2 head type locative>  | final DP gives locative Jan03CB**
    <DP head case_for_position> = <DP_2 head case_for_position> | case determined by
                                                      | position in sentence
    <DP_1 head case_for_position> = <DP head case_for_position>  | for apposition 22Jan03 CB
    <DP head case> = <DP head case_for_position>
    <DP_1 head case> = direct      | initial conjuncts unmarked
    <DP_2 head case> = <DP_2 head case_for_position>  | final conjuncts have case
    <DP_1 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP_2 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP head type comma> <= <DP_2 head type comma>
    <DP head type relcl> <= <DP_2 head type relcl>    | 24Jul03 CB
    <DP rule> = Fand

rule {DP option For - final with 'or'}
DP = DP_1 Conj DP_2
    <DP head reflexive> = <DP_1 head reflexive> | pass reflexive info
    <DP head reflexive> = <DP_2 head reflexive> | pass reflexive info
    <DP head type coordination> = +
    <DP_1 head type nonfinalcoordination> <= +  | for AdjP case 14Aug03 CB
    <DP_2 head type nonfinalcoordination> = -  | for AdjP case 14Aug03 CB
    <DP head type DO_contraction> = -
    <DP head type modifier-final> = <DP_2 head type modifier-final>
    <DP head type case-marked> = -
    <DP_1 head type case-marked> = -
    <DP_2 head type case-marked> = -
    <Conj gloss> = or
    <Conj head type conjoins_DP> = +
    <DP mother_node> = -             | not initial in coordination
    <DP_1 mother_node> = -        | not initial DP in coordination
    <DP_2 mother_node> = -        | not initial DP in coordination
    <DP conjoined> = +                 | to restrict recursion
    <DP_1 conjoined> = -
    <DP_2 conjoined> = -               | to stop further recursion
    <DP final_conjunction gloss> = or  | pass info for non-plural agreement
    <DP conjunction gloss> = ending    | require comma as upper Conj
    <DP head type pronoun> <= <DP_2 head type pronoun> | pronoun from final DP
    <DP head type proper> <= <DP_2 head type proper> | proper from final DP
    <DP head type no_head_N> <= <DP_2 head type no_head_N> | no_head_N from final DP
    <DP head type apposition> = <DP_2 head type apposition> | final DP gives apposition 31Mar03 CB
    <DP head type locative> = <DP_2 head type locative>  | final DP gives locative Jan03CB**
    <DP head case_for_position> = <DP_2 head case_for_position> | case determined by
                                                      | position in sentence
    <DP_1 head case_for_position> = <DP head case_for_position>  | for apposition 22Jan03 CB
    <DP head case> = <DP head case_for_position>
    <DP_1 head case> = direct      | initial conjuncts unmarked
    <DP_2 head case> = <DP_2 head case_for_position>  | final conjuncts have case
    <DP_1 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP_2 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP head type comma> <= <DP_2 head type comma>
    <DP head type relcl> <= <DP_2 head type relcl>    | 24Jul03 CB
    <DP rule> = For

|-*****
rule {DP option casePst - case-marked DP}
DP = DP_1 Case
    <DP head> = <DP_1 head>
    <DP conjoined> = <DP_1 conjoined>      | pass up info one level
    <DP mother_node> = <DP_1 mother_node>  | pass up info one level
    <DP head infl tense past> = +                                 
    <DP_1 head agr person third> = +       | third person only Feb2020
    <DP_1 head type comma> = -
    <DP_1 head type apposition> = -
    <DP_1 head type case-marked> = -        | to prevent double case marking
    <DP_1 head type DO_contraction> = -    
    <DP_1 head case_for_position> = direct  | to know normal case in apposition 20Jan03 CB  
    <DP_1> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP_1> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type comma> <= <Case head type comma>
    <DP head type case-marked> <= +              | now case-marked
    <DP head type compound> <= -            | can't compound if case-marked
    <DP head case> = direct           | redo case  to = CB 23May19 
    <DP rule> = casePst

rule {DP option caseNonPstExceptDef - case-marked DP}
DP = DP_1 Case
    <DP head> = <DP_1 head>
    <DP conjoined> = <DP_1 conjoined>      | pass up info one level
    <DP mother_node> = <DP_1 mother_node>  | pass up info one level
    <DP head infl tense past> = -                                 
    <DP_1 head agr person third> = +       | third person only Feb2020
   {<DP head type indefinite> = + 
   /<DP head type generic> = +                                 
   }                            
    <DP_1 head type comma> = -
    <DP_1 head type apposition> = -
    <DP_1 head type case-marked> = -        | to prevent double case marking
    <DP_1 head type DO_contraction> = -    
    <DP_1 head case_for_position> = direct  | to know normal case in apposition 20Jan03 CB  
    <DP_1> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP_1> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type comma> <= <Case head type comma>
    <DP head type case-marked> <= +              | now case-marked
    <DP head type compound> <= -            | can't compound if case-marked
    <DP head case> = direct           | redo case to = CB 23May19 
    <DP rule> = caseNonPstExceptDef

rule {DP option caseNonPstDef - case-marked DP}
DP = DP_1 Case
    <DP head> = <DP_1 head>
    <DP conjoined> = <DP_1 conjoined>      | pass up info one level
    <DP mother_node> = <DP_1 mother_node>  | pass up info one level
    <DP head infl tense past> = - 
    <DP_1 head agr person third> = +       | third person only Feb2020
    <DP head type indefinite> = -                                 
    <DP_1 head type comma> = -
    <DP_1 head type apposition> = -
    <DP_1 head type case-marked> = -        | to prevent double case marking
    <DP_1 head type DO_contraction> = -    
    <DP_1 head case_for_position> = oblique  | to know normal case in apposition 20Jan03 CB  
    <DP_1> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP_1> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type comma> <= <Case head type comma>
    <DP head type case-marked> <= +              | now case-marked
    <DP head type compound> <= -            | can't compound if case-marked
    <DP head case> = oblique            | redo case to = CB 23May19 
    <DP rule> = caseNonPstDef

rule {DP option case1and2pronouns - case-marked DP}
DP = DP_1 Case
    <DP head> = <DP_1 head>
    <DP conjoined> = <DP_1 conjoined>      | pass up info one level
    <DP mother_node> = <DP_1 mother_node>  | pass up info one level
    <DP head infl tense past> = - 
    <DP_1 head agr person third> = -       | 1st and 2nd person only Feb2020
    <DP_1 head type pronoun> = +           | 1st and 2nd person pron only Feb2020
    <DP head type indefinite> = -                                 
    <DP_1 head type comma> = -
    <DP_1 head type apposition> = -
    <DP_1 head type case-marked> = -        | to prevent double case marking
    <DP_1 head type DO_contraction> = -    
    <DP_1 head case_for_position> = objective  | to know normal case in apposition 20Jan03 CB 
    <DP_1> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP_1> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type comma> <= <Case head type comma>
    <DP head type case-marked> <= +              | now case-marked
    <DP head type compound> <= -            | can't compound if case-marked
    <DP_1 head case> = objective            | redo case to = CB 23May19 
    <DP rule> = case1and2pronouns

rule {DP option caseAppos - case-marked DP including apposition}
DP = DP_1 Case
    <DP head> = <DP_1 head>
    {
    <DP_1 head type apposition> = +    | 17Jan03  CB
    <DP_1 head type comma> = +
    /<DP_1 head type apposition> = namely  | 21Nov03 CB
    }
    <DP_1 head type case-marked> = -        | to prevent double case marking
    <DP_1 head type DO_contraction> = -    
    <DP_1 head case_for_position> = direct  | to know normal case in apposition 20Jan03 CB
    <DP_1 head case> = direct   | changed from case from Case 17Feb03 CB
    <DP head type case-marked> <= +              | now case-marked
    <DP head type compound> <= -            | can't compound if case-marked
    <DP_1> == ~[conjoined:+]     | apposition only, not coordination
    <DP rule> = caseAppos

| 16Jan03 RL Added this rule, moved to DP level 20Jan03 CB, split into 2 rules to avoid duplicate parses due to options in DP_2 when have PP instead 27Jan03 CB
rule {DP option Appos - Apposition, commas required} |e.g. John, the butcher, came.
DP = DP_1 DP_2
    <DP head> = <DP_1 head>           | 27Jan03CB
    <DP_1 head agr> = <DP_2 head agr>     | person and number agreement
    <DP head apposed> = <DP_2>    | pass up info for generic/refl 19Feb03 CB Name of feature changed Apr 2020CB
    <DP_1 head type comma> = +
    <DP_2 head type comma> = +
    <DP_2 head type apposition> = -  | allow stacking only one way 20Jan03 CB
    <DP_1 head type case-marked> = -     | case-marked above apposition only 20Jan03 CB
    <DP_2 head type case-marked> = -     | case-marked above apposition only 20Jan03 CB
    <DP_1 head type relative> = -    | N cannot have REL with following modifier
    <DP_2 head type DO_contraction> = -  | DO_contraction use 1contr rule
|    <DP_2 head type coordination> = -   | not allowing coordinate apposition |removed 18Mar03 CB
    <DP head case_for_position> = <DP_1 head case_for_position> | pass down in case of iteration 27Jan03 CB
    <DP_1 head case> = <DP head case_for_position> 
    <DP_2 head case> = <DP head case_for_position> 
    <DP_2 head infl polarity> = +       | Apposition phrase is not negative
    <DP_1> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP_1> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP_2> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP_2> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head reflexive> = <DP_2 head reflexive> | pass reflexive info
    <DP head type compound> <= <DP_2 head type compound>  | 04 Apr03 CB
    <DP head type apposition> <= +    | 17Jan03 CB
    <DP rule> = Appos

| generic/ref pn cannot be checked inside PP apposition
rule {DP option PPAppos - Apposition with PP, commas required}
DP = DP_1 PP
    <DP head> = <DP_1 head>           | 27Jan03CB
    <DP_1 head type comma> = +
    <PP head type comma> = +
    <DP_1 head type case-marked> = -     | case-marked above apposition only 20Jan03 CB
    <DP_1 head type relative> = -    | N cannot have REL with following modifier
    <DP head case_for_position> = <DP_1 head case_for_position> | pass down in case of iteration 27Jan03 CB
    <DP_1 head case> = <DP head case_for_position> 
    <PP head type sentential> = -
    <DP head reflexive> = <PP head reflexive> | pass reflexive info
    <DP_1> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP_1> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type compound> <= <PP head type compound>  | 04 Apr03 CB
    <DP head type apposition> <= +    | 17Jan03 CB
    <DP rule> = PPAppos
 
| for ygny type apposition/coordination/relativization, added 24Mar03 CB
rule {DP option namely - "ygny"-type apposition}
DP = DP_1 Conj DP_2
    <DP head> = <DP_1 head>
    <DP_1 head type case-marked> = -
    <DP_2 head type case-marked> = -
    <DP_1 head case> = <DP_2 head case>  | assume same case marking - Ron?? 
    <Conj gloss> = namely
    <DP conjoined> = +    | no coordination above ygny  changed from "= namely" Apr2020
    <DP_2 conjunction gloss> = namely   | to restrict interaction w/ coordination
    <DP head reflexive> = <DP_2 head reflexive> | pass reflexive info
    <DP head type apposition> <= namely    | 21Nov03 CB
    <DP_1 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP_2 head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <DP rule> = namely
   
rule {DP option relative_clause}
DP = DP_1 CP
    <DP head> = <DP_1 head>
    <DP_1 head type comma> = -
    <DP_1 head type relative> = +
    <CP head type root> = -
    <CP head type question> = -
    <CP head type conj_suffix> = -   | 03Apr03 CB
    <CP head type relcl> = +        | 21Nov03 CB
|    <DP_1 conjoined> = -             | not conjoined head 21Apr03 CB
    <DP head type relcl> <= +
    <DP head type comma> <= <CP head type comma>
    <DP_1> == ~[conjoined:+]     | not cojoined head
    <DP rule> = relative_clause

|rule added 28Jan03 CB
rule {DP option relcl2 - relative clause with no rel suffix, head by Pron, PropN, Dem, Deg, QP, or phrases}
DP = DP_1 CP
    <DP head> = <DP_1 head>
    <DP_1 head type comma> = -
    <DP_1 head type relative> = -    | rel suffix not required
    <DP_1 head type indefinite> = -  | (but can't be indefinite instead)
    {<DP_1 conjoined> = -             | if conjoined head 
    /<DP_1 conjoined> = +             | must be mother-node
     <DP_1 mother_node> = +
    }
    {<DP_1 head type proper> = +     | for proper noun heads
    /<DP_1 head type pronoun> = +          | or pronoun heads
    /<DP_1 head type suffix_Pn> = +        | or with suffix Pn **24Jul06 CB
    /<DP_1 head type no_head_N> = +        | or Dem, Deg or QP heads
     <DP_1 head type pronoun> = -
    /<DP_1 head type no_head_N> = -       | or phrases w/ final modifiers
     <DP_1 head type pronoun> = -
     <DP_1 head type modifier-final> = +
     <DP_1 head type modifier-initial> = -
    /<DP_1 head type no_head_N> = -       | or phrases w/ initial modifiers
     <DP_1 head type pronoun> = -
     <DP_1 head type modifier-final> = -
     <DP_1 head type modifier-initial> = +
    /<DP_1 head type no_head_N> = -       | or phrases w/ modifiers both sides
     <DP_1 head type pronoun> = -
     <DP_1 head type modifier-final> = +
     <DP_1 head type modifier-initial> = +
    }
    <CP head type root> = -
    <CP head type question> = -
    <CP head type conj_suffix> = -   | 03Apr03 CB
    <CP head type relcl> = +          | 21Nov03 CB
    <DP head type case-marked> = <DP_1 head type case-marked>
    <DP head type relcl> <= +
    <DP head type comma> <= <CP head type comma>
    <DP rule> = relcl2
    
|rule added 7Apr03 CB
rule {DP option relcl2+kh - relative clause with no rel suffix, with +kh suffixed to head}
DP = DP_1 IP
    <DP head> = <DP_1 head>
    <DP_1 head type comma> = -
    <DP_1 head type comp_suffix> = +
    <IP head type root> = -
    <IP head type question> = -
    <IP head type conj_suffix> = -   | 03Apr03 CB
    <IP head type initialP> = -      | no InitP allowed in IP 21Apr03 CB
    <IP head type relcl> = +          | 21Nov03 CB
    <DP head type case-marked> = <DP_1 head type case-marked>
|    <DP_1 conjoined> = -
|    {<DP_1 conjoined> = -             | if conjoined head     ***asking Ron
|    /<DP_1 conjoined> = +             | must be mother-node
|     <DP_1 mother_node> = +
|    }
    <DP relativeCl> = +
    <DP_1 relativeCl> = -              | not iterative 03Jun03 CB
    <DP head type relcl> <= +
    <DP head type comma> <= <IP head type comma>
    <DP head relativity conjoined> = <IP head type conjoined> | for compounding constraints with main V 20Oct03 CB
|?|    <DP head relativity compounds_with1> = <IP head type final-conjunct compounds_with1>
|?|    <DP head relativity compounds_with2> = <IP head type final-conjunct compounds_with2>
|?|    <DP head relativity compounds_with3> = <IP head type final-conjunct compounds_with3>
|?|    <DP head relativity compounds_with4> = <IP head type final-conjunct compounds_with4>
    <DP_1> == ~[conjoined:+]     | not conjoined head
    <DP rule> = relcl2+kh
    
rule {DP option 1 - no modifiers}
DP = D'
    <DP head> = <D' head>
    <DP head type case-marked> = -
    <DP conjoined> = -
    <DP rule> = 1

rule {DP option 1conjI - no modifiers, Conj initial}
DP = Conj D'
    <DP head> = <D' head>
    <DP head type case-marked> = -
    <DP conjoined> = -
    <DP head type coordination> = -    | not in DP coordination construction
    <DP head type initialP> = -               | restrict conjunctions here and in DP 
    <Conj head type comma> = -
    <Conj gloss> = also
    <Conj head type DP-initial> = +
    <DP rule> = 1conjI

rule {DP option 1conjIF - no modifiers, Conj initial, final}
DP = Conj D' Conj_2
    <DP head> = <D' head>
    <DP head type case-marked> = -
    <DP conjoined> = -
    <DP head type coordination> = -    | not in DP coordination construction
    <DP head type initialP> = -               | restrict conjunctions here and in DP 
    <D' head type relative> = -
    <D' head type comma> = -
    <Conj head type comma> = -
    <Conj gloss> = also
    <Conj head type DP-initial> = +
    <Conj_2 head type DP-final> = +
    <DP head type comma> <= <Conj_2 head type comma>
    <DP head type relative> <= <Conj_2 head type relative>
    <DP head type compound> <= -  | 04 Apr03 CB
    <DP rule> = 1conjIF

rule {DP option 1conjF - no modifiers, Conj final}
DP = D' Conj
    <DP head> = <D' head>
    <D' head type comma> = -
    <D' head type relative> = -
    <DP head type case-marked> = -
    <DP conjoined> = -
    <DP head type coordination> = -    | not in DP coordination construction
    <DP head type initialP> = -               | restrict conjunctions here and in DP 
    <Conj head type DP-final> = +
    <DP head type comma> <= <Conj head type comma>
    <DP head type relative> <= <Conj head type relative>
    <DP head type compound> <= -  | 04 Apr03 CB
    <Conj> == ~[gloss:namely]
    <DP rule> = 1conjF

rule {DP option 2a - modifiers initial}
DP = Deg_1 (Deg) D'       | Deg_1 is the negative particle "na", Deg is "alone"
    <DP head> = <D' head>
    <Deg head type comma> = -
    <Deg_1 head type comma> = -
    <Deg head type modifies_NP> = +
    <Deg_1 head type modifies_NP> = +
    <Deg_1 head infl polarity> = -
    <Deg head infl polarity> = +
    {<Deg head case> = direct     | initial modifiers not case-marked
     <Deg head type gen_initial> = -
    /<Deg head case> = genitive       | unless can take genitive initially
     <Deg head type gen_initial> = +    | 7Apr03 CB
    }
    {<Deg_1 head case> = direct     | initial modifiers not case-marked
     <Deg_1 head type gen_initial> = -
    /<Deg_1 head case> = genitive       | unless can take genitive initially
     <Deg_1 head type gen_initial> = +    | 7Apr03 CB
    }
    <DP head type case-marked> = -
    <DP conjoined> = -
    <DP head infl polarity> <= <Deg_1 head infl polarity>  | negative comes from Deg
    <DP rule> = 2a

rule {DP option 2aconjI - modifiers initial, Conj initial}
DP = Conj Deg_1 (Deg) D'  | Deg_1 is the negative particle "na", Deg is "alone"
    <DP head> = <D' head> 
    <Conj head type comma> = -
    <Deg head type comma> = -
    <Deg_1 head type comma> = -
    <Deg head type modifies_NP> = +
    <Deg_1 head type modifies_NP> = +
    <Deg_1 head infl polarity> = -
    <Deg head infl polarity> = +
    {<Deg head case> = direct     | initial modifiers not case-marked
     <Deg head type gen_initial> = -
    /<Deg head case> = genitive       | unless can take genitive initially
     <Deg head type gen_initial> = +    | 7Apr03 CB
    }
    {<Deg_1 head case> = direct     | initial modifiers not case-marked
     <Deg_1 head type gen_initial> = -
    /<Deg_1 head case> = genitive       | unless can take genitive initially
     <Deg_1 head type gen_initial> = +    | 7Apr03 CB
    }
    <DP head type case-marked> = -
    <DP conjoined> = -
    <DP head type coordination> = -    | not in DP coordination construction
    <DP head type initialP> = -               | restrict conjunctions here and in DP 
    <Conj gloss> = also
    <Conj head type DP-initial> = +
    <DP head infl polarity> <= <Deg_1 head infl polarity>  | negative comes from Deg
    <DP rule> = 2aconjI

rule {DP option 2aconjIF - modifiers initial, Conj initial, final}
DP = Conj Deg_1 (Deg) D' Conj_2   | Deg_1 is the negative "na", Deg is "alone"
    <DP head> = <D' head>
    <Conj head type comma> = -
    <Deg head type comma> = -
    <Deg_1 head type comma> = -
    <D' head type comma> = -
    <D' head type relative> = -
    <Deg head type modifies_NP> = +
    <Deg_1 head type modifies_NP> = +
    <Deg_1 head infl polarity> = -
    <Deg head infl polarity> = +
    {<Deg head case> = direct     | initial modifiers not case-marked
     <Deg head type gen_initial> = -
    /<Deg head case> = genitive       | unless can take genitive initially
     <Deg head type gen_initial> = +    | 7Apr03 CB
    }
    {<Deg_1 head case> = direct     | initial modifiers not case-marked
     <Deg_1 head type gen_initial> = -
    /<Deg_1 head case> = genitive       | unless can take genitive initially
     <Deg_1 head type gen_initial> = +    | 7Apr03 CB
    }
    <DP head type case-marked> = -
    <DP conjoined> = -
    <DP head type coordination> = -    | not in DP coordination construction
    <DP head type initialP> = -               | restrict conjunctions here and in DP 
    <Conj gloss> = also
    <Conj head type DP-initial> = +
    <Conj_2 head type DP-final> = +
    <DP head infl polarity> <= <Deg_1 head infl polarity>  | negative comes from Deg
    <DP head type comma> <= <Conj_2 head type comma>
    <DP head type relative> <= <Conj_2 head type relative>
    <DP head type compound> <= -  | 04 Apr03 CB
    <DP rule> = 2aconjIF

rule {DP option 2aconjF - modifiers initial, Conj final}
DP = Deg_1 (Deg) D' Conj  | Deg_1 is the negative particle "na", Deg is "alone"
    <DP head> = <D' head>
    <Deg head type comma> = -
    <Deg_1 head type comma> = -
    <D' head type comma> = -
    <D' head type relative> = -
    <Deg head type modifies_NP> = +
    <Deg_1 head type modifies_NP> = +
    <Deg_1 head infl polarity> = -
    <Deg head infl polarity> = +
    {<Deg head case> = direct     | initial modifiers not case-marked
     <Deg head type gen_initial> = -
    /<Deg head case> = genitive       | unless can take genitive initially
     <Deg head type gen_initial> = +    | 7Apr03 CB
    }
    {<Deg_1 head case> = direct     | initial modifiers not case-marked
     <Deg_1 head type gen_initial> = -
    /<Deg_1 head case> = genitive       | unless can take genitive initially
     <Deg_1 head type gen_initial> = +    | 7Apr03 CB
    }
    <DP head type case-marked> = -
    <DP conjoined> = -
    <DP head type coordination> = -    | not in DP coordination construction
    <DP head type initialP> = -               | restrict conjunctions here and in DP 
    <Conj head type DP-final> = +
    <DP head infl polarity> <= <Deg_1 head infl polarity>  | negative comes from Deg
    <DP head type comma> <= <Conj head type comma>
    <DP head type relative> <= <Conj head type relative>
    <DP head type compound> <= -  | 04 Apr03 CB
    <DP rule> = 2aconjF

rule {DP option 2b - modifier initial}
DP = Deg D'
    <DP head> = <D' head>
    <Deg head type comma> = -
    <Deg head type modifies_NP> = +
|    /<Deg head type modifies_NPrep> = +  | added for drst byrwn... 10Jul03 CB
|     <D' head case> = genitive           | removed for Ability 18 Mar2020
|    }
|    <Deg head agr number plural> = -   |commented off to combine rules **19Jul06 CB
    <Deg head case> = direct     | initial modifiers not case-marked
|     <Deg head type gen_initial> = -
|    /<Deg head case> = genitive       | unless can take genitive initially
|     <Deg head type gen_initial> = +    | 7Apr03 CB
|    }
    <DP head type case-marked> = -
    <DP conjoined> = -
    <Deg head infl polarity> = +
    <DP rule> = 2b

|Combined this rule with option 2b above since plurality does not come from Deg **19Jul06 CB
|rule {DP option 2bpl - modifier initial - plural}
|DP = Deg D'
|    <DP head> = <D' head>
|    <Deg head type comma> = -
|    <Deg head type modifies_NP> = +
|    <Deg head agr number plural> = +
|    {<Deg head case> = direct     | initial modifiers not case-marked
|     <Deg head type gen_initial> = -
|    /<Deg head case> = genitive       | unless can take genitive initially
|     <Deg head type gen_initial> = +    | 7Apr03 CB
|    }
|    <DP head type case-marked> = -
|    <DP conjoined> = -
|    <Deg head infl polarity> = +
|    <DP head agr number> <= <Deg head agr number>  | plurality comes from Deg
|    <DP rule> = 2bpl

rule {DP option 2bconjI - modifier initial, Conj initial}
DP = Conj Deg D'
    <DP head> = <D' head>
    <Conj head type comma> = -
    <Deg head type comma> = -
    <Deg head type modifies_NP> = +
    <Deg head agr number plural> = -
    {<Deg head case> = direct     | initial modifiers not case-marked
     <Deg head type gen_initial> = -
    /<Deg head case> = genitive       | unless can take genitive initially
     <Deg head type gen_initial> = +    | 7Apr03 CB
    }
    <DP head type case-marked> = -
    <DP conjoined> = -
    <DP head type coordination> = -    | not in DP coordination construction
    <DP head type initialP> = -               | restrict conjunctions here and in DP 
    <Conj gloss> = also
    <Conj head type DP-initial> = +
    <Deg head infl polarity> = +
    <DP rule> = 2bconjI

rule {DP option 2bconjIpl - plural modifier initial, Conj initial}
DP = Conj Deg D'
    <DP head> = <D' head>
    <Conj head type comma> = -
    <Deg head type comma> = -
    <Deg head type modifies_NP> = +
    <Deg head agr number plural> = +
    {<Deg head case> = direct     | initial modifiers not case-marked
     <Deg head type gen_initial> = -
    /<Deg head case> = genitive       | unless can take genitive initially
     <Deg head type gen_initial> = +    | 7Apr03 CB
    }
    <DP head type case-marked> = -
    <DP conjoined> = -
    <DP head type coordination> = -    | not in DP coordination construction
    <DP head type initialP> = -               | restrict conjunctions here and in DP 
    <Conj gloss> = also
    <Conj head type DP-initial> = +
    <Deg head infl polarity> = +
    <DP head agr number> <= <Deg head agr number>  | plurality comes from Deg
    <DP rule> = 2bconjIpl

rule {DP option 2bconjIF - modifier initial, Conj initial, final}
DP = Conj Deg D' Conj_2
    <DP head> = <D' head>
    <Conj head type comma> = -
    <Deg head type comma> = -
    <D' head type comma> = -
    <D' head type relative> = -
    <Deg head type modifies_NP> = +
    <Deg head agr number plural> = -
    {<Deg head case> = direct     | initial modifiers not case-marked
     <Deg head type gen_initial> = -
    /<Deg head case> = genitive       | unless can take genitive initially
     <Deg head type gen_initial> = +    | 7Apr03 CB
    }
    <DP head type case-marked> = -
    <DP conjoined> = -
    <DP head type coordination> = -    | not in DP coordination construction
    <DP head type initialP> = -               | restrict conjunctions here and in DP 
    <Conj gloss> = also
    <Conj head type DP-initial> = +
    <Conj_2 head type DP-final> = +
    <Deg head infl polarity> = +
    <DP head type comma> <= <Conj_2 head type comma>
    <DP head type relative> <= <Conj_2 head type relative>
    <DP head type compound> <= -  | 04 Apr03 CB
    <DP rule> = 2bconjIF

rule {DP option 2bconjIFpl - plural modifier initial, Conj initial, final}
DP = Conj Deg D' Conj_2
    <DP head> = <D' head>
    <Conj head type comma> = -
    <Deg head type comma> = -
    <D' head type comma> = -
    <D' head type relative> = -
    <Deg head type modifies_NP> = +
    <Deg head agr number plural> = +
    {<Deg head case> = direct     | initial modifiers not case-marked
     <Deg head type gen_initial> = -
    /<Deg head case> = genitive       | unless can take genitive initially
     <Deg head type gen_initial> = +    | 7Apr03 CB
    }
    <DP head type case-marked> = -
    <DP conjoined> = -
    <DP head type coordination> = -    | not in DP coordination construction
    <DP head type initialP> = -               | restrict conjunctions here and in DP 
    <Conj gloss> = also
    <Conj head type DP-initial> = +
    <Conj_2 head type DP-final> = +
    <Deg head infl polarity> = +
    <DP head type comma> <= <Conj_2 head type comma>
    <DP head type relative> <= <Conj_2 head type relative>
    <DP head type compound> <= -  | 04 Apr03 CB
    <DP head agr number> <= <Deg head agr number>  | plurality comes from Deg
    <DP rule> = 2bconjIFpl

rule {DP option 2bconjF - modifier initial, Conj final}
DP = Deg D' Conj
    <DP head> = <D' head>
    <Deg head type comma> = -
    <D' head type comma> = -
    <D' head type relative> = -
    <Deg head type modifies_NP> = +
    <Deg head agr number plural> = -
    {<Deg head case> = direct     | initial modifiers not case-marked
     <Deg head type gen_initial> = -
    /<Deg head case> = genitive       | unless can take genitive initially
     <Deg head type gen_initial> = +    | 7Apr03 CB
    }
    <DP head type case-marked> = -
    <DP conjoined> = -
    <DP head type coordination> = -    | not in DP coordination construction
    <DP head type initialP> = -               | restrict conjunctions here and in DP 
    <Conj head type DP-final> = +
    <Deg head infl polarity> = +
    <DP head type comma> <= <Conj head type comma>
    <DP head type relative> <= <Conj head type relative>
    <DP head type compound> <= -  | 04 Apr03 CB
    <DP rule> = 2bconjF

rule {DP option 2bconjFpl - plural modifier initial, Conj final}
DP = Deg D' Conj
    <DP head> = <D' head>
    <Deg head type comma> = -
    <D' head type comma> = -
    <D' head type relative> = -
    <Deg head type modifies_NP> = +
    <Deg head agr number plural> = +
    {<Deg head case> = direct     | initial modifiers not case-marked
     <Deg head type gen_initial> = -
    /<Deg head case> = genitive       | unless can take genitive initially
     <Deg head type gen_initial> = +    | 7Apr03 CB
    }
    <DP head type case-marked> = -
    <DP conjoined> = -
    <DP head type coordination> = -    | not in DP coordination construction
    <DP head type initialP> = -               | restrict conjunctions here and in DP 
    <Conj head type DP-final> = +
    <Deg head infl polarity> = +
    <DP head type comma> <= <Conj head type comma>
    <DP head type relative> <= <Conj head type relative>
    <DP head type compound> <= -  | 04 Apr03 CB
    <DP head agr number> <= <Deg head agr number>  | plurality comes from Deg
    <DP rule> = 2bconjFpl

rule {DP option 2z - modifiers final}
DP = D' Deg            
    <DP head> = <D' head>
    <D' head type comma> = -
    <D' head type relative> = -
    <Deg head type modifies_NP> = +
    <Deg head infl polarity> = +
    <Deg head type DP-final> = +
    <Deg head agr> = <D' head agr>
    <Deg head case> = direct     | Deg not marked for case
    <DP head type case-marked> = -
    <DP conjoined> = -
    <DP head type comma> <= <Deg head type comma>
    <DP head type compound> <= -  | 04 Apr03 CB
    <DP rule> = 2z

rule {DP option 2zconjI - modifiers final, Conj initial}
DP = Conj D' Deg
    <DP head> = <D' head>
    <Conj head type comma> = -
    <D' head type comma> = -
    <D' head type relative> = -
    <Deg head type modifies_NP> = +
    <Deg head infl polarity> = +
    <Deg head type DP-final> = +
    <Deg head agr> = <D' head agr>
    <Deg head case> = direct     | Deg not marked for case
    <DP head type case-marked> = -
    <DP conjoined> = -
    <DP head type coordination> = -    | not in DP coordination construction
    <DP head type initialP> = -               | restrict conjunctions here and in DP 
    <Conj gloss> = also
    <Conj head type DP-initial> = +
    <DP head type comma> <= <Deg head type comma>
    <DP head type relative> <= <Deg head type relative>
    <DP head type compound> <= -  | 04 Apr03 CB
    <DP rule> = 2zconjI

rule {DP option 2zconjIF - modifiers final, Conj initial, final}
DP = Conj D' Deg Conj_2
    <DP head> = <D' head>
    <Conj head type comma> = -
    <Deg head type comma> = -
    <D' head type comma> = -
    <D' head type relative> = -
    <Deg head type relative> = -
    <Deg head type modifies_NP> = +
    <Deg head infl polarity> = +
    <Deg head type DP-final> = +
    <Deg head agr> = <D' head agr>
    <Deg head case> = direct     | Deg not marked for case
    <DP head type case-marked> = -
    <DP conjoined> = -
    <DP head type coordination> = -    | not in DP coordination construction
    <DP head type initialP> = -               | restrict conjunctions here and in DP 
    <Conj gloss> = also
    <Conj head type DP-initial> = +
    <Conj_2 head type DP-final> = +
    <DP head type comma> <= <Conj_2 head type comma>
    <DP head type relative> <= <Conj_2 head type relative>
    <DP head type compound> <= -  | 04 Apr03 CB
    <DP rule> = 2zconjIF

rule {DP option 2zconjF - modifiers final, Conj final}
DP = D' Deg Conj
    <DP head> = <D' head>
    <Deg head type comma> = -
    <D' head type comma> = -
    <D' head type relative> = -
    <Deg head type relative> = -
    <Deg head type modifies_NP> = +
    <Deg head infl polarity> = +
    <Deg head type DP-final> = +
    <Deg head agr> = <D' head agr>
    <Deg head case> = direct     | Deg not marked for case
    <DP head type case-marked> = -
    <DP conjoined> = -
    <DP head type coordination> = -    | not in DP coordination construction
    <DP head type initialP> = -               | restrict conjunctions here and in DP 
    <Conj head type DP-final> = +
    <DP head type comma> <= <Conj head type comma>
    <DP head type relative> <= <Conj head type relative>
    <DP head type compound> <= -  | 04 Apr03 CB
    <DP rule> = 2zconjF

|-********************************************************
|rules split 29Jan03 CB to deal with phrases for relcl2
rule {D' option 4a - no modifiers}
D' = NP
    <D' head> = <NP head>
    <D' rule> = 4a

rule {D' option 4aDem - only demonstratives, initial}   
D' = Dem NP
    <D' head> = <NP head>
    <Dem head type comma> = -
    <Dem head type comp_suffix> = -  | head relcl 7Apr03 CB
    <Dem head case> = direct   | Dem unmarked for case in Gilaki/Balochi when a modifier
    <NP head type generic> <= -     | generic nouns become non-generic with Dem  8Jan2020 CB
    <D' head type wh> <= <Dem head type wh>
    <D' head infl polarity> <= <Dem head infl polarity>
    <D' head type modifier-initial> <= +  | for relcl2 constraint 29Jan03 CB
    <D' rule> = 4a

|-*********************************************************
rule {NP option 1a - no possessor}
NP = {N'' / N'}
    <NP head> = <N'' head>
    <NP head> = <N' head>
|    {<NP head type genitive_suffix> = -   | if +, possessor required, eliminates NPreps
|    /<NP head type genitive_suffix> = +
|     <NP head type locative> = +          | 0May19 CB locatives are genitive
|    }                                     | testing removal 20Aug2019
     <NP rule> = 1a

rule {NP option 1bposs - no separate marker, possessor final}
NP = {N'' / N'} DP
    <NP head> = <N'' head>
    <NP head> = <N' head>
    <NP head type NPrep> = -        | **22Jul06 CB NPrep use 1bNPrep
    <NP head type no_head_N> = -    | to disallow Num, Q as having possessors Mar2020
    <DP head type apposition> = -   | apposition to whole DP, not just possessor 20Jan03 CB 
    <DP head type case-marked> = -           | possessor not separately case-marked 20Jan03 CB
    <DP head type no_head_N> = -    | to disallow Num, Q as possessors 14Jul03
    <N' head type comma> = -
    <N'' head type comma> = -
    <N' head type pronoun> = -     | pronouns do not have noun possessors Apr 2020
    <N'' head type pronoun> = -    | pronouns do not have noun possessors Apr 2020
    <N' head type relative> = -    | N cannot have REL with following modifier
    <N'' head type relative> = -    | N cannot have REL with following modifier
    <N' head type temporal> = -     | possessed nouns are not temporal APr2020
    <N'' head type temporal> = -     | possessed nouns are not temporal APr2020
    <DP head type temporal> = -     | possessors are not temporal APr2020
    <DP head type DO_contraction> = -  | DO_contraction use 1contr rule
||    <DP head type coordination> = -   | not allowing coordinate possessors |Genitive 3 has 22May2019 CB
    <DP head case_for_position> = genitive  | to know normal case for conjoined DPs
    <DP head case> = genitive          | possessor is genitive case
|   {<DP head case> = genitive          | possessor is genitive case
|   /<DP head type genitive_suffix> = +  | took genitive case off genitive_suffix for other issues, so need |this
|   }                                    | for genitive possessors  16Aug2019
    <DP head infl polarity> = +       | possessors are not negative
    <DP head type relcl> = -         | no relcl within possessor 28Jan03CB
    <NP head possessor> = <DP>
    <N' head case> = <NP head case_for_position>
    <N'' head case> = <NP head case_for_position>
    <NP head reflexive> = <DP head reflexive> | pass reflexive info to possessor
    <NP head type modifier-final> <= +   | was for Gilaki to handle genitive case required with final modifiers
    <DP> == ~[cat:Num]             | numbers can't be possessors  
    <NP head type indefinite> <= <DP head type indefinite>
    <NP head type relative> <= <DP head type relative>
    <NP head type comma> <= <DP head type comma>      | needed  17Jan03 CB
    <NP head type compound> <= <DP head type compound>  | 04Apr03 CB
    <NP rule> = 1bposs

|This rule needed???  trying removal 20 AUG2019
|rule added **22Jul06 CB to deal with differences with NPrep vs possessors, e.g. negative objects
|rule {NP option 1bNPrep - NPrep object final}
|NP = {N'' / N'} DP
|    <NP head> = <N'' head>
|    <NP head> = <N' head>
|    <NP head type NPrep> = +
|    <DP head type apposition> = -   | apposition to whole DP, not just object 20Jan03 CB 
|    <DP head type case-marked> = -           | object not separately case-marked 20Jan03 CB
|    <DP head type no_head_N> = -    | to disallow Num, Q as objects 14Jul03
|    <N' head type comma> = -
|    <N'' head type comma> = -
|    <N' head type relative> = -    | N cannot have REL with following modifier
|    <N'' head type relative> = -    | N cannot have REL with following modifier
|    <DP head type DO_contraction> = -  | DO_contraction use 1contr rule
|    <DP head case_for_position> = direct  | to know normal case for conjoined DPs
|    {<DP head case> = direct          | changed to direct
|     <DP head type pronoun> = -
|     <DP head type genitive_suffix> = -
|    /<DP head case> = genitive           | except for pronoun objects
|     <DP head type pronoun> = +
|     <DP head type genitive_suffix> = -
|    /<DP head case> = genitive           | or when has genitive_suffix
|     <DP head type genitive_suffix> = +
|    }
|    <DP head type relcl> = -         | no relcl within object 28Jan03CB
|    <NP head object> = <DP>
|    <N' head case> = <NP head case_for_position>
|    <N'' head case> = <NP head case_for_position>
|    <NP head reflexive> = <DP head reflexive> | pass reflexive info to object
|    <NP head type modifier-final> <= +   | to handle genitive case required with final modifiers
|    <DP> == ~[cat:Num]             | numbers can't be objects 
|    <NP head type indefinite> <= <DP head type indefinite>
|    <NP head type relative> <= <DP head type relative>
|    <NP head type comma> <= <DP head type comma>      | needed  17Jan03 CB
|    <NP head type compound> <= <DP head type compound>  | 04Apr03 CB
|    <NP rule> = 1bNPrep

rule {NP option 1contr - no separate marker, DO_contraction possessor final}
NP = {N'' / N'} DP
    <NP head> = <N'' head>
    <NP head> = <N' head>
    <N'' head type comma> = -
    <N' head type comma> = -
    <N'' head type relative> = -    | N cannot have REL with following modifier
    <DP head type DO_contraction> = +  | DO_contraction
    <DP head case> = genitive       | specially marked for Gilaki/Balochi transfer
    <DP head infl polarity> = +       | possessors are not negative
    <DP head type relcl> = -         | no relcl within possessor 28Jan03CB
    <DP head type coordination> = -
    <NP head possessor> = <DP>
    <N' head case> = <NP head case_for_position>
    <N'' head case> = <NP head case_for_position>
    <N' head type DO_contraction> = -    | to eliminate double contractions
    <N'' head type DO_contraction> = -   | to eliminate double contractions
    <NP head reflexive> = <DP head reflexive> | pass reflexive info to possessor
    <NP head type modifier-final> <= +   | to handle genitive case required with final modifiers
    <NP head type DO_contraction> <= <DP head type DO_contraction>   | for contraction form of possessor
    <NP head case> <= <DP head case>  | accusative case comes from DO_contraction
    <NP head type indefinite> <= <DP head type indefinite>
    <NP head type relative> <= <DP head type relative>
    <NP head type comma> <= <DP head type comma>
    <NP head type compound> <= <DP head type compound>  | 04Apr03 CB
    <NP rule> = 1contr

| removed 28Apr2020 needed???
|rule {NP option 6a - non-nominal heads}
|NP = { Deg / QP} | RL Apr 2020 took out "Dem /"
||    <NP head> = <Dem head>
|    <NP head> = <Deg head>
|    <NP head> = <QP head>
|    <QP head type human> = + | RL 11Dec02 Force an NP that consists only of a QP to be human |so that we don't get two identical parses at the IP level (one for 3rd sg and one for 3rd pl |subject)
|    <Deg head type quantifier> = +
|    <Deg head case> = direct       | RL 6Apr03 A degree word that stands alone can't have |genitive suffix. This eliminates 2 extra parses from Acts 13:20a.
|    <Deg head type gen_initial> = -    | RL 9May03 Likewise a degree word that takes a |genitive can't stand alone.
||    <Dem head type wh > = -        |- so "which" not separate
|    <NP head type modifier-final> = -
|    <NP head type modifier-initial> = -
|    <NP head type no_head_N> = +        | to disallow compound V with neg alone
|    <NP rule> = 6a

| removed 28Apr2020 needed???
|rule {NP option 6aPP - non-nominal heads, with partitive PP after}
|NP = { Deg / QP} PP | RL Apr 2020 took out "Dem /"
||    <NP head> = <Dem head>
|    <NP head> = <Deg head>
|    <NP head> = <QP head>
|    <NP head reflexive> = <PP head reflexive> | pass reflexive info to PP
||    <Dem head type comma> = -
|    <Deg head type comma> = -
|    <QP head type comma> = -
||    <Dem head type relative> = -
|    <Deg head type relative> = -
|    <QP head type relative> = -
|    <Deg head type quantifier> = +
||    <Dem head type wh > = -        |- so "which" not separate
|    <PP head type stranded> = -            |- PP must have overt complement
|    <PP head type sentential> = -    |- sentential not within NP
|    <NP head type modifier-final> = -
|    <NP head type modifier-initial> = -
|    <NP head type no_head_N> = +        | to disallow compound V with neg alone
|    <NP head type relative> <= <PP head type relative>
|    <NP head type comma> <= <PP head type comma>
|    <PP head object head type> == [modifier-final:+] -> ~[compound:+]  | PPs with modified |objects whose final element is marked compound, must compound 16Jul03 CB
|    <PP head> == ~[rootgloss:for]      | PP not benefactor 24Jul03 CB
|    <NP rule> = 6aPP

rule {NP option 6apn - NP=Pn}
NP = Pron
    <NP head> = <Pron head>
    <NP head type reflexivity> = -
    <NP rule> = 6apn

rule {NP option 6apnreflex - NP=ReflexivePn}
NP = Pron
    <NP head> = <Pron head>
    <NP head type reflexivity> = +
    <Pron head agr> = <NP head reflexive head agr> |enforce agreement
||    <NP head reflexive> = <Pron> |enforce agreement won't run - causes cycle WOrk on.
    <NP rule> = 6apnreflex

rule {NP option 6aempreflex - NP=Pn + ReflexivePn} | emphatic with pers num agreement
NP = Pron_1 Pron_2
    <NP head> = <Pron_2 head>
    <Pron_1 head type reflexivity> = -
    <Pron_2 head type reflexivity> = +
    <Pron_1 head case> = direct           | keeping Pron_1 unmarked for case, we expect case on Pron_2 when needed
    <Pron_1 head agr> = <Pron_2 head agr>
    <Pron_2 head agr> = <NP head reflexive head agr> |enforce agreement
    <NP rule> = 6aempreflex

|-********************************************************
rule {N'' option 1 - QPs initial}
N'' = QP N'
    <N'' head> = <N' head>
    <QP head type comma> = -
    <QP head case> = direct    | initial modifiers unmarked for case
    <N' head type object_agr_suffix> = -   |CB 24May19   no object agr
    <N'' head agr number> <= <QP head agr number>
    <N'' head type indefinite> <= <QP head type indefinite> | to make nouns preceded by one to pass indefinite feature up.
    <N' head type modifier-initial> <= +  | for relcl2 constraint 28Jan03 CB
    <N'' rule> = 1

rule {N'' option 2 - QPs final}
N'' = N' QP
    <N'' head> = <N' head>
    <QP head agr number> = <N' head agr number>
    <N' head type comma> = -
    <N' head type relative> = -     | N cannot have REL with following modifier
    <N'' head case> = <N'' head case_for_position>
    <QP head case> = direct   
|    <QP head type ordinal> = +
    <N' head type object_agr_suffix> = -   |CB 24May19   no object agr
    <N'' head type modifier-final> <= +   | to handle genitive case required with final modifiers
    <N' head type relative> <= <QP head type relative>
    <N'' head type comma> <= <QP head type comma>
    <N'' head type compound> <= -  | 04Apr03 CB
    <N'' rule> = 2

|-********************************************************
rule {N' option 1a - AdjP initial, recursive}
N' = AdjP N'_2
    <N' head> = <N'_2 head>
    <AdjP head case> = direct   | initial modifiers unmarked for case
    <AdjP head type DP-initial> = +
    <AdjP head type attributive> = + | 8May19 RL CB here as well as AdjP final true?
|    <AdjP head type ordinal> = -     | testing this with genitive.txt
    <AdjP head type comma> = -
    <N'_2 head type object_agr_suffix> = -   |CB 24May19   no object agr
    <N' head type modifier-initial> <= +  | for relcl2 constraint 28Jan03 CB
    <N' rule> = 1a

rule {N' option 1b - AdjP final, recursive}
N' = N'_2 AdjP
    <N' head> = <N'_2 head>
    <AdjP head type DP-final> = +
    <AdjP head type attributive> = + | 8May19 RL
    <N'_2 head type comma> = -   
    <N' head case> = <N' head case_for_position>
    <N' head type nonfinalcoordination> = -  | coordination use next rule
    <N' head type relative> = -     | N cannot have REL with following modifier
    <N' head type modifier-final> <= +   | to handle genitive case required with final modifiers
|    <N' head type genitive_suffix> <= <AdjP head type genitive_suffix> | N marking can be overridden by AdjP, if AdjP also marked then another modifier required.
    {<AdjP head case> = direct             | unmarked for case 14Aug03 CB
     <AdjP head type genitive_suffix> = -
    /<AdjP head type genitive_suffix> = +        | unless has genitive_suffix
     <AdjP head case> = genitive
    }
    <N'_2 head type object_agr_suffix> = -   |CB 24May19   no object agr
    <N' head type indefinite> <= <AdjP head type indefinite>
    <N' head type relative> <= <AdjP head type relative>
    <N' head type comma> <= <AdjP head type comma>
    <N' head type compound> <= <AdjP head type compound>  | 04Apr03 CB
    <N' rule> = 1b


rule {N' option 1bcoord - AdjP final, recursive, for non-final coordination}
N' = N'_2 AdjP
    <N' head> = <N'_2 head>
    <AdjP head type DP-final> = +
    <AdjP head type attributive> = + | 8May19 RL
    <N'_2 head type comma> = -
    <N' head case> = <N' head case_for_position>
    <N' head type nonfinalcoordination> = +
    <N' head type coordination> = +
    {<AdjP head case> = direct             | unmarked for case 14Aug03 CB
     <AdjP head type genitive_suffix> = -
    /<AdjP head type genitive_suffix> = +        | unless has genitive_suffix
     <AdjP head case> = genitive
    }
    <N' head type relative> = -     | N cannot have REL with following modifier
    <N'_2 head type object_agr_suffix> = -   |CB 24May19   no object agr
    <N' head type modifier-final> <= +   | to handle genitive case required with final modifiers
|    <N' head type genitive_suffix> <= <AdjP head type genitive_suffix> | N marking can be overridden by AdjP, if AdjP also marked then another modifier required.
    <N' head type indefinite> <= <AdjP head type indefinite>
    <N' head type relative> <= <AdjP head type relative>
    <N' head type comma> <= <AdjP head type comma>
    <N' head type compound> <= <AdjP head type compound>  | 04Apr03 CB
    <N' rule> = 1bcoord

|09-APR-04 added for participle - need to noload any Adj entries derived from V+participle **20Jul06 CB Not restricting this type of participle so constraint removed.
rule {N' option 2b - VPart final, recursive}
N' = N'_2 V
    <N' head> = <N'_2 head>
    <N'_2 head type comma> = -
    <N'_2 head case> = <N' head case_for_position>
    <N' head type nonfinalcoordination> = -  | coordination use next rule
    <V head type participle> = +
    <V head case> = direct        | ??
    <N' head type relative> = -     | N cannot have REL with following modifier
    <N' head type modifier-final> <= +   | to handle genitive case required with final modifiers
|    <N' head type genitive_suffix> <= <V head type genitive_suffix> | N marking can be overridden by V, if V also marked then another modifier required.
    <N' head type indefinite> <= -
    <N' head type relative> <= -
    <N' head type comma> <= <V head type comma>
    <N' head type compound> <= - 
    <V> == ~[rootgloss:become]         | Sdn does not form participle adjectives 13-APR-04
    <N' rule> = 2b

|09-APR-04 added for participle **20Jul06 CB Not restricting this type of participle so constraint removed.
rule {N' option 2bcoord - VPart final, recursive, for non-final coordination}
N' = N'_2 V
    <N' head> = <N'_2 head>
    <N'_2 head type comma> = -
    <N'_2 head case> = <N' head case_for_position>
    <N' head type nonfinalcoordination> = +
    <N' head type coordination> = +
    <V head type participle> = +
    <V head case> = direct             | unmarked for case 14Aug03 CB
    <N' head type relative> = -     | N cannot have REL with following modifier
    <N' head type modifier-final> <= +   | to handle genitive case required with final modifiers
    <N' head type genitive_suffix> <= <V head type genitive_suffix> | N marking can be overridden by V, if V also marked then another modifier required.
    <N' head type indefinite> <= -
    <N' head type relative> <= -
    <N' head type comma> <= <V head type comma>
    <N' head type compound> <= - 
    <V> == ~[rootgloss:become]         | Sdn does not form participle adjectives 13-APR-04
    <N' rule> = 2bcoord

| try eliminating this rule, seldom needed 19Feb03  12Aug2019 trying for Balach with brothers
| removed Apr2020, allowing with PP as adjoined PP instead, verb has singular agreement
|rule {N' option 3bPP - noun, PP final}
|N' = N PP
|    <N' head> = <N head>
|    <N' head rootgloss> = <N rootgloss>  |for compounding constraint 10Jul03
|    <PP head rootgloss> = with
|    <PP head type stranded> = -         |- P must have overt complement
|    <PP head type sentential> = -       |- sentential not within NP
|    <N head type comma> = -
|    <N head type copular_suffix> = -    | Apr2020
|    <N' head type no_head_N> = -
|    <N' head reflexive> = <PP head reflexive> | pass reflexive info to PP
|    <N' head type relative> = -    | N cannot have REL with following modifier
|    <N' head type relative> <= <PP head type relative>
|    <N' head type comma> <= <PP head type comma>
|    <N' head type compound> <= <PP head type compound>  | 17Jan03 CB
|    <N' rule> = 3bPP
    
rule {N' option 3b - noun}
N' = N
    <N' head> = <N head>
    <N' head rootgloss> = <N rootgloss>  |for compounding constraint 10Jul03
    <N' head participle> = none           | for participle constraint 12-APR-04
    <N' head subject head agr> = none         | testing 28May19 ***
    <N' head type atributive> = -       | testing 28May19 ***
    <N' head type no_head_N> = -
    <N' rule> = 3b

rule {N' option conj - conjoined nouns}
N' =  (N_3 Conj_2) N_2 Conj_1 N_1
    <N' head> = <N_1 head>
    <N' head rootgloss> = <N_2 rootgloss>  |for compounding constraint 10Jul03
    <N' head participle> = none           | for participle constraint 12-APR-04
    <N_2 head case> = direct
    <N_3 head case> = direct
    <Conj_2 gloss> = and
    <Conj_1 gloss> = and
    <N' conjoined> = +   | to prevent recursion
    <N_1 conjoined> = -
    <N_2 conjoined> = -
    <N_3 conjoined> = -
    <N' head type no_head_N> = -
    <N' head type genitive_suffix> <= +   | to force following modifier
    <N' rule> = conj

|added 09Jul03 CB for compound infinitives
rule {N' option compound}
N' = N_1 N
    <N' head> = <N head>
    <N' head rootgloss> = <N rootgloss>   |for compounding constraint 10Jul03
    <N' head participle> = none           | for participle constraint 12-APR-04
    <N_1 head case> = direct
    <N_1 head type comma> = -
    <N_1 head type compound> = +
    <N head infl finite> = -
    <N' head type no_head_N> = -
   {<N_1 head type compounds_with1> = <N rootgloss>
   /<N_1 head type compounds_with2> = <N rootgloss>
   /<N_1 head type compounds_with3> = <N rootgloss>
   /<N_1 head type compounds_with4> = <N rootgloss>}
    <N' rule> = compound

|added 11Dec03 CB for compound infinitives with Adj
rule {N' option compoundAdj}
N' = Adj N
    <N' head> = <N head>
    <N' head rootgloss> = <N rootgloss>   |for compounding constraint 10Jul03
    <N' head participle> = none           | for participle constraint 12-APR-04
    <Adj head case> = direct
    <Adj head type comma> = -
    <Adj head type compound> = +
    <N head infl finite> = -
    <N' head type no_head_N> = -
   {<Adj head type compounds_with1> = <N rootgloss>
   /<Adj head type compounds_with2> = <N rootgloss>
   /<Adj head type compounds_with3> = <N rootgloss>
   /<Adj head type compounds_with4> = <N rootgloss>}
    <N' rule> = compoundAdj

|-***********************************************************
rule {PP option 2a - optional adverbial or Deg before}
PP = (Deg_1) (AdvP / Deg) P'
    <PP head> = <P' head>
    <Deg_1 head type comma> = -
    <AdvP head type comma> = -
    <Deg head type comma> = -
    <AdvP head type manner> = +
    <Deg head type modifies_PP> = +
    <Deg_1 head type modifies_PP> = +
    <Deg_1 head infl polarity> = -
    {<P' head case> = direct         |new
     <P' head type genitive_suffix> = -
    /<P' head case> = genitive
     <P' head type genitive_suffix> = + 
    /<P' head case> = genitive
     <P' head type genitive_suffix> = -
     <P' head type prefix_Prep> = +    | added 17Feb03 CB for P AdjP
     <P' head type modifier-final> = + | added 17Feb03 CB for P AdjP
    } 
    <PP rule> = 2a


|-***********************************************************
rule {P' option 1a - prepositions, DP complement only - not for bh=to}
P' = P (N) DP
    <P' head> = <P head>
    <P' head rootgloss> = <P rootgloss>
    <P' head gloss> = <P gloss>
    <P head type comma> = -
    <N head type comma> = -
    <N head subject head agr> = none         | testing 28May19 ***
    <N head type attributive> = -       | testing 28May19 ***
    <P head type PP-initial> = +
|    {<P head type prefix_Prep> = -                                       | causing failure 22Aug2019
|    /<P head type prefix_Prep> = +  
|     <P head type demonstrative> = + | need to allow object with bdyn qrar CB
|     <P head type pronoun> = -       | but not with pronoun
|    }
    <P head type suffix_Pn> = -
    <P' head reflexive> = <DP head reflexive> | pass reflexive info
    <DP head type case-marked> = -                    |RL 30Jan02  can't have a DO marker in a prepositional phrase.
    <DP head type DO_contraction> = -
    {<DP head case> = genitive              | we are setting the case of the DP in the Prep Phrase to genitive (this should help with transfer to Balochi)
    <DP head case_for_position> = genitive  | to know normal case for conjoined DPs
     <P head type translates2Prep> = -
    /<DP head type genitive_suffix> = +
     <P head type translates2Prep> = -
    <DP head case_for_position> = genitive  | to know normal case for conjoined DPs
    /<DP head case> = oblique             | different case marking for PPs that stay prepositions like with
    <DP head case_for_position> = oblique  | to know normal case for conjoined DPs
     <P head type translates2Prep> = +
     <DP head type pronoun> = -
    /<DP head case> = oblique             | different case marking for PPs that stay prepositions like with
    <DP head case_for_position> = oblique  | to know normal case for conjoined DPs
     <P head type translates2Prep> = +
     <DP head type pronoun> = +
     <DP head agr person third> = +
    /<DP head case> = direct            | different case for 1st and 2nd pronouns  23Jan2020
    <DP head case_for_position> = direct  | to know normal case for conjoined DPs
     <P head type translates2Prep> = +
     <DP head type pronoun> = +
     <DP head agr person first> = +
    /<DP head case> = direct
    <DP head case_for_position> = direct  | to know normal case for conjoined DPs
     <P head type translates2Prep> = +
     <DP head type pronoun> = +
     <DP head agr person second> = +
    }
    <P' head type stranded> = -  |- not missing a complement
    <P' head object> = <DP>         |- for passive, logical constraint 27Jan03 CB
    <N head case> = oblique
    <P head case> = direct
    <DP head participle> = none                                      | trying to restrict participles 12-APR-04
    <DP head possessor head participle> = none                       | trying to restrict participles 12-APR-04
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <P> == ~[rootgloss: to]      | IO, locative use other rule                  | Jun2019 CB
    <P> == ~[gloss: to]      | IO, locative use other rule                  | Jun2019 CB
    <P' head type comma> <= <DP head type comma>
    <P' head type wh> <= <DP head type wh> |- wh for pied-piping
|following removed 21Apr03 CB for "from this same man" marked on P.  If this doesn't work for other situations, need to split feature between source and locative, mark source on P, and add InitP rule allowing source PPs.
|    <P' head type locative> <= <DP head type locative> | Feb03 CB
|    <P' head> == [rootgloss:to] -> ~[object:[head:[type:[pronoun:+]]]]  |only nonpronominals with bh (otherwise use next rule) 27Jan03 CB, removed Jun2019
    <P' rule> = 1a

|************
|added 26Jun2019 CB locative use of to with noun below 
rule {P' option 1aIO - prepositions, DP complement only for IO P = to}
P' = P DP
    <P' head> = <P head>
    <P' head rootgloss> = <P rootgloss>
    <P rootgloss> = to
    <P' head gloss> = <P gloss>
    <P gloss> = to
    <P' head type location_PP> = -     | not for location with motion verbs
    <P head type comma> = -
    <P head type PP-initial> = +
|    {<P head type prefix_Prep> = -                                       | causing failure 22Aug2019
|    /<P head type prefix_Prep> = +  
|     <P head type demonstrative> = + | need to allow object with bdyn qrar CB
|     <P head type pronoun> = -       | but not with pronoun
|    }
    <P head type suffix_Pn> = -
    <P' head reflexive> = <DP head reflexive> | pass reflexive info
    <DP head type case-marked> = -                    |RL 30Jan02  can't have a DO marker in a prepositional phrase.
    <DP head type DO_contraction> = -
||    <DP head case_for_position> = objective  | to know normal case for conjoined DPs- DP case set by VP rule
    <P' head type stranded> = -  |- not missing a complement
    <P' head object> = <DP>         |- for passive, logical constraint 27Jan03 CB
    <P head case> = direct
    <DP head participle> = none                                      | trying to restrict participles 12-APR-04
    <DP head possessor head participle> = none                       | trying to restrict participles 12-APR-04
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <P' head type comma> <= <DP head type comma>
    <P' head type wh> <= <DP head type wh> |- wh for pied-piping
|following removed 21Apr03 CB for "from this same man" marked on P.  If this doesn't work for other situations, need to split feature between source and locative, mark source on P, and add InitP rule allowing source PPs.
|    <P' head type locative> <= <DP head type locative> | Feb03 CB
    <P' rule> = 1aIO

|added 22Aug2019 CB 
rule {P' option 1aLocTo - prepositions, DP complement only for P = to when a locative}
P' = P DP
    <P' head> = <P head>
    <P' head rootgloss> = <P rootgloss>
    <P rootgloss> = to
    <P' head gloss> = <P gloss>
    <P gloss> = to
    <P head type locative> = +
    <P' head type location_PP> = +
    <P head type comma> = -
    <P head type PP-initial> = +
|    {<P head type prefix_Prep> = -                                       | causing failure 22Aug2019
|    /<P head type prefix_Prep> = +  
|     <P head type demonstrative> = + | need to allow object with bdyn qrar CB
|     <P head type pronoun> = -       | but not with pronoun
|    }
    <P head type suffix_Pn> = -
    <P' head reflexive> = <DP head reflexive> | pass reflexive info
    <DP head type case-marked> = -                    |RL 30Jan02  can't have a DO marker in a prepositional phrase.
    <DP head type DO_contraction> = -
    <DP head case_for_position> = oblique  | to know normal case for conjoined DPs
    <DP head case> = oblique   | we are setting the case of the DP in the locative Prep Phrase to oblique (this should help with transfer to Balochi)
    <P' head type stranded> = -  |- not missing a complement
    <P' head object> = <DP>         |- for passive, logical constraint 27Jan03 CB
    <P head case> = direct
    <DP head participle> = none                                      | trying to restrict participles 12-APR-04
    <DP head possessor head participle> = none                       | trying to restrict participles 12-APR-04
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <P' head type comma> <= <DP head type comma>
    <P' head type wh> <= <DP head type wh> |- wh for pied-piping
    <P' rule> = 1aLocTo

rule {P' option 1adv - prepositions, locative complement only}
P' = P (N) AdvP
    <P' head> = <P head>
    <P' head rootgloss> = <P rootgloss>
    <P' head gloss> = <P gloss>
    <P head type comma> = -
    <N head type comma> = -
    <P head type PP-initial> = +
    <AdvP head type locative> = +
    <P' head type locative> = +  | pass up locative feature
    <P' head type stranded> = -  |- not missing a complement
    <N head case> = oblique
    <P head case> = direct
    <P' head type comma> <= <AdvP head type comma> 
    <P> == ~[rootgloss:for]      | benefactors use option benefactorPP
    <P> == ~[gloss:for]      | benefactors use option benefactorPP
    <P' rule> = 1adv

| RL added this rule 23Jan03 E.g: bh^^vwr kaml
rule {P' option 1adj - prepositions, adjective}
P' = P AdjP
    <P' head> = <P head>
    <P' head rootgloss> = <P rootgloss>
    <P' head gloss> = <P gloss>
    <P head type comma> = -
    <N head type comma> = -
    <P head type PP-initial> = +
    <AdjP head case> = direct   
    <P' head type stranded> = -  |- not missing a complement
    <P head case> = direct        | added 17Feb03 CB - changed to direct 12Aug2019
    <P head type prefix_Prep> = +     | added 17Feb03 CB
    <P head type modifier-final> <= + | added 17Feb03 CB
    <P' head type comma> <= <AdjP head type comma> 
    <P> == ~[rootgloss:for]      | benefactors use option benefactorPP
    <P> == ~[gloss:for]      | benefactors use option benefactorPP
    <P' rule> = 1adj

rule {P' option 2a - prepositions, IP complement }
P' = P (N) IP
    <P' head> = <P head>
    <P' head rootgloss> = <P rootgloss>
    <P' head gloss> = <P gloss>
    <P head type comma> = -
    <N head type comma> = -
    <P head type PP-initial> = +
    <P head type prefix_Prep> = -
    <P head type suffix_Pn> = -
    <P' head type root> = <IP head type root>
    <IP head type question> = -
    <IP head infl mood imperative> = -
    <IP head type participle> = -   | restrict participle within IP
    <IP head type copular> = -
    <IP head type initialP> = -     | restrict InitP within IP complement 
    <IP head type conj_suffix> = -  | not h2 13Mar03 CB per Ron
    <IP head type relcl> = -        | not a rel clause 21Nov03 CB
    <P' head type stranded> = -  |- not missing a complement
    <P' head type sentential> = +
    <N head case> = oblique
    <P head case> = direct
    <P' head type comma> <= <IP head type comma> 
    <P> == ~[rootgloss:for]      | benefactors use option benefactorPP
    <P> == ~[gloss:for]      | benefactors use option benefactorPP
    <P' rule> = 2a

rule {P' option bh-I - prefixed to oblique, complement required}
P' = P DP
    <P' head> = <P head>
    <P' head rootgloss> = <P rootgloss>
    <P' head gloss> = <P gloss>
    <P head type comma> = -
    <P head type passive> = +
    <P head case> = oblique
    <P head type prefix_Prep> = +
    <P head type suffix_Pn> = -
    <P' head reflexive> = <DP head reflexive> | pass reflexive info
    <P' head object> = <DP>         |- for passive, etc.
    <DP head type DO_contraction> = -
    <DP head case_for_position> = direct  | to know normal case for conjoined DPs
    <DP head case> = direct
    <P' head type stranded> = -         |- not missing a complement
    <DP head participle> = none                                      | trying to restrict participles 12-APR-04
    <DP head possessor head participle> = none                       | trying to restrict participles 12-APR-04
    <DP head type nonfinalcoordination> = -
    <DP> == ~[mother_node:-]     | if coordination, must be allowed initially
    <DP> == [mother_node:+] -> [head:[type:[coordination:+]]] |and be complete
    <DP head type> == [relative:+] -> [relcl:+]      | require rel suffix to only occur when relative clause present
    <P' head type comma> <= <DP head type comma> 
    <P' rule> = bh-I

rule {P' option bh-II - prefixed to N, Pn or Dem complement so full PP}
P' = P
    <P' head> = <P head>
    <P' head rootgloss> = <P rootgloss>
    <P' head gloss> = <P gloss>
    <P head type passive> = +
    <P head case> = direct
    <P head type prefix_Prep> = +
    <P' head type stranded> = -         |- not missing a complement
    <P' rule> = bh-II

|added 15Jul03 CB
rule {P' option pn-sf - pronoun suffixed to P so full PP}
P' = P
    <P' head> = <P head>
    <P' head rootgloss> = <P rootgloss>
    <P' head gloss> = <P gloss>
    <P head type passive> = -
    <P head case> = direct
    <P head type suffix_Pn> = +
    <P' head type stranded> = -         |- not missing a complement
    <P' rule> = pn-sf

|-***********************************************************
rule {QP option 2 as Numbers - modifiers final}
QP = NumP (Q) (Adj)
    <QP head> = <NumP head>
    <Adj head type ordinal> = +
    <Adj head case> = <QP head case>
    <QP rule> = 2

rule {QP option Q alone}
QP = Q
    <QP head> = <Q head>
    <QP rule> = Q

rule {NumP option number (optional classifier)}
NumP = Num (NumCl)
    <NumP head> = <Num head>
    <NumCl head case> = <NumP head case>
    <NumP rule> = number

| RL 5Feb02 classifier alone.
rule {NumCl option numberCl}
NumP = NumCl
    <NumP head> = <NumCl head>
    <NumP rule> = numberCl

rule {NumP as compound}
NumP = NumP_1 Conj NumP_2
    <NumP head> = <NumP_1 head>
    <NumP conjoined> = +                             |RL 5Feb02 limit recursion to right node only.
    <NumP_1 conjoined> = -
    <NumP rule> = compound 

|-***********************************************************
rule {AdjP option 0 - conjoined }
AdjP = AdjP_1 Conj AdjP_2
    <AdjP head> = <AdjP_2 head>   | make right-headed for case marking 03Apr03
    <AdjP conjoined> = +          | limit recursion to left node only
    <AdjP_2 conjoined> = -
    <AdjP_1 head case> = direct  | unmarked except final
    <Conj head type conjoins_DP> = +
    <AdjP_1 head type relative> = -  | intial conjunct not marked with REL
    <AdjP rule> = 0

rule {AdjP option 2 - degree modifiers initial }
AdjP = (Deg) Adj
    <AdjP head> = <Adj head>
    <Deg head type comma> = -
    <Deg head type modifies_Adj> = +
    <AdjP head infl polarity> <= <Deg head infl polarity>
    <AdjP rule> = 2

|-***********************************************************
rule {AdvP option 1 - no modifiers}
AdvP = Adv
    <AdvP head> = <Adv head>
    <AdvP rule> = 1

rule {AdvP option 2 - modifiers initial}
AdvP = Deg Adv
    <AdvP head> = <Adv head>
    <Deg head type comma> = -
|    <Deg head type modifies_Adv> = <Adv head type>  |replace this with the following Apr2020
    <AdvP head modifier head> = <Deg head>
          <AdvP head> == [type:[manner:+]] -> [modifier:[head:[type:[modifies_Adv:[manner:+]]]]]
          <AdvP head> == [type:[temporal:+]] -> [modifier:[head:[type:[modifies_Adv:[temporal:+]]]]]
          <AdvP head> == [type:[locative:+]] -> [modifier:[head:[type:[modifies_Adv:[locative:+]]]]]
   <AdvP rule> = 2
