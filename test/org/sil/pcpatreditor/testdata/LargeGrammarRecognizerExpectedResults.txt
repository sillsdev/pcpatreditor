(patrgrammar (comment |-PC-PATR Grammar file for FARSI, Based on FARPatr-2019 but ergative version, changing case features to non-binary May 2019, Cutting out most extra rules version 2 Jan 2020  Now no case in glosses RL Apr 2020\r\n) (comment |- additional templates for Balochi/Gilaki conflicts 6/21/19\r\n) (comment ||Let Gil_accusative          be  [ ]\r\n) (comment |- additional templates for Balochi 3/29/19\r\n) (comment |Let benefactor              be  <head case>                                 = benefactor\r\n) (featureTemplates (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue direct)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (featureTemplateValue (atomicValue direct) (comment ||Let object                  be  <head case>                                 = objective\r\n)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue object_case)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (featureTemplateValue (atomicValue objective)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue generic)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue generic)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue attributive)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue attributive)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue definite)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue indefinite)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue translates2prep)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue translates2Prep)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue modifier_required)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier_required)))) (closingWedge >)) = (featureTemplateValue (atomicValue +) (comment ||testing for ez 20Aug2019\r\n) (comment |-***********************************************************\r\n) (comment |-Feature templates\r\n)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue absolutive)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (featureTemplateValue (atomicValue absolutive)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue -absolutive)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (featureTemplateValue (featureTemplateDisjunction (openingBrace {) (featurePath (atomicValue ergative) (featurePath (atomicValue genitive))) (featurePathOrStructure (featurePath (atomicValue dative))) (closingBrace }))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue accusative)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (featureTemplateValue (atomicValue accusative)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue -accusative)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (featureTemplateValue (featureTemplateDisjunction (openingBrace {) (featurePath (atomicValue nominative) (featurePath (atomicValue genitive))) (featurePathOrStructure (featurePath (atomicValue dative))) (closingBrace }))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue AdjP-final)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue AdjP-final)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue AdjP-initial)))) (closingWedge >)) = (featureTemplateValue (atomicValue -))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue AdjP-initial)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue AdjP-initial)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue AdjP-final)))) (closingWedge >)) = (featureTemplateValue (atomicValue -))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue AdvP-final)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue AdvP-final)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue AdvP-initial)))) (closingWedge >)) = (featureTemplateValue (atomicValue -))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue AdvP-initial)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue AdvP-initial)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue AdvP-final)))) (closingWedge >)) = (featureTemplateValue (atomicValue -))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue animate)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue animate)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue animate_object)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue object) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue animate)))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue animate_subject)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue subject) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue animate)))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue -animate)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue animate)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue -animate_object)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue object) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue animate)))))) (closingWedge >)) = (featureTemplateValue (atomicValue -)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue -animate_subject)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue subject) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue animate)))))) (closingWedge >)) = (featureTemplateValue (atomicValue -)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue benefactor)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (featureTemplateValue (atomicValue benefactor)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue causative)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue valence) (featurePath (atomicValue causative))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue causative_syntax)) be) (featureTemplateValue (featureTemplateDisjunction (openingBrace {) (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue infl)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue valence)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue causative)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (closingBracket ]))) (embeddedFeatureStructure (featureStructureName (atomicValue type)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue causative_syntax)) : (featureStructureValue (atomicValue +)) (closingBracket ])))) (embeddedFeatureStructure (featureStructureName (atomicValue embedded)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue cat)) : (featureStructureValue (atomicValue IP)) (closingBracket ])))) (closingBracket ]))) (closingBracket ])) (featurePathOrStructure (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue type)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue causative_syntax)) : (featureStructureValue (atomicValue +)) (embeddedFeatureStructure (featureStructureName (atomicValue transitive)) : (featureStructureValue (atomicValue +))) (closingBracket ]))) (embeddedFeatureStructure (featureStructureName (atomicValue embedded)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue cat)) : (featureStructureValue (atomicValue none)) (closingBracket ])))) (closingBracket ]))) (closingBracket ]))) (closingBrace })))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue comma)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue completive)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue aspect) (featurePath (atomicValue completive))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compound)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue -compound)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue comp_suffix)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comp_suffix)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue conj_suffix)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue conj_suffix)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue participle)))) (closingWedge >)) = (featureTemplateValue (atomicValue -))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue conjoins_DP)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue conjoins_DP)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue conjoins_IP)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue conjoins_IP)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue -conjoins_DP)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue conjoins_DP)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue -conjoins_IP)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue conjoins_IP)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue continuative)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue aspect) (featurePath (atomicValue continuative))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue copular)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue copular)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)) = (featureTemplateValue (atomicValue -))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue -copular)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue copular)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)) = (featureTemplateValue (atomicValue +))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue copular_suffix)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue copular_suffix)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue copular)) ])))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue CP-final)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue CP-final)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue -CP-final)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue CP-final)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue CP-initial)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue CP-initial)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue -CP-initial)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue CP-initial)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue CP-specifier-initial)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue CP-specifier-initial)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue declarative)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue mood) (featurePath (atomicValue declarative))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue ditransitive)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue ditransitive)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)) = (featureTemplateValue (atomicValue +))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue -ditransitive)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue ditransitive)))) (closingWedge >)) = (featureTemplateValue (atomicValue -) (comment |testing for adj 5\r\n)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)) = (featureTemplateValue (atomicValue +))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue DP-final)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP-final)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue -DP-final)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP-final)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue DP-initial)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP-initial)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue -DP-initial)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP-initial)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue DO_contraction)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DO_contraction)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue dual)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number) (featurePath (atomicValue dual))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue dual_object)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue object) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number) (featurePath (atomicValue dual))))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue dual_subject)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue subject) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number) (featurePath (atomicValue dual))))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue embedded_subjunctive)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue embedded) (featurePath (atomicValue infl) (featurePath (atomicValue mood) (featurePath (atomicValue realis))))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue embedded) (featurePath (atomicValue infl) (featurePath (atomicValue mood) (featurePath (atomicValue subjunctive))))) (closingWedge >)) = (featureTemplateValue (atomicValue +) (comment | Feb2020\r\n))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue ergative)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (featureTemplateValue (atomicValue ergative)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue -ergative)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (featureTemplateValue (featureTemplateDisjunction (openingBrace {) (featurePath (atomicValue absolutive)) (featurePathOrStructure (featurePath (atomicValue genitive))) (closingBrace }))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue exclusive)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue first))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue second))))) (closingWedge >)) = (featureTemplateValue (atomicValue -))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue feminine)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue gender) (featurePath (atomicValue feminine))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue feminine_object)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue object) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue gender) (featurePath (atomicValue feminine))))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue feminine_subject)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue subject) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue gender) (featurePath (atomicValue feminine))))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue first)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue first))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue second))))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue third))))) (closingWedge >)) = (featureTemplateValue (atomicValue -)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue first_exclusive_subject)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue subject) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue first))))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue subject) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue second))))))) (closingWedge >)) = (featureTemplateValue (atomicValue -))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue first_exclusive_object)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue object) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue first))))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue object) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue second))))))) (closingWedge >)) = (featureTemplateValue (atomicValue -))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue first_inclusive_subject)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue subject) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue first))))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue subject) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue second))))))) (closingWedge >)) = (featureTemplateValue (atomicValue +))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue first_inclusive_object)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue object) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue first))))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue object) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue second))))))) (closingWedge >)) = (featureTemplateValue (atomicValue +))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue first_object)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue object) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue first))))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue object) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue second))))))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue object) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue third))))))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue object_agr_suffix)))) (closingWedge >)) = (featureTemplateValue (atomicValue +))))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue first_subject)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue subject) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue first))))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue subject) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue second))))))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue subject) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue third))))))) (closingWedge >)) = (featureTemplateValue (atomicValue -)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue future)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue tense) (featurePath (atomicValue future))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue gen_initial)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue gen_initial)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue genitive)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (featureTemplateValue (atomicValue genitive)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue genitive-accusative)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (featureTemplateValue (featureTemplateDisjunction (openingBrace {) (featurePath (atomicValue genitive)) (featurePathOrStructure (featurePath (atomicValue accusative))) (closingBrace }))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue -genitive)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (featureTemplateValue (featureTemplateDisjunction (openingBrace {) (featurePath (atomicValue nominative)) (featurePathOrStructure (featurePath (atomicValue accusative))) (closingBrace }))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue genitive_suffix)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue genitive_suffix)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue genitive)) ])))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue habitual)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue aspect) (featurePath (atomicValue habitual))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue human)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue human)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue animate)) ])))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue -human)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue human)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue imperative)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue mood) (featurePath (atomicValue imperative))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue subject) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue second))))))) (closingWedge >)) = (featureTemplateValue (atomicValue +) (comment |for Adj 4\r\n)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue subject) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue third))))))) (closingWedge >)) = (featureTemplateValue (atomicValue -) (comment |for Adj 4\r\n)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue imperfective)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue aspect) (featurePath (atomicValue perfective))))) (closingWedge >)) = (featureTemplateValue (atomicValue -)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue impersonal)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue impersonal)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue inclusive)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue second))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue incompletive)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue aspect) (featurePath (atomicValue completive))))) (closingWedge >)) = (featureTemplateValue (atomicValue -)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue indefinite)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue indefinite)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) = (featureTemplateValue (atomicValue -))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue infinitive)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue finite)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue interrogative)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue mood) (featurePath (atomicValue interrogative))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue question)))) (closingWedge >)) = (featureTemplateValue (atomicValue +))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue -interrogative)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue mood) (featurePath (atomicValue interrogative))))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue question)))) (closingWedge >)) = (featureTemplateValue (atomicValue -))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue intransitive)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue irrealis)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue mood) (featurePath (atomicValue realis))))) (closingWedge >)) = (featureTemplateValue (atomicValue -)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue locative)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue locative)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue temporal)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue manner)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue manner)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue -manner)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue manner)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue masculine)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue gender) (featurePath (atomicValue masculine))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue masculine_object)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue object) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue gender) (featurePath (atomicValue masculine))))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue masculine_subject)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue subject) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue gender) (featurePath (atomicValue masculine))))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue modifies_Adj)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifies_Adj)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue modifies_Adv)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifies_Adv) (featurePath (atomicValue temporal))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifies_Adv) (featurePath (atomicValue locative))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifies_Adv) (featurePath (atomicValue manner))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifies_Adv) (featurePath (atomicValue reason))))) (closingWedge >)) = (featureTemplateValue (atomicValue +))))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue modifies_Adv-reason)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifies_Adv) (featurePath (atomicValue reason))))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifies_Adv) (featurePath (atomicValue locative))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifies_Adv) (featurePath (atomicValue manner))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifies_Adv) (featurePath (atomicValue temporal))))) (closingWedge >)) = (featureTemplateValue (atomicValue +))))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue modifies_locative)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifies_Adv) (featurePath (atomicValue locative))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue modifies_manner)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifies_Adv) (featurePath (atomicValue manner))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue modifies_NP)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifies_NP)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue modifies_NPrep)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifies_NPrep)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue modifies_PP)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifies_PP)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue modifies_Q)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifies_Q)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue modifies_reason)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifies_Adv) (featurePath (atomicValue reason))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue modifies_temporal)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifies_Adv) (featurePath (atomicValue temporal))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue motion)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue motion)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue negative)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue polarity)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue negative_prefix)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue negative_prefix)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue negative)) ])))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue negative_suffix)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue negative_suffix)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue negative)) ])))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue neuter)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue gender) (featurePath (atomicValue neuter))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue neuter_object)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue object) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue gender) (featurePath (atomicValue neuter))))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue neuter_subject)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue subject) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue gender) (featurePath (atomicValue neuter))))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue nominative)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (featureTemplateValue (atomicValue nominative)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue -nominative)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (featureTemplateValue (featureTemplateDisjunction (openingBrace {) (featurePath (atomicValue accusative)) (featurePathOrStructure (featurePath (atomicValue genitive))) (closingBrace }))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue oblique)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (featureTemplateValue (atomicValue oblique)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue participle)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue participle)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue partitive)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue partitive)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue passive)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue passive)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue -passive)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue passive)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue passive.optional)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue passive)))) (closingWedge >)) = (featureTemplateValue (featureTemplateDisjunction (openingBrace {) (featurePath (atomicValue +)) (featurePathOrStructure (featurePath (atomicValue -))) (closingBrace }))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue past)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue tense) (featurePath (atomicValue past))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue tense) (featurePath (atomicValue present))))) (closingWedge >)) = (featureTemplateValue (atomicValue -))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue perfective)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue aspect) (featurePath (atomicValue perfective))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue plural)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number) (featurePath (atomicValue plural))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number) (featurePath (atomicValue singular))))) (closingWedge >)) = (featureTemplateValue (atomicValue -))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue plural_object)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue object) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number) (featurePath (atomicValue plural))))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue object) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number) (featurePath (atomicValue singular))))))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue object_agr_suffix)))) (closingWedge >)) = (featureTemplateValue (atomicValue +) (comment |added 24May19\r\n)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue plural_subject)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue subject) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number) (featurePath (atomicValue plural))))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue subject) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number) (featurePath (atomicValue singular))))))) (closingWedge >)) = (featureTemplateValue (atomicValue -))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue poss_dual)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue possessor) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number) (featurePath (atomicValue dual))))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue possessor) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number) (featurePath (atomicValue singular))))))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue possessor) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number) (featurePath (atomicValue plural))))))) (closingWedge >)) = (featureTemplateValue (atomicValue -)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue poss_exclusive)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue possessor) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue first))))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue possessor) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue second))))))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue possessor) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue third))))))) (closingWedge >)) = (featureTemplateValue (atomicValue -)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue poss_feminine)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue possessor) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue gender) (featurePath (atomicValue feminine))))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue poss_first)) be) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue poss_exclusive)) ]))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue poss_inclusive)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue possessor) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue first))))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue possessor) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue second))))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue possessor) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue third))))))) (closingWedge >)) = (featureTemplateValue (atomicValue -)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue poss_masculine)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue possessor) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue gender) (featurePath (atomicValue masculine))))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue poss_plural)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue possessor) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number) (featurePath (atomicValue plural))))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue possessor) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number) (featurePath (atomicValue singular))))))) (closingWedge >)) = (featureTemplateValue (atomicValue -))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue poss_second)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue possessor) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue first))))))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue possessor) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue second))))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue possessor) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue third))))))) (closingWedge >)) = (featureTemplateValue (atomicValue -)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue poss_singular)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue possessor) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number) (featurePath (atomicValue plural))))))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue possessor) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number) (featurePath (atomicValue singular))))))) (closingWedge >)) = (featureTemplateValue (atomicValue +))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue poss_third)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue possessor) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue first))))))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue possessor) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue second))))))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue possessor) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue third))))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue possessed)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue possessed)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue potential)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue aspect) (featurePath (atomicValue potential))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue PP-final)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue QP-final)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue QP-initial)))) (closingWedge >)) = (featureTemplateValue (atomicValue -))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue PP-initial)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue QP-initial)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue QP-final)))) (closingWedge >)) = (featureTemplateValue (atomicValue -))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue prefix_Prep)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue prefix_Prep)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue present)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue tense) (featurePath (atomicValue present))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue tense) (featurePath (atomicValue past))))) (closingWedge >)) = (featureTemplateValue (atomicValue -))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue progressive)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue aspect) (featurePath (atomicValue progressive))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue question)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue question)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue -question)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue question)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue QP-final)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue QP-final)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue QP-initial)))) (closingWedge >)) = (featureTemplateValue (atomicValue -))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue QP-initial)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue QP-initial)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue QP-final)))) (closingWedge >)) = (featureTemplateValue (atomicValue -))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue quantifier)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue quantifier)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue reason)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue reason)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue realis)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue mood) (featurePath (atomicValue realis))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue reciprocal)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue reciprocal)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue reflexive)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue reflexivity)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue relative)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue indefinite)))) (closingWedge >)) = (featureTemplateValue (atomicValue -))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue -relative)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue indefinite)))) (closingWedge >)) = (featureTemplateValue (atomicValue -))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue +root)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue root)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue -root)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue root)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue second)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue second))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue first))))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue third))))) (closingWedge >)) = (featureTemplateValue (atomicValue -)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue second_object)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue object) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue second))))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue object) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue first))))))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue object) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue third))))))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue object_agr_suffix)))) (closingWedge >)) = (featureTemplateValue (atomicValue +))))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue second_subject)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue subject) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue second))))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue subject) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue first))))))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue subject) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue third))))))) (closingWedge >)) = (featureTemplateValue (atomicValue -)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue sentential)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue sentential)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue short_infinitive)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue finite)))) (closingWedge >)) = (featureTemplateValue (atomicValue short)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue singular)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number) (featurePath (atomicValue singular))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number) (featurePath (atomicValue plural))))) (closingWedge >)) = (featureTemplateValue (atomicValue -))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue singular_object)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue object) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number) (featurePath (atomicValue singular))))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue object) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number) (featurePath (atomicValue plural))))))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue object_agr_suffix)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue singular_subject)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue subject) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number) (featurePath (atomicValue singular))))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue subject) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number) (featurePath (atomicValue plural))))))) (closingWedge >)) = (featureTemplateValue (atomicValue -))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue stative)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue aspect) (featurePath (atomicValue stative))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue stand-alone)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue stand-alone)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue subjunctive)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue mood) (featurePath (atomicValue subjunctive))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue mood) (featurePath (atomicValue realis))))) (closingWedge >)) = (featureTemplateValue (atomicValue -))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue suffix_Pn)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue suffix_Pn)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue temporal)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue temporal)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue -temporal)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue temporal)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue third)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue third))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue first))))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue second))))) (closingWedge >)) = (featureTemplateValue (atomicValue -)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue third_object)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue object) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue third))))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue object) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue first))))))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue object) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue second))))))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue object_agr_suffix)))) (closingWedge >)) = (featureTemplateValue (atomicValue +))))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue third_subject)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue subject) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue third))))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue subject) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue first))))))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue subject) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue second))))))) (closingWedge >)) = (featureTemplateValue (atomicValue -)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue transitive)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue transitive_motion)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive_motion)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue transitive.optional)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)) = (featureTemplateValue (featureTemplateDisjunction (openingBrace {) (featurePath (atomicValue +)) (featurePathOrStructure (featurePath (atomicValue -))) (closingBrace })))) (comment | 21Jul03\r\n)) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue wh)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue wh)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue -wh)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue wh)))) (closingWedge >)) = (featureTemplateValue (atomicValue -) (comment |-special features for compounding restrictions - these only forced to compound when rootgloss matches. Rules currently allow up to 5 rootglosses.\r\n)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_bring1_intrans)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue bring)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_bring1_trans)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue bring)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_bring2_intrans)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with2)))) (closingWedge >)) = (featureTemplateValue (atomicValue bring)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_come1_intrans)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue come)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_come2_intrans)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with2)))) (closingWedge >)) = (featureTemplateValue (atomicValue come)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_do1_intrans)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue do)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_do1_trans)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue do)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_do2_trans)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with2)))) (closingWedge >)) = (featureTemplateValue (atomicValue do)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_do2_intrans)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with2)))) (closingWedge >)) = (featureTemplateValue (atomicValue do)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_do3_intrans)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with3)))) (closingWedge >)) = (featureTemplateValue (atomicValue do)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_do4_intrans)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with4)))) (closingWedge >)) = (featureTemplateValue (atomicValue do)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_fall1_intrans)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue fall)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_give1_trans)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue give)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_give1_intrans)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue give)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_have1_intrans)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue have)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_hit1_intrans)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue hit)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_hit2_intrans)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with2)))) (closingWedge >)) = (featureTemplateValue (atomicValue hit)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_hit3_intrans)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with3)))) (closingWedge >)) = (featureTemplateValue (atomicValue hit)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_pull1_intrans)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue pull)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_pull2_intrans)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with2)))) (closingWedge >)) = (featureTemplateValue (atomicValue pull)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_sew1_intrans)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue sew)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_supply1_intrans)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue supply)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +) (comment | Need to be redone or removed\r\n)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_آمدن)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue come.pst)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_آمدن،آوردن)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue come.pst)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with2)))) (closingWedge >)) = (featureTemplateValue (atomicValue bring.pst)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_آمدن،آوردن،بردن،کردن)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue come.pst)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with2)))) (closingWedge >)) = (featureTemplateValue (atomicValue bring.pst)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with3)))) (closingWedge >)) = (featureTemplateValue (atomicValue carry.pst)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with4)))) (closingWedge >)) = (featureTemplateValue (atomicValue do.pst)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_آمدن،آوردن،شدن،کردن)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue come.pst)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with2)))) (closingWedge >)) = (featureTemplateValue (atomicValue bring.pst)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with3)))) (closingWedge >)) = (featureTemplateValue (atomicValue become.pst)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with4)))) (closingWedge >)) = (featureTemplateValue (atomicValue do.pst)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_آمدن،آوردن،رفتن،فرستادن)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue come.pst)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with2)))) (closingWedge >)) = (featureTemplateValue (atomicValue bring.pst)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with3)))) (closingWedge >)) = (featureTemplateValue (atomicValue go.pst)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with4)))) (closingWedge >)) = (featureTemplateValue (atomicValue send.pst)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_اندوختن،یافتن)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue amass.pst)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with2)))) (closingWedge >)) = (featureTemplateValue (atomicValue find.pst)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_آوردن)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue bring.pst)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_آوردن،دادن)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue bring.pst)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with2)))) (closingWedge >)) = (featureTemplateValue (atomicValue give.pst)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_آوردن،دادن،گشتن)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue bring.pst)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with2)))) (closingWedge >)) = (featureTemplateValue (atomicValue give.pst)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with3)))) (closingWedge >)) = (featureTemplateValue (atomicValue turn.pst)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +))))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_آوردن،داشتن)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue آوردن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with2)))) (closingWedge >)) = (featureTemplateValue (atomicValue داشتن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_بخشیدن،دادن،یافتن)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue بخشیدن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with2)))) (closingWedge >)) = (featureTemplateValue (atomicValue دادن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with3)))) (closingWedge >)) = (featureTemplateValue (atomicValue یافتن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +))))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_بر‌‌آوردن،زدن،کردن،کشیدن)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue بر‌‌آوردن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with2)))) (closingWedge >)) = (featureTemplateValue (atomicValue زدن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with3)))) (closingWedge >)) = (featureTemplateValue (atomicValue کردن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with4)))) (closingWedge >)) = (featureTemplateValue (atomicValue کشیدن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_پوشیدن،دوختن)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue پوشیدن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with2)))) (closingWedge >)) = (featureTemplateValue (atomicValue دوختن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_خوردن،خریدن،دادن)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue خوردن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with2)))) (closingWedge >)) = (featureTemplateValue (atomicValue خریدن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with3)))) (closingWedge >)) = (featureTemplateValue (atomicValue دادن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +))))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_خواندن)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue خواندن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_دادن)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue دادن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_دادن،فرا‌‌دادن،سپردن،کردن)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue دادن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with2)))) (closingWedge >)) = (featureTemplateValue (atomicValue فرا‌‌دادن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with3)))) (closingWedge >)) = (featureTemplateValue (atomicValue سپردن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with4)))) (closingWedge >)) = (featureTemplateValue (atomicValue کردن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_دادن،فرمودن،کردن)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue دادن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with2)))) (closingWedge >)) = (featureTemplateValue (atomicValue فرمودن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with3)))) (closingWedge >)) = (featureTemplateValue (atomicValue کردن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +))))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_دادن،کردن)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue دادن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with2)))) (closingWedge >)) = (featureTemplateValue (atomicValue کردن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_دادن،گرفتن)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue دادن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with2)))) (closingWedge >)) = (featureTemplateValue (atomicValue گرفتن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_دادن،گفتن)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue دادن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with2)))) (closingWedge >)) = (featureTemplateValue (atomicValue گفتن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_دادن،یافتن)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue دادن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with2)))) (closingWedge >)) = (featureTemplateValue (atomicValue یافتن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_داشتن،کردن)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue داشتن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with2)))) (closingWedge >)) = (featureTemplateValue (atomicValue کردن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_داشتن،شدن،کردن،نمودن)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue داشتن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with2)))) (closingWedge >)) = (featureTemplateValue (atomicValue شدن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with3)))) (closingWedge >)) = (featureTemplateValue (atomicValue کردن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with4)))) (closingWedge >)) = (featureTemplateValue (atomicValue نمودن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_داشتن،کردن،نمودن)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue داشتن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with2)))) (closingWedge >)) = (featureTemplateValue (atomicValue کردن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with3)))) (closingWedge >)) = (featureTemplateValue (atomicValue نمودن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +))))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_دیدن)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue دیدن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_رسیدن)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue رسیدن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_ساختن،شدن،کردن)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue ساختن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with2)))) (closingWedge >)) = (featureTemplateValue (atomicValue شدن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with3)))) (closingWedge >)) = (featureTemplateValue (atomicValue کردن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +))))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_ساختن،شدن،کردن،گشتن)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue ساختن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with2)))) (closingWedge >)) = (featureTemplateValue (atomicValue شدن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with3)))) (closingWedge >)) = (featureTemplateValue (atomicValue کردن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with4)))) (closingWedge >)) = (featureTemplateValue (atomicValue گشتن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_ساختن)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue ساختن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_شدن)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue شدن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_شدن،کردن)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue شدن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with2)))) (closingWedge >)) = (featureTemplateValue (atomicValue کردن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_شدن،کردن،نمودن)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue شدن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with2)))) (closingWedge >)) = (featureTemplateValue (atomicValue کردن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with3)))) (closingWedge >)) = (featureTemplateValue (atomicValue نمودن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +))))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_شمردن،گرفتن،نمودن)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue شمردن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with2)))) (closingWedge >)) = (featureTemplateValue (atomicValue گرفتن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with3)))) (closingWedge >)) = (featureTemplateValue (atomicValue نمودن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +))))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_کردن)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue do.pst)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_کردن،گفتن)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue کردن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with2)))) (closingWedge >)) = (featureTemplateValue (atomicValue گفتن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_کردن،شدن)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue کردن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with2)))) (closingWedge >)) = (featureTemplateValue (atomicValue شدن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_کردن،نمودن)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue کردن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with2)))) (closingWedge >)) = (featureTemplateValue (atomicValue نمودن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_گفتن)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue گفتن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_گزیدن)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue گزیدن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_گزیدن،کردن)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue گزیدن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with2)))) (closingWedge >)) = (featureTemplateValue (atomicValue کردن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue compounds_with_یافتن)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (featureTemplateValue (atomicValue یافتن)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +) (comment |-Category changes and defaults\r\n))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue Adj)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue cat)) (closingWedge >)) = (featureTemplateValue (atomicValue !Adj)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue ordinal)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue wh)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue indefinite)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue sentential)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP-initial)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue genitive_suffix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue negative_suffix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue negative_prefix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue attributive)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (featureTemplateValue (atomicValue !direct)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue impersonal)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-) (comment |CB 24Jul06\r\n)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with2)))) (closingWedge >)) = (featureTemplateValue (atomicValue !none)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with3)))) (closingWedge >)) = (featureTemplateValue (atomicValue !none)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with4)))) (closingWedge >)) = (featureTemplateValue (atomicValue !none)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue !unspecified))))))))))))))))))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue Adv)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue cat)) (closingWedge >)) = (featureTemplateValue (atomicValue !Adv)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue wh)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (featureTemplateValue (atomicValue !direct)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue polarity)))) (closingWedge >)) = (featureTemplateValue (atomicValue !+)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-final)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-initial)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue manner)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue temporal)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue locative)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-))))))))))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue Art)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue cat)) (closingWedge >)) = (featureTemplateValue (atomicValue !Art)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue wh)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue negative_suffix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue negative_prefix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)))))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue Aux)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue cat)) (closingWedge >)) = (featureTemplateValue (atomicValue !Aux)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue passive)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue finite)))) (closingWedge >)) = (featureTemplateValue (atomicValue !+)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue tense) (featurePath (atomicValue future))))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue mood) (featurePath (atomicValue realis))))) (closingWedge >)) = (featureTemplateValue (atomicValue !+)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue polarity)))) (closingWedge >)) = (featureTemplateValue (atomicValue !+)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue negative_suffix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue negative_prefix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue aspect) (featurePath (atomicValue perfective))))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue object_agr_suffix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-) (comment |24May19\r\n)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue impersonal)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-))))))))))))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue C)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue cat)) (closingWedge >)) = (featureTemplateValue (atomicValue C)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue question)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-) (comment |Mark Conj with - values of features if cannot occur in that position!!\r\n)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue Conj)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue cat)) (closingWedge >)) = (featureTemplateValue (atomicValue !Conj)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue conjoins_DP)))) (closingWedge >)) = (featureTemplateValue (atomicValue !+)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue conjoins_IP)))) (closingWedge >)) = (featureTemplateValue (atomicValue !+)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue CP-initial)))) (closingWedge >)) = (featureTemplateValue (atomicValue !+)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue CP-final)))) (closingWedge >)) = (featureTemplateValue (atomicValue !+)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP-initial)))) (closingWedge >)) = (featureTemplateValue (atomicValue !+)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP-final)))) (closingWedge >)) = (featureTemplateValue (atomicValue !+)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-))))))))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue Deg)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue cat)) (closingWedge >)) = (featureTemplateValue (atomicValue Deg)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DO_contraction)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (featureTemplateValue (atomicValue !direct)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifies_Adj)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifies_Adv) (featurePath (atomicValue temporal))))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifies_Adv) (featurePath (atomicValue locative))))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifies_Adv) (featurePath (atomicValue manner))))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifies_Adv) (featurePath (atomicValue reason))))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifies_NP)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifies_NPrep)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifies_PP)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifies_Q)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue quantifier)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue wh)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue indefinite)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue CP-final)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue polarity)))) (closingWedge >)) = (featureTemplateValue (atomicValue !+)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP-final)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number) (featurePath (atomicValue plural))))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue apposition)))) (closingWedge >)) = (featureTemplateValue (atomicValue -) (comment |17Jan03CB\r\n)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pronoun)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue proper)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue gen_initial)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-) (comment |7Apr03CB\r\n)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comp_suffix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue negative_suffix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue negative_prefix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-) (comment | Deg meaning 'all' needs to be marked plural\r\n))))))))))))))))))))))))))))))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue Dem)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue cat)) (closingWedge >)) = (featureTemplateValue (atomicValue !Dem)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue wh)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue indefinite)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DO_contraction)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (featureTemplateValue (atomicValue !direct)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number) (featurePath (atomicValue singular))))) (closingWedge >)) = (featureTemplateValue (atomicValue !+)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number) (featurePath (atomicValue plural))))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue third))))) (closingWedge >)) = (featureTemplateValue (atomicValue !+)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue first))))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue second))))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue apposition)))) (closingWedge >)) = (featureTemplateValue (atomicValue -) (comment |17Jan03 CB\r\n)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pronoun)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue proper)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comp_suffix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue demonstrative)))) (closingWedge >)) = (featureTemplateValue (atomicValue +) (comment |28Jul03 CB\r\n)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue negative_suffix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue negative_prefix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-))))))))))))))))))))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue Excl)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue cat)) (closingWedge >)) = (featureTemplateValue (atomicValue !Excl)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue N)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue cat)) (closingWedge >)) = (featureTemplateValue (atomicValue !N)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue third))))) (closingWedge >)) = (featureTemplateValue (atomicValue !+)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue first))))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue second))))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number) (featurePath (atomicValue singular))))) (closingWedge >)) = (featureTemplateValue (atomicValue !+)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number) (featurePath (atomicValue plural))))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (featureTemplateValue (atomicValue !direct)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue polarity)))) (closingWedge >)) = (featureTemplateValue (atomicValue !+)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue finite)))) (closingWedge >)) = (featureTemplateValue (atomicValue !+)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue animate)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue human)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue generic)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue wh)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue reciprocal)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue indefinite)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue sentential)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-final)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-initial)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DO_contraction)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue proper)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pronoun)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-) (comment |set by force_Pn to +, so can't have - w/o default 28Jan03 CB\r\n)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue genitive_suffix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with2)))) (closingWedge >)) = (featureTemplateValue (atomicValue !none)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with3)))) (closingWedge >)) = (featureTemplateValue (atomicValue !none)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with4)))) (closingWedge >)) = (featureTemplateValue (atomicValue !none)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue !unspecified)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue temporal)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue locative)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-) (comment |**\r\n)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue apposition)))) (closingWedge >)) = (featureTemplateValue (atomicValue -) (comment |17Jan03CB\r\n)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue reflexivity)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-) (comment |17Feb03CB\r\n)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (featureTemplateValue (atomicValue -) (comment |1Apr03CB\r\n)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comp_suffix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)) = (featureTemplateValue (atomicValue !+) (comment |for compound default case, mark intransitive if needed 17Apr03 CB\r\n)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue nonfinalcoordination)))) (closingWedge >)) = (featureTemplateValue (atomicValue -) (comment |15Aug03CB\r\n)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue NPrep)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-) (comment |22Jul06CB\r\n)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue negative_suffix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue negative_prefix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue copular_suffix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-) (comment |Apr2020\r\n)))))))))))))))))))))))))))))))))))))))))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue Num)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue cat)) (closingWedge >)) = (featureTemplateValue (atomicValue Num)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue ordinal)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue wh)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue indefinite)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DO_contraction)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number) (featurePath (atomicValue singular))))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number) (featurePath (atomicValue plural))))) (closingWedge >)) = (featureTemplateValue (atomicValue !+)) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue DP-initial)) ]) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue apposition)))) (closingWedge >)) = (featureTemplateValue (atomicValue -) (comment |17Jan03CB\r\n)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pronoun)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue proper)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comp_suffix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue negative_suffix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue negative_prefix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)))))))))))))))))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue ordinal)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue cat)) (closingWedge >)) = (featureTemplateValue (atomicValue !Adj)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue ordinal)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue indefinite)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue genitive_suffix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue negative_suffix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue negative_prefix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)))))))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue P)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue cat)) (closingWedge >)) = (featureTemplateValue (atomicValue !P)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue passive)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue wh)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue partitive)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue stand-alone)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue prefix_Prep)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue suffix_Pn)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (featureTemplateValue (atomicValue !direct)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue genitive_suffix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue locative)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-) (comment |21Apr03CB\r\n)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue NPrep)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-) (comment |22Jul06CB\r\n))))))))))))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue Poss)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue cat)) (closingWedge >)) = (featureTemplateValue (atomicValue !Poss)) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue genitive)) ]) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue negative_suffix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue negative_prefix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)))))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue Pron)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue cat)) (closingWedge >)) = (featureTemplateValue (atomicValue !Pron)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pronoun)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue proper)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue wh)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue animate)))) (closingWedge >)) = (featureTemplateValue (atomicValue !+)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue polarity)))) (closingWedge >)) = (featureTemplateValue (atomicValue !+)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue reciprocal)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue indefinite)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue human)))) (closingWedge >)) = (featureTemplateValue (atomicValue !+)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue generic)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (featureTemplateValue (atomicValue !direct)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue locative)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue temporal)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-final)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-initial)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DO_contraction)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue genitive_suffix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue apposition)))) (closingWedge >)) = (featureTemplateValue (atomicValue -) (comment |17Jan03CB\r\n)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue reflexivity)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-) (comment |17Feb03CB\r\n)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comp_suffix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue NPrep)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-) (comment |22Jul06CB\r\n)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue negative_suffix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue negative_prefix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)))))))))))))))))))))))))))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue Q)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue cat)) (closingWedge >)) = (featureTemplateValue (atomicValue Q)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue wh)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue indefinite)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pronoun)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue proper)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comp_suffix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue negative_suffix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue negative_prefix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)))))))))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue V)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue cat)) (closingWedge >)) = (featureTemplateValue (atomicValue !V)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue passive)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue sentential)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue copular)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue copular_suffix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue motion)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive_motion)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue reciprocal)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue finite)))) (closingWedge >)) = (featureTemplateValue (atomicValue !+)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue polarity)))) (closingWedge >)) = (featureTemplateValue (atomicValue !+)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue participle)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue mood) (featurePath (atomicValue realis))))) (closingWedge >)) = (featureTemplateValue (atomicValue !+)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue conj_suffix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue impersonal)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-) (comment |CB 24Jul06\r\n)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue tense) (featurePath (atomicValue present))))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue tense) (featurePath (atomicValue past))))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounded)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue participle_passive)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue rootgloss_V_2))) (closingWedge >)) = (featureTemplateValue (atomicValue none)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue object_agr_suffix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-) (comment |24May19\r\n)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue negative_suffix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue negative_prefix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue aspect) (featurePath (atomicValue perfective))))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue mood) (featurePath (atomicValue subjunctive))))) (closingWedge >)) = (featureTemplateValue (atomicValue !-) (comment |20Feb2020\r\n) (comment |- Farsi categories in AMPLE\r\n)))))))))))))))))))))))))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue AdjB)) be) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue Adj)) ]))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue NB)) be) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue N)) ]) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue NPrep)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-) (comment |22Jul06CB\r\n))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue PN)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue cat)) (closingWedge >)) = (featureTemplateValue (atomicValue !N)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue third))))) (closingWedge >)) = (featureTemplateValue (atomicValue !+)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue first))))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue second))))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number) (featurePath (atomicValue singular))))) (closingWedge >)) = (featureTemplateValue (atomicValue !+)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number) (featurePath (atomicValue plural))))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (featureTemplateValue (atomicValue !direct)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue polarity)))) (closingWedge >)) = (featureTemplateValue (atomicValue !+)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue animate)))) (closingWedge >)) = (featureTemplateValue (atomicValue !+)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue generic)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue wh)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue reciprocal)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue proper)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pronoun)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue human)))) (closingWedge >)) = (featureTemplateValue (atomicValue !+)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue indefinite)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-final)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-initial)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DO_contraction)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue genitive_suffix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue locative)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-) (comment |Feb03CB\r\n)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue apposition)))) (closingWedge >)) = (featureTemplateValue (atomicValue -) (comment |17Jan03CB\r\n)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comp_suffix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue finite)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue NPrep)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-) (comment |22Jul06CB\r\n)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue negative_suffix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue negative_prefix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)))))))))))))))))))))))))))))))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue PNP)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue cat)) (closingWedge >)) = (featureTemplateValue (atomicValue !N)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue third))))) (closingWedge >)) = (featureTemplateValue (atomicValue !+)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue first))))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue second))))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number) (featurePath (atomicValue singular))))) (closingWedge >)) = (featureTemplateValue (atomicValue !+)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number) (featurePath (atomicValue plural))))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (featureTemplateValue (atomicValue !direct)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue polarity)))) (closingWedge >)) = (featureTemplateValue (atomicValue !+)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue animate)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue wh)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue generic)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue reciprocal)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue proper)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pronoun)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue human)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue indefinite)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-final)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-initial)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DO_contraction)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue genitive_suffix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue locative)))) (closingWedge >)) = (featureTemplateValue (atomicValue !+) (comment | Feb03CB\r\n)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue apposition)))) (closingWedge >)) = (featureTemplateValue (atomicValue -) (comment |17Jan03CB\r\n)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comp_suffix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue finite)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue NPrep)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-) (comment |22Jul06CB\r\n)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue negative_suffix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue negative_prefix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)))))))))))))))))))))))))))))))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue Pn)) be) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue Pron)) ]) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue NPrep)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-) (comment |22Jul06CB\r\n))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue RefPn)) be) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue Pron)) ] (comment | 31Jan03 RL\r\n)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue reflexivity)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue locative)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue NPrep)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-) (comment |22Jul06CB\r\n))))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue GenericPn)) be) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue Pron)) ] (comment | 31Jan03 RL\r\n)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue reflexivity)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue generic)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue locative)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue NPrep)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-) (comment |22Jul06CB\r\n) (comment |generic pronouns are marked +reflexivity so only need a single constraint to cover both in rules, but also +generic in case a distinction needed  17Feb03 CB\r\n)))))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue Prep)) be) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue P)) ]))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue NPrep)) be) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue P)) ] (comment | 22Aug2019   \r\n)) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue locative)) ]) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue apposition)))) (closingWedge >)) = (featureTemplateValue (atomicValue -) (comment |17Jan03CB\r\n)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue NPrep)))) (closingWedge >)) = (featureTemplateValue (atomicValue +) (comment |22Jul06CB\r\n)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue translates2Prep)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)))))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue Cop)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue cat)) (closingWedge >)) = (featureTemplateValue (atomicValue !V)) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue V)) ]) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue copular)) ]))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue VActor)) be) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue N)) ]))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue VPres)) be) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue V)) ]) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue present)) ]) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue impersonal)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-) (comment |CB 24Jul06\r\n)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue aspect) (featurePath (atomicValue perfective))))) (closingWedge >)) = (featureTemplateValue (atomicValue !-))))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue VPast)) be) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue V)) ]) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue past)) ]) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue completive)) ]) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue impersonal)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-) (comment |CB 24Jul06\r\n)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue aspect) (featurePath (atomicValue perfective))))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)))))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue VSubj)) be) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue V)) ]) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue irrealis)) ]) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue impersonal)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-) (comment |CB 24Jul06\r\n)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue aspect) (featurePath (atomicValue perfective))))) (closingWedge >)) = (featureTemplateValue (atomicValue !-))))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue VPart)) be) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue V)) ]) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (featureTemplateValue (atomicValue !direct)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue impersonal)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-) (comment |CB 24Jul06\r\n)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue aspect) (featurePath (atomicValue perfective))))) (closingWedge >)) = (featureTemplateValue (atomicValue !-))))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue VPerf)) be) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue V)) ]) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue perfective)) ]) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue impersonal)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-) (comment |CB 24Jul06\r\n)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue aspect) (featurePath (atomicValue perfective))))) (closingWedge >)) = (featureTemplateValue (atomicValue !-))))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue VProg)) be) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue V)) ]) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue progressive)) ]) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue impersonal)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-) (comment |CB 24Jul06\r\n)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue aspect) (featurePath (atomicValue perfective))))) (closingWedge >)) = (featureTemplateValue (atomicValue !-))))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue VInf)) be) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue V)) ]) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue impersonal)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-) (comment |CB 24Jul06\r\n)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue aspect) (featurePath (atomicValue perfective))))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue Quest)) be) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue Adv)) ]))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue QPn)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue cat)) (closingWedge >)) = (featureTemplateValue (atomicValue Pron)) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue Pron)) ]) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue wh)) ]))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue Quote)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue cat)) (closingWedge >)) = (featureTemplateValue (atomicValue Quote) (comment |- override the default category.\r\n)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue DO)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue cat)) (closingWedge >)) = (featureTemplateValue (atomicValue Case)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue negative_suffix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue negative_prefix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-))))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue makeAux)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue cat)) (closingWedge >)) = (featureTemplateValue (atomicValue Aux)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue passive)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue finite)))) (closingWedge >)) = (featureTemplateValue (atomicValue !+)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue tense) (featurePath (atomicValue future))))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue mood) (featurePath (atomicValue realis))))) (closingWedge >)) = (featureTemplateValue (atomicValue !+)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue polarity)))) (closingWedge >)) = (featureTemplateValue (atomicValue !+)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue negative_suffix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue negative_prefix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue aspect) (featurePath (atomicValue perfective))))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue impersonal)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)))))))))))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue makeCase)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue cat)) (closingWedge >)) = (featureTemplateValue (atomicValue Case)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue negative_suffix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue negative_prefix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-))))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue makeAdv)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue cat)) (closingWedge >)) = (featureTemplateValue (atomicValue Adv)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue wh)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (featureTemplateValue (atomicValue !direct)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-final)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-initial)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue manner)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue temporal)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue locative)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)))))))))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue makeAdj)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue cat)) (closingWedge >)) = (featureTemplateValue (atomicValue Adj)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue ordinal)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue wh)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue indefinite)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue sentential)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP-initial)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue genitive_suffix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue negative_suffix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue negative_prefix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue attributive)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (featureTemplateValue (atomicValue !direct)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue impersonal)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-) (comment |CB 24Jul06\r\n)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with2)))) (closingWedge >)) = (featureTemplateValue (atomicValue !none)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with3)))) (closingWedge >)) = (featureTemplateValue (atomicValue !none)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with4)))) (closingWedge >)) = (featureTemplateValue (atomicValue !none)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue !unspecified))))))))))))))))))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue makeExcl)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue cat)) (closingWedge >)) = (featureTemplateValue (atomicValue Excl)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue force_Dem)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue cat)) (closingWedge >)) = (featureTemplateValue (atomicValue Dem)) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue Dem)) ])))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue force_Pn)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue cat)) (closingWedge >)) = (featureTemplateValue (atomicValue Pron)) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue Pron)) ])))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue force_Prep)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue cat)) (closingWedge >)) = (featureTemplateValue (atomicValue P)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue passive)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue wh)))) (closingWedge >)) = (featureTemplateValue (atomicValue -)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue partitive)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (featureTemplateValue (atomicValue !direct)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue stand-alone)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue locative)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-) (comment |21Apr03CB\r\n))))))))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue force_V)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue cat)) (closingWedge >)) = (featureTemplateValue (atomicValue V)) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue V)) ]) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue impersonal)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-) (comment |CB 24Jul06\r\n)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue aspect) (featurePath (atomicValue perfective))))) (closingWedge >)) = (featureTemplateValue (atomicValue !-) (comment |- Farsi categories in FLEX *** newly added 2019 to mirror category mapper in PAWS \r\n))))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue adj)) be) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue Adj)) ]))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue adv)) be) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue Adv)) ]))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue aux)) be) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue Aux)) ]))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue conn)) be) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue Conj)) ]))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue deg)) be) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue Deg)) ]))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue dem)) be) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue Dem)) ]))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue indf)) be) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue Art)) ]))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue interj)) be) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue Excl)) ]))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue interogpro-form)) be) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue Pron)) ]) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue wh)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue third))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue interrogative)) ])))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue n)) be) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue N)) ]))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue n-irreg)) be) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue N)) ]))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue npl)) be) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue N)) ]) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number) (featurePath (atomicValue plural))))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number) (featurePath (atomicValue singular))))) (closingWedge >)) = (featureTemplateValue (atomicValue -)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue nprep)) be) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue NPrep)) ]))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue nprop)) be) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue PN)) ]))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue num)) be) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue Num)) ]))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue pers)) be) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue Pron)) ] (comment |16Aug2019\r\n)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue personal)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue human)))) (closingWedge >)) = (featureTemplateValue (atomicValue +) (comment |21Aug2019\r\n)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue post)) be) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue P)) ]) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue translates2Prep)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue prep)) be) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue P)) ]) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue translates2Prep)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue pro)) be) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue Pron)) ]))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue prt)) be) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue N)) ] (comment | trying for particle 16Aug19\r\n)))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue quant)) be) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue Q)) ]))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue v)) be) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue V)) ]))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue vcomp)) be) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue V)) ]) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (featureTemplateValue (atomicValue +) (comment |16Aug2019\r\n))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue cop)) be) (featurePathTemplateBody (featureTemplateAbbreviation [ (featureTemplateName (atomicValue V)) ]) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue copular)))) (closingWedge >)) = (featureTemplateValue (atomicValue +)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)) = (featureTemplateValue (atomicValue -) (comment |19Aug2019\r\n)))))) (featureTemplate (featureTemplateDefinition Let (featureTemplateName (atomicValue vphrase)) be) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue cat)) (closingWedge >)) = (featureTemplateValue (atomicValue VP)) (featurePathTemplateBody (featurePathUnit (openingWedge <) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue object_agr_suffix)))) (closingWedge >)) = (featureTemplateValue (atomicValue !-) (comment |24May19\r\n) (comment |---------------------------------------------------------------------\r\n) (comment |-Phrase structure rules\r\n)))))) (patrRules (patrRule (ruleKW rule) (ruleIdentifier { testing } S = AdvP / DP |/ VP / PP \r\n < S head > = < AdvP head > < S head > = < DP head > |    <S head> = <VP head>\r\n |    <S head> = <PP head>\r\n rule { S option start symbol - final ya na & Quote allowed }) (phraseStructureRule (nonTerminal S) (ruleDef =) (rightHandSide (disjunctiveTerminals { (nonTerminal IP) (disjunctionNonTerminal / (nonTerminal CP)) }) (optionalTerminals ( (nonTerminal Conj) (nonTerminal Deg) )) (optionalTerminals ( (nonTerminal Quote) )))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal S) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal S) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal CP) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue root)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue conj_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 16Jul03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal CP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue root)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal CP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue conj_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 16Jul03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal CP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 21Nov03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue gloss)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue or)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue CP-final)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue CP-final)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue polarity)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal S) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue initialP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not a rel clause 21Nov03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal CP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not a rel clause 21Nov03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal S) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue start)))))) (patrRule (ruleKW rule) (ruleIdentifier { S option startInitPP symbol with PP initial elements and final ya na & Quote allowed }) (phraseStructureRule (nonTerminal S) (ruleDef =) (rightHandSide (nonTerminal InitP) (disjunctiveTerminals { (nonTerminal IP) (disjunctionNonTerminal / (nonTerminal CP)) }) (optionalTerminals ( (nonTerminal Conj) (nonTerminal Deg) )) (optionalTerminals ( (nonTerminal Quote) )))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal S) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal S) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal CP) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head) (featurePath (atomicValue subject))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue subject))) (closingWedge >) (comment | pass reflexive info\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal CP) (featurePath (atomicValue head) (featurePath (atomicValue subject))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue subject))) (closingWedge >) (comment | pass reflexive info\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue root)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pro-drop)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 28May19 CB \r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue conj_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 16Jul03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal CP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue root)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal CP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue conj_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 16Jul03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal CP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 21Nov03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue root)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue gloss)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue or)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue CP-final)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue CP-final)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue polarity)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal S) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue initialP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue PP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | 17Feb03 CB for generic/reflex\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 17Feb03 CB for generic/reflex\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not a rel clause 21Nov03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal CP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not a rel clause 21Nov03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal S) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue startInitPP)))))) (patrRule (ruleKW rule) (ruleIdentifier { S option startInitDP with DP initial elements and final ya na & Quote allowed }) (phraseStructureRule (nonTerminal S) (ruleDef =) (rightHandSide (nonTerminal InitP) (nonTerminal IP) (optionalTerminals ( (nonTerminal Conj) (nonTerminal Deg) )) (optionalTerminals ( (nonTerminal Quote) )))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal S) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head) (featurePath (atomicValue subject))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue subject))) (closingWedge >) (comment | pass reflexive info\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue root)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pro-drop)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 28May19 \r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue conj_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 16Jul03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue root)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue gloss)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue or)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue CP-final)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue CP-final)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue polarity)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal S) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue initialP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (disjunctiveUnificationConstraint { (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 03Apr03 CB\r\n))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment |  relcl in InitP only with overt subject\r\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pro-drop)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) }))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | 17Feb03 CB for generic/reflex\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue PP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 17Feb03 CB for generic/reflex\r\n)) (comment | don't split coordination - these replace logical constraints in subject rules that incorrectly eliminated even adverbial InitPs 17Apr03 CB\r\n))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head)) (closingWedge >)) == (logConstraintExpression ~ (logConstraintFactor ( (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue subject)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue type)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue coordination)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (binop &) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue type)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue pro-drop)) : (featureStructureValue (atomicValue -)) (closingBracket ]))) (closingBracket ])))) ))))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head)) (closingWedge >)) == (logConstraintExpression ~ (logConstraintFactor ( (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue object)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue type)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue coordination)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (binop &) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue type)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue pro-drop)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (closingBracket ])))) ))))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not a rel clause 21Nov03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal S) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue startInitDP)))))) (patrRule (ruleKW rule) (ruleIdentifier { S option startCPInitDP with DP initial elements and final ya na & Quote allowed }) (phraseStructureRule (nonTerminal S) (ruleDef =) (rightHandSide (nonTerminal InitP) (nonTerminal CP) (optionalTerminals ( (nonTerminal Conj) (nonTerminal Deg) )) (optionalTerminals ( (nonTerminal Quote) )))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal S) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal CP) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal CP) (featurePath (atomicValue head) (featurePath (atomicValue subject))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue subject))) (closingWedge >) (comment | pass reflexive info\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal CP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue root)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal CP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue conj_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 16Jul03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal CP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 21Nov03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue root)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue gloss)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue or)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue CP-final)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue CP-final)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue polarity)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal S) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue initialP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | 17Feb03 CB for generic/reflex\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue PP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 17Feb03 CB for generic/reflex\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal S) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue startCPInitDP)))))) (patrRule (ruleKW rule) (ruleIdentifier { S option startInit with nonPP/ DP initial elements and final ya na & Quote allowed }) (phraseStructureRule (nonTerminal S) (ruleDef =) (rightHandSide (nonTerminal InitP) (disjunctiveTerminals { (nonTerminal IP) (disjunctionNonTerminal / (nonTerminal CP)) }) (optionalTerminals ( (nonTerminal Conj) (nonTerminal Deg) )) (optionalTerminals ( (nonTerminal Quote) )))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal S) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal S) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal CP) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue root)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue conj_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 16Jul03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal CP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue root)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal CP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue conj_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 16Jul03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal CP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 21Nov03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue root)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue gloss)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue or)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue CP-final)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue CP-final)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue polarity)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal S) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue initialP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue PP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 17Feb03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 17Feb03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not a rel clause 21Nov03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal CP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not a rel clause 21Nov03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal S) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue startInit)))))) (patrRule (ruleKW rule) (ruleIdentifier { InitP option conj - conjunctions - root or nonroot }) (phraseStructureRule (nonTerminal InitP) (ruleDef =) (rightHandSide (nonTerminal Conj) (optionalTerminals ( (nonTerminal Conj_2) )))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head)) (closingWedge >) (comment |    <InitP head type comma> = +     |need this to have sentences that start with "w" (and)   | must have comma  ***trying removal of comma requirement 28Jan03 CB \r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue initialP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | restrict conjunctions here and in DP \r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue CP-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue CP-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue PP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 17Feb03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 17Feb03 CB\r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal Conj_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue conj)))))) (patrRule (ruleKW rule) (ruleIdentifier { InitP option adv - AdvP - root or nonroot }) (phraseStructureRule (nonTerminal InitP) (ruleDef =) (rightHandSide (optionalTerminals ( (nonTerminal Conj) )) (nonTerminal AdvP) (optionalTerminals ( (nonTerminal Conj_2) )))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal AdvP) (featurePath (atomicValue head)) (closingWedge >) (comment |RL 19Nov02    <InitP head type comma> = +        | must have comma\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue initialP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | restrict occurrence in sentential PPs \r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal AdvP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue CP-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | mark Adv as -CP-initial if not manner but cannot occur clause initial \r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal AdvP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue manner)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue CP-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue CP-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue PP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 17Feb03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 17Feb03 CB\r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal Conj_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue adv)))))) (patrRule (ruleKW rule) (ruleIdentifier { InitP option excl - Exclamation - root or nonroot }) (phraseStructureRule (nonTerminal InitP) (ruleDef =) (rightHandSide (optionalTerminals ( (nonTerminal Conj) )) (nonTerminal Excl) (optionalTerminals ( (nonTerminal Conj_2) )))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal Excl) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | must have comma\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue initialP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | restrict conjunctions here and in DP \r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue CP-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue CP-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue PP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 17Feb03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 17Feb03 CB\r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal Conj_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue excl) (comment |this rule will also include subject DPs with relative clauses and comma in nonroot IPs\r\n)))))) (patrRule (ruleKW rule) (ruleIdentifier { InitP option address - DP address or focus/topic - root or nonroot }) (phraseStructureRule (nonTerminal InitP) (ruleDef =) (rightHandSide (disjunctiveOptionalNonTerminal ( (nonTerminal Conj) (disjunctionOptionalNonTerminal / (nonTerminal Excl)) )) (nonTerminal DP))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue initialP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | restrict conjunctions here and in DP \r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | must have comma\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue subject))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >) (comment | pass reflexive info\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue CP-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not a DP coordination construction\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue nonfinalcoordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DO_contraction)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 17Feb03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue nominative)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | for apposition \r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue PP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 17Feb03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | 17Feb03 CB\r\n)))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relative)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relcl)) : (featureStructureValue (atomicValue +)) (closingBracket ]) (comment | require rel suffix to only occur when relative clause present\r\n)))))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue address) (comment | RL 28Mar03 add this rule\r\n)))))) (patrRule (ruleKW rule) (ruleIdentifier { InitP option address2 - DP address or focus/topic - root or nonroot }) (phraseStructureRule (nonTerminal InitP) (ruleDef =) (rightHandSide (nonTerminal Conj) (nonTerminal Excl) (nonTerminal DP))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue initialP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | restrict conjunctions here and in DP \r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | must have comma\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue subject))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >) (comment | pass reflexive info\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue CP-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not a DP coordination construction\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue nonfinalcoordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DO_contraction)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 17Feb03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | for apposition 22Jan03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue PP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 17Feb03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | 17Feb03 CB\r\n)))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relative)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relcl)) : (featureStructureValue (atomicValue +)) (closingBracket ]) (comment | require rel suffix to only occur when relative clause present\r\n)))))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue address2) (comment | RL 10Dec02\r\n)))))) (patrRule (ruleKW rule) (ruleIdentifier { InitP option address_conjoined - DP address or focus/topic - root or nonroot }) (phraseStructureRule (nonTerminal InitP) (ruleDef =) (rightHandSide (nonTerminal Excl) (nonTerminal DP) (nonTerminal Conj) (optionalTerminals ( (nonTerminal Excl_2) )) (nonTerminal DP_2))) (comment | e.g. Acts 13:16 <<ay mrdan asraYyly w ay Gyryhwdyan Xdatrs, KwS fra^^dhyd!\r\n) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue initialP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | restrict conjunctions here and in DP \r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | must have comma\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue subject))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >) (comment | pass reflexive info\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue subject))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >) (comment | pass reflexive info\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not a DP coordination construction\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue nonfinalcoordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | adjective/apposition 17Apr03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | adjective/apposition 17Apr03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not a DP_2 coordination construction\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue nonfinalcoordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue PP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 17Feb03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | 17Feb03 CB\r\n)))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relative)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relcl)) : (featureStructureValue (atomicValue +)) (closingBracket ]) (comment | require rel suffix to only occur when relative clause present\r\n)))))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relative)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relcl)) : (featureStructureValue (atomicValue +)) (closingBracket ]) (comment | require rel suffix to only occur when relative clause present\r\n)))))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue address_conjoined)))))) (patrRule (ruleKW rule) (ruleIdentifier { InitP option manner PP - root only }) (phraseStructureRule (nonTerminal InitP) (ruleDef =) (rightHandSide (disjunctiveOptionalNonTerminal ( (nonTerminal Conj) (disjunctionOptionalNonTerminal / (nonTerminal Adv)) )) (nonTerminal PP) (optionalTerminals ( (nonTerminal Conj_2) )))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal PP) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | must have comma\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue root)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue subject))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal PP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >) (comment | pass reflexive info\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue initialP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | restrict occurrence in sentential PPs \r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Adv) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue reason)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal PP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue manner)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal PP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue temporal)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal PP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue locative)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment |    <PP head type passive> = -          | this may not work, remove if passive P can be here\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal PP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue stranded)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment |- PP must have overt complement\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue CP-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue CP-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue PP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | 17Feb03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 17Feb03 CB\r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal Conj_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue mannerPP)))))) (patrRule (ruleKW rule) (ruleIdentifier { InitP option tempPP - temporal PP - root only }) (phraseStructureRule (nonTerminal InitP) (ruleDef =) (rightHandSide (disjunctiveOptionalNonTerminal ( (nonTerminal Conj) (disjunctionOptionalNonTerminal / (nonTerminal Adv)) )) (nonTerminal PP) (optionalTerminals ( (nonTerminal Conj_2) )))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal PP) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | must have comma\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue root)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue subject))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal PP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >) (comment | pass reflexive info\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue initialP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | restrict occurrence in sentential PPs \r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Adv) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue reason)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal PP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue temporal)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal PP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue manner)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal PP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue locative)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal PP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue passive)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | this may not work, remove if passive P can be here\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal PP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue stranded)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment |- PP must have overt complement\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue CP-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue CP-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue PP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | 17Feb03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 17Feb03 CB\r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal Conj_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue tempPP)))))) (patrRule (ruleKW rule) (ruleIdentifier { InitP option locPP - locative PP - comma not required - root only } InitP = ( Conj ( Conj_1 ) / Adv ) PP ( Conj_2 ) < InitP head > = < PP head > < InitP head type root > = + < InitP head subject > = < PP head reflexive > | pass reflexive info\r\n < InitP head type initialP > = + | restrict occurrence in sentential PPs \r\n < Adv head type reason > = + < Adv head type temporal > = - < PP head type manner > = - < PP head type locative > = + < PP head type temporal > = - < PP head type passive > = - < PP head type stranded > = - |- PP must have overt complement\r\n < Conj head type CP-initial > = + < Conj_1 head type CP-initial > = + < Conj_2 head type CP-initial > = + < InitP head type PP > = + | 17Feb03 CB\r\n < InitP head type DP > = - | 17Feb03 CB\r\n < InitP head type comma > <= < Conj_2 head type comma > < InitP rule > = locPP | separated off from locPP rule to avoid possibility of stranded Conj **19Jul06 CB  | 23Jan03 RL removed passive restriction in locPP above E.g. az nsl ayn mrd \r\n rule { InitP option passivePP - comma not required - root only } InitP = ( Conj ( Conj_1 ) / Adv ) PP < InitP head > = < PP head > < InitP head type root > = + < InitP head subject > = < PP head reflexive > | pass reflexive info\r\n < InitP head type initialP > = + | restrict occurrence in sentential PPs \r\n < Adv head type reason > = + < Adv head type temporal > = - < PP head type manner > = - < PP head type temporal > = - < PP head type passive > = + | 23Jan03 RL removed passive restriction. E.g. az nsl ayn mrd  |this may not work, remove if passive P can be here\r\n < PP head type stranded > = - |- PP must have overt complement\r\n < Conj head type CP-initial > = + < Conj_1 head type CP-initial > = + < InitP head type PP > = + | 17Feb03 CB\r\n < InitP head type DP > = - | 17Feb03 CB\r\n < InitP head type comma > <= < Conj_1 head type comma > < InitP rule > = passivePP rule { InitP option CP - adverbial CP - root only }) (phraseStructureRule (nonTerminal InitP) (ruleDef =) (rightHandSide (optionalTerminals ( (nonTerminal Conj/InitP_2) )) (nonTerminal CP) (optionalTerminals ( (nonTerminal Conj_2) ) (comment | RL 07Dec02 allow another InitP inside this InitP e.g.: "bradran, aKr pnd w andrzy bray mrdm daryd, bKwyyd."\r\n)))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal CP) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | must have comma\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue root)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue initialP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | restrict occurrence in sentential PPs \r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | must have comma | RL 07Dec02 added\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue subject))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal InitP_2) (featurePath (atomicValue head) (featurePath (atomicValue subject))) (closingWedge >) (comment | pass reflexive info\r\n)) (comment |    <CP head type root> = -           | removed 02Dec02 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal CP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue conj_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 16Jul03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal CP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 21Nov03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue CP-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue CP-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue PP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 17Feb03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 17Feb03 CB\r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal Conj_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal InitP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue CP) (comment |-***********************************************************\r\n)))))) (patrRule (ruleKW rule) (ruleIdentifier { CP option 1 - no fronting, root or non-root }) (phraseStructureRule (nonTerminal CP) (ruleDef =) (rightHandSide (nonTerminal C'))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal CP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal C') (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal CP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 1) (comment |-**********************************************************\r\n)))))) (patrRule (ruleKW rule) (ruleIdentifier { C' option 1c - head-initial, question, root }) (phraseStructureRule (nonTerminal C') (ruleDef =) (rightHandSide (nonTerminal C) (nonTerminal IP))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal C') (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal C') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue question)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal C) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue question)))) (closingWedge >) (comment | amended 02Dec02 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal C') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue root)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal C) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue root)))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal C') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue root)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal C') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue question)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal C) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal C) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue CP-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal C') (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 1c)))))) (patrRule (ruleKW rule) (ruleIdentifier { C' option 1creason - head-initial, reason, root }) (phraseStructureRule (nonTerminal C') (ruleDef =) (rightHandSide (nonTerminal C) (nonTerminal IP))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal C') (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal C') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue question)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal C) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue question)))) (closingWedge >) (comment | amended 02Dec02 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal C') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue reason)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal C) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue reason)))) (closingWedge >) (comment | amended 02Dec02 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal C') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue root)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal C') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue question)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal C) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue reason)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal C) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal C) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue CP-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal C') (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 1creason)))))) (patrRule (ruleKW rule) (ruleIdentifier { C' option 2c - head-initial, question, non-root }) (phraseStructureRule (nonTerminal C') (ruleDef =) (rightHandSide (optionalTerminals ( (nonTerminal C_1) )) (nonTerminal C_2) (nonTerminal IP))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal C') (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal C') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue question)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal C_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue question)))) (closingWedge >) (comment |amended 02Dec02 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal C') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue root)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal C_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue root)))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal C') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue root)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal C_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal C_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal C_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue question)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal C_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue question)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal C_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue CP-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal C_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue CP-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal C') (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 2c)))))) (patrRule (ruleKW rule) (ruleIdentifier { C' option 2j - head-initial, non-question, non-root }) (phraseStructureRule (nonTerminal C') (ruleDef =) (rightHandSide (nonTerminal C) (nonTerminal IP))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal C') (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal C') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue question)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal C) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue question)))) (closingWedge >) (comment | RL 13Feb02 if IP has a comma and C doesn't they can't unify for type.\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal C') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue root)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal C') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue question)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal C) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal C) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue CP-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal C) (featurePath (atomicValue embedded)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head) (featurePath (atomicValue embedded))) (closingWedge >) (comment | pass subcategorization down\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal C') (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 2j) (comment |-***********************************************************\r\n)))))) (patrRule (ruleKW rule) (ruleIdentifier { IP option 0 - conjoined IPs }) (phraseStructureRule (nonTerminal IP) (ruleDef =) (rightHandSide (nonTerminal IP_1) (nonTerminal Conj) (nonTerminal IP_2))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal IP_1) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | limit recursion\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP_1) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pro-drop)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue root)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal IP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue root)))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP_1) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue mood) (featurePath (atomicValue realis))))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal IP_2) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue mood) (featurePath (atomicValue realis))))) (closingWedge >) (comment | 15Jul03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue conjoins_IP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal IP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) (comment | comma placement for InitP\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not a rel clause 21Nov03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not a rel clause 21Nov03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 0)))))) (patrRule (ruleKW rule) (ruleIdentifier { IP option 0a-DP - missing final verb IPs }) (phraseStructureRule (nonTerminal IP) (ruleDef =) (rightHandSide (nonTerminal IP_1) (nonTerminal Conj) (nonTerminal DP))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal IP_1) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head) (featurePath (atomicValue subject))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >) (comment | pass reflexive info\r\n)))) (constraint (unificationConstraint (disjunctiveUnificationConstraint { (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue objective))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) }))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue conjoined)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | mark for checking compounding constraints (special case with relcl2+kh and 5c) 20Oct03 CB\r\n))) (constraint (comment |?|    <IP head type final-conjunct compounds_with1> = <DP head type compounds_with1>\r\n)) (constraint (comment |?|    <IP head type final-conjunct compounds_with2> = <DP head type compounds_with2>\r\n)) (constraint (comment |?|    <IP head type final-conjunct compounds_with3> = <DP head type compounds_with3>\r\n)) (constraint (comment |?|    <IP head type final-conjunct compounds_with4> = <DP head type compounds_with4>\r\n)) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) (comment | comma placement for InitP\r\n))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relative)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relcl)) : (featureStructureValue (atomicValue +)) (closingBracket ]) (comment | require rel suffix to only occur when relative clause present\r\n)))))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (closingWedge >)) == (logConstraintExpression ~ (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue gloss)) : (featureStructureValue (atomicValue namely)) (closingBracket ])))))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 0a-DP) (comment | for ygny type apposition/coordination/relativization, added 24Mar03 CB\r\n)))))) (patrRule (ruleKW rule) (ruleIdentifier { IP option 0a-ygny - "ygny"-type apposition }) (phraseStructureRule (nonTerminal IP) (ruleDef =) (rightHandSide (nonTerminal IP_1) (nonTerminal Conj) (nonTerminal DP))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal IP_1) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | must have comma when at end\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head) (featurePath (atomicValue subject))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >) (comment | pass reflexive info\r\n)))) (constraint (unificationConstraint (disjunctiveUnificationConstraint { (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue objective))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) }))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue gloss)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue namely)))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relative)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relcl)) : (featureStructureValue (atomicValue +)) (closingBracket ]) (comment | require rel suffix to only occur when relative clause present\r\n)))))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue Oa-ygny) (comment | for ygny type apposition/coordination/relativization, added 24Mar03 CB\r\n)))))) (patrRule (ruleKW rule) (ruleIdentifier { IP option 0a-ygnyPP - "ygny"-type apposition with PP }) (phraseStructureRule (nonTerminal IP) (ruleDef =) (rightHandSide (nonTerminal IP_1) (nonTerminal Conj) (nonTerminal PP))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal IP_1) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | must have comma when at end\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue gloss)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue namely)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head) (featurePath (atomicValue subject))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal PP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >) (comment | pass reflexive info\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal PP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue sentential)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue Oa-ygnyPP)))))) (patrRule (ruleKW rule) (ruleIdentifier { IP option 0a-AdjP - missing final verb IPs }) (phraseStructureRule (nonTerminal IP) (ruleDef =) (rightHandSide (nonTerminal IP_1) (nonTerminal Conj) (nonTerminal AdjP))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal IP_1) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal AdjP) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal AdjP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) (comment | comma placement for InitP\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 0a-AdjP)))))) (patrRule (ruleKW rule) (ruleIdentifier { IP option 0b - 2 IPs, initial IP in participle form }) (phraseStructureRule (nonTerminal IP) (ruleDef =) (rightHandSide (nonTerminal IP_1) (nonTerminal IP_2))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal IP_2) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | limit recursion\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP_1) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue conj_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | allow the participle suffix to serve as a conjunction.\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | 13Mar03 CB added per Ron\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue root)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal IP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue root)))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP_1) (featurePath (atomicValue head) (featurePath (atomicValue subject))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal IP_2) (featurePath (atomicValue head) (featurePath (atomicValue subject))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue auxiliary)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | RL 10Feb03 No auxiliaries. E.g. we don't want this sentence from Acts 13:26 to be handled here 'ayn pyam njat bray ma frstadh Sdh ast.'\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not a rel clause 21Nov03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not a rel clause 21Nov03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 0b) (comment |*****split rule for impersonalV and then non-past and pst transitive*****\r\n)))))) (patrRule (ruleKW rule) (ruleIdentifier { IP option 2cImpersonalV - subject initial, required, root clause } IP = DP I' < IP head > = < I' head > < IP head type root > = + < IP head type pro-drop > = - < IP head subject head agr > = < DP head reflexive head agr > | pass reflexive info\r\n { < DP head type comma > = - < DP head type apposition > = - / < DP head type apposition > = + | 17Jan03  CB\r\n / < DP head type apposition > = namely | 21Nov03  CB\r\n / < DP head type relcl > = + | can have comma if relcl 27Jan03 CB\r\n < DP head type comma > = + < DP head type apposition > = - } < I' head subject > = < DP > < I' head type impersonal > = + | impersonal verbs do not agree **24Jul06 CB\r\n < IP head subject head type > = < DP head type > | pass DP type features for compounding, regardless of agreement 17Apr03 CB\r\n < IP head subject head possessor > = < DP head possessor > | pass DP possessor info for compounding, regardless of agreement 17Apr03 CB\r\n { < DP head case > = oblique < DP head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < DP head agr person third > = + / < DP head agr person first > = + | pronouns different case CB 23May19\r\n < DP head case > = objective < DP head case_for_position > = objective | to know normal case for conjoined DPs\r\n / < DP head agr person second > = + | pronouns different case CB 23May19\r\n < DP head case > = objective < DP head case_for_position > = objective | to know normal case for conjoined DPs\r\n } < DP head type DO_contraction > = - | 17Feb03 CB\r\n < DP head type case-marked > = - < DP head type nonfinalcoordination > = - < DP > == ~ [ mother_node : - ] | if coordination, must be allowed initially\r\n < DP > == [ mother_node : + ] -> [ head : [ type : [ coordination : + ] ] ] |and be complete\r\n < DP head type > == [ relative : + ] -> [ relcl : + ] | require rel suffix to only occur when relative clause present\r\n < IP head > == [ type : [ reciprocal : + ] ] -> [ subject : [ head : [ agr : [ number : [ plural : + ] ] ] ] ] < IP head > == [ object : [ head : [ type : [ reciprocal : + ] ] ] ] -> [ subject : [ head : [ agr : [ number : [ plural : + ] ] ] ] ] < IP head > == [ object : [ head : [ infl : [ polarity : - ] ] ] ] -> |if the object is negative, the verb must be negative\r\n [ infl : [ polarity : - ] ] < IP head > == [ subject : [ head : [ infl : [ polarity : - ] ] ] ] -> |if the subject is negative, the verb must be negative\r\n [ infl : [ polarity : - ] ] < IP head > == ~ [ object : [ head : [ type : [ conjunction_gloss : initial_ya ] ] ] ] | to restrict splitting between subject and object\r\n ||    <IP head> == [subject:[head:[type:[coordination:+]]]] ->\r\n ||                ~[type:[initialP:+]]\r\n < IP head > == ( ( ( [ subject : [ head : [ participle : [ cat : V ] ] ] ] / [ subject : [ head : [ possessor : [ head : [ participle : [ cat : V ] ] ] ] ] ] ) ) & ( [ type : [ no_intervening : + ] ] ) ) -> ( ( [ type : [ auxiliary : - copular : - passive : - ] ] / [ type : [ auxiliary : + participle : + ] ] ) / [ type : [ participle_passive : + ] ] ) | to force participle to be w/ V or Aux 12-APR-04\r\n < IP head > == [ rootgloss : ^1 ] -> ~ ( [ type : [ no_intervening : + ] ] & ( ( [ subject : [ head : [ type : [ compounds_with1 : ^1 ] ] ] ] / [ subject : [ head : [ type : [ compounds_with2 : ^1 ] ] ] ] ) / ( [ subject : [ head : [ type : [ compounds_with3 : ^1 ] ] ] ] / [ subject : [ head : [ type : [ compounds_with4 : ^1 ] ] ] ] ) ) ) < IP head > == [ rootgloss : ^1 ] -> ~ ( [ type : [ no_intervening : + ] ] & ( ( [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with1 : ^1 ] ] ] ] ] ] / [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with2 : ^1 ] ] ] ] ] ] ) / ( [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with3 : ^1 ] ] ] ] ] ] / [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with4 : ^1 ] ] ] ] ] ] ) ) ) < IP head > == [ object : [ head : [ rootgloss : ^1 ] ] ] -> ~ ( ( [ subject : [ head : [ type : [ compounds_with1 : ^1 ] ] ] ] / [ subject : [ head : [ type : [ compounds_with2 : ^1 ] ] ] ] ) / ( [ subject : [ head : [ type : [ compounds_with3 : ^1 ] ] ] ] / [ subject : [ head : [ type : [ compounds_with4 : ^1 ] ] ] ] ) ) < IP head > == [ object : [ head : [ rootgloss : ^1 ] ] ] -> ~ ( ( [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with1 : ^1 ] ] ] ] ] ] / [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with2 : ^1 ] ] ] ] ] ] ) / ( [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with3 : ^1 ] ] ] ] ] ] / [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with4 : ^1 ] ] ] ] ] ] ) ) < IP rule > = 2cImpersonalV rule { IP option 2cINon-ImpersonalVNonPast - subject initial, required, root clause } IP = DP I' < IP head > = < I' head > < IP head type root > = + < IP head type pro-drop > = - < IP head subject head agr > = < DP head reflexive head agr > | pass reflexive info\r\n |    {<DP head type comma> = -                    ||* 22Aug2019 causing failure\r\n |     <DP head type apposition> = -\r\n |    /<DP head type apposition> = +    | 17Jan03  CB\r\n |    /<DP head type apposition> = namely    | 21Nov03  CB\r\n |    /<DP head type relcl> = +        | can have comma if relcl 27Jan03 CB\r\n |     <DP head type comma> = +\r\n |     <DP head type apposition> = -\r\n |    }\r\n < I' head type impersonal > = - < I' head infl tense past > = - < I' head subject > = < DP > |    /<DP head type human> = -                       | only for impersonal V??  22Aug2019 failures\r\n |     <DP head agr person third> = +\r\n |     <DP head agr number plural> = +\r\n |     <I' head subject head agr number singular> = +\r\n |     <I' head subject head agr number plural> = -\r\n |     <I' head subject head agr person second> = -       | RL 2Feb02 allow 1st and 3rd person, but not 2nd.\r\n |    }\r\n |    <IP head subject head type> = <DP head type>  | pass DP type features for compounding, regardless of agreement 17Apr03 CB\r\n |    <IP head subject head possessor> = <DP head possessor> | pass DP possessor info for compounding, regardless of agreement 17Apr03 CB\r\n < DP head case_for_position > = direct | to know normal case for conjoined DPs\r\n < DP head case > = direct < DP head type DO_contraction > = - | 17Feb03 CB\r\n < DP head type case-marked > = - < DP head type nonfinalcoordination > = - < DP > == ~ [ mother_node : - ] | if coordination, must be allowed initially\r\n < DP > == [ mother_node : + ] -> [ head : [ type : [ coordination : + ] ] ] |and be complete\r\n < IP head > == [ object : [ head : [ infl : [ polarity : - ] ] ] ] -> |if the object is negative, the verb must be negative\r\n [ infl : [ polarity : - ] ] < IP head > == [ subject : [ head : [ infl : [ polarity : - ] ] ] ] -> |if the subject is negative, the verb must be negative\r\n [ infl : [ polarity : - ] ] < IP head > == ~ [ object : [ head : [ type : [ conjunction_gloss : initial_ya ] ] ] ] | to restrict splitting between subject and object\r\n < IP head > == [ subject : [ head : [ type : [ coordination : + ] ] ] ] -> ~ [ type : [ initialP : + ] ] < IP head > == ( ( ( [ subject : [ head : [ participle : [ cat : V ] ] ] ] / [ subject : [ head : [ possessor : [ head : [ participle : [ cat : V ] ] ] ] ] ] ) ) & ( [ type : [ no_intervening : + ] ] ) ) -> ( ( [ type : [ auxiliary : - copular : - passive : - ] ] / [ type : [ auxiliary : + participle : + ] ] ) / [ type : [ participle_passive : + ] ] ) | to force participle to be w/ V or Aux 12-APR-04\r\n < IP head > == [ rootgloss : ^1 ] -> ~ ( [ type : [ no_intervening : + ] ] & ( ( [ subject : [ head : [ type : [ compounds_with1 : ^1 ] ] ] ] / [ subject : [ head : [ type : [ compounds_with2 : ^1 ] ] ] ] ) / ( [ subject : [ head : [ type : [ compounds_with3 : ^1 ] ] ] ] / [ subject : [ head : [ type : [ compounds_with4 : ^1 ] ] ] ] ) ) ) < IP head > == [ rootgloss : ^1 ] -> ~ ( [ type : [ no_intervening : + ] ] & ( ( [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with1 : ^1 ] ] ] ] ] ] / [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with2 : ^1 ] ] ] ] ] ] ) / ( [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with3 : ^1 ] ] ] ] ] ] / [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with4 : ^1 ] ] ] ] ] ] ) ) ) < IP head > == [ object : [ head : [ rootgloss : ^1 ] ] ] -> ~ ( ( [ subject : [ head : [ type : [ compounds_with1 : ^1 ] ] ] ] / [ subject : [ head : [ type : [ compounds_with2 : ^1 ] ] ] ] ) / ( [ subject : [ head : [ type : [ compounds_with3 : ^1 ] ] ] ] / [ subject : [ head : [ type : [ compounds_with4 : ^1 ] ] ] ] ) ) < IP head > == [ object : [ head : [ rootgloss : ^1 ] ] ] -> ~ ( ( [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with1 : ^1 ] ] ] ] ] ] / [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with2 : ^1 ] ] ] ] ] ] ) / ( [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with3 : ^1 ] ] ] ] ] ] / [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with4 : ^1 ] ] ] ] ] ] ) ) < IP rule > = 2cINon-ImpersonalVNonPast rule { IP option 2cINon-ImpersonalV-PastIntransitive - subject initial, required, root clause } IP = DP I' < IP head > = < I' head > < IP head type root > = + < IP head type pro-drop > = - { < DP head type comma > = - < DP head type apposition > = - / < DP head type apposition > = + | 17Jan03  CB\r\n / < DP head type apposition > = namely | 21Nov03  CB\r\n / < DP head type relcl > = + | can have comma if relcl 27Jan03 CB\r\n < DP head type comma > = + < DP head type apposition > = - } < I' head type impersonal > = - < I' head infl tense past > = + < I' head infl tense future > = - | Not future Apr2020\r\n < I' head type transitive > = - { < I' head subject > = < DP > / < DP head type human > = - < DP head agr person third > = + < DP head agr number plural > = + < I' head subject head agr number singular > = + < I' head subject head agr number plural > = - < I' head subject head agr person second > = - | RL 2Feb02 allow 1st and 3rd person, but not 2nd.\r\n } < IP head subject head type > = < DP head type > | pass DP type features for compounding, regardless of agreement 17Apr03 CB\r\n < IP head subject head possessor > = < DP head possessor > | pass DP possessor info for compounding, regardless of agreement 17Apr03 CB\r\n < DP head case_for_position > = direct | to know normal case for conjoined DPs\r\n < DP head case > = direct < DP head type DO_contraction > = - | 17Feb03 CB\r\n < DP head type case-marked > = - < DP head type nonfinalcoordination > = - < DP > == ~ [ mother_node : - ] | if coordination, must be allowed initially\r\n < DP > == [ mother_node : + ] -> [ head : [ type : [ coordination : + ] ] ] |and be complete\r\n < DP head type > == [ relative : + ] -> [ relcl : + ] | require rel suffix to only occur when relative clause present\r\n < IP head > == [ type : [ reciprocal : + ] ] -> [ subject : [ head : [ agr : [ number : [ plural : + ] ] ] ] ] < IP head > == [ subject : [ head : [ infl : [ polarity : - ] ] ] ] -> |if the subject is negative, the verb must be negative\r\n [ infl : [ polarity : - ] ] ||    <IP head> == [subject:[head:[type:[coordination:+]]]] ->\r\n ||                ~[type:[initialP:+]]\r\n < IP head > == ( ( ( [ subject : [ head : [ participle : [ cat : V ] ] ] ] / [ subject : [ head : [ possessor : [ head : [ participle : [ cat : V ] ] ] ] ] ] ) ) & ( [ type : [ no_intervening : + ] ] ) ) -> ( ( [ type : [ auxiliary : - copular : - passive : - ] ] / [ type : [ auxiliary : + participle : + ] ] ) / [ type : [ participle_passive : + ] ] ) | to force participle to be w/ V or Aux 12-APR-04\r\n < IP head > == [ rootgloss : ^1 ] -> ~ ( [ type : [ no_intervening : + ] ] & ( ( [ subject : [ head : [ type : [ compounds_with1 : ^1 ] ] ] ] / [ subject : [ head : [ type : [ compounds_with2 : ^1 ] ] ] ] ) / ( [ subject : [ head : [ type : [ compounds_with3 : ^1 ] ] ] ] / [ subject : [ head : [ type : [ compounds_with4 : ^1 ] ] ] ] ) ) ) < IP head > == [ rootgloss : ^1 ] -> ~ ( [ type : [ no_intervening : + ] ] & ( ( [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with1 : ^1 ] ] ] ] ] ] / [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with2 : ^1 ] ] ] ] ] ] ) / ( [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with3 : ^1 ] ] ] ] ] ] / [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with4 : ^1 ] ] ] ] ] ] ) ) ) < IP rule > = 2cNon-ImpersonalV-PastIntransitive rule { IP option 2cINon-ImpersonalV-PastTransitive - subject initial, required, root clause } IP = DP I' < IP head > = < I' head > < IP head type root > = + < IP head type pro-drop > = - < IP head subject head agr > = < DP head reflexive head agr > | pass reflexive info\r\n { < DP head type comma > = - < DP head type apposition > = - / < DP head type apposition > = + | 17Jan03  CB\r\n / < DP head type apposition > = namely | 21Nov03  CB\r\n / < DP head type relcl > = + | can have comma if relcl 27Jan03 CB\r\n < DP head type comma > = + < DP head type apposition > = - } < I' head type impersonal > = - < I' head infl tense past > = + < I' head type transitive > = + { < I' head subject > = < DP > / < DP head type human > = - < DP head agr person third > = + < DP head agr number plural > = + < I' head subject head agr number singular > = + < I' head subject head agr number plural > = - < I' head subject head agr person second > = - | RL 2Feb02 allow 1st and 3rd person, but not 2nd.\r\n } < IP head subject head type > = < DP head type > | pass DP type features for compounding, regardless of agreement 17Apr03 CB\r\n < IP head subject head possessor > = < DP head possessor > | pass DP possessor info for compounding, regardless of agreement 17Apr03 CB\r\n { < DP head case > = oblique < DP head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < DP head agr person third > = + / < DP head agr person first > = + | pronouns different case CB 23May19\r\n < DP head case > = direct < DP head case_for_position > = direct | to know normal case for conjoined DPs\r\n / < DP head agr person second > = + | pronouns different case CB 23May19\r\n < DP head case > = direct < DP head case_for_position > = direct | to know normal case for conjoined DPs\r\n } < DP head type DO_contraction > = - | 17Feb03 CB\r\n < DP head type case-marked > = - < DP head type nonfinalcoordination > = - < DP > == ~ [ mother_node : - ] | if coordination, must be allowed initially\r\n < DP > == [ mother_node : + ] -> [ head : [ type : [ coordination : + ] ] ] |and be complete\r\n < DP head type > == [ relative : + ] -> [ relcl : + ] | require rel suffix to only occur when relative clause present\r\n < IP head > == [ type : [ reciprocal : + ] ] -> [ subject : [ head : [ agr : [ number : [ plural : + ] ] ] ] ] < IP head > == [ object : [ head : [ type : [ reciprocal : + ] ] ] ] -> [ subject : [ head : [ agr : [ number : [ plural : + ] ] ] ] ] < IP head > == [ object : [ head : [ infl : [ polarity : - ] ] ] ] -> |if the object is negative, the verb must be negative\r\n [ infl : [ polarity : - ] ] < IP head > == [ subject : [ head : [ infl : [ polarity : - ] ] ] ] -> |if the subject is negative, the verb must be negative\r\n [ infl : [ polarity : - ] ] < IP head > == ~ [ object : [ head : [ type : [ conjunction_gloss : initial_ya ] ] ] ] | to restrict splitting between subject and object\r\n ||    <IP head> == [subject:[head:[type:[coordination:+]]]] ->\r\n ||                ~[type:[initialP:+]]\r\n < IP head > == ( ( ( [ subject : [ head : [ participle : [ cat : V ] ] ] ] / [ subject : [ head : [ possessor : [ head : [ participle : [ cat : V ] ] ] ] ] ] ) ) & ( [ type : [ no_intervening : + ] ] ) ) -> ( ( [ type : [ auxiliary : - copular : - passive : - ] ] / [ type : [ auxiliary : + participle : + ] ] ) / [ type : [ participle_passive : + ] ] ) | to force participle to be w/ V or Aux 12-APR-04\r\n < IP head > == [ rootgloss : ^1 ] -> ~ ( [ type : [ no_intervening : + ] ] & ( ( [ subject : [ head : [ type : [ compounds_with1 : ^1 ] ] ] ] / [ subject : [ head : [ type : [ compounds_with2 : ^1 ] ] ] ] ) / ( [ subject : [ head : [ type : [ compounds_with3 : ^1 ] ] ] ] / [ subject : [ head : [ type : [ compounds_with4 : ^1 ] ] ] ] ) ) ) < IP head > == [ rootgloss : ^1 ] -> ~ ( [ type : [ no_intervening : + ] ] & ( ( [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with1 : ^1 ] ] ] ] ] ] / [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with2 : ^1 ] ] ] ] ] ] ) / ( [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with3 : ^1 ] ] ] ] ] ] / [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with4 : ^1 ] ] ] ] ] ] ) ) ) < IP head > == [ object : [ head : [ rootgloss : ^1 ] ] ] -> ~ ( ( [ subject : [ head : [ type : [ compounds_with1 : ^1 ] ] ] ] / [ subject : [ head : [ type : [ compounds_with2 : ^1 ] ] ] ] ) / ( [ subject : [ head : [ type : [ compounds_with3 : ^1 ] ] ] ] / [ subject : [ head : [ type : [ compounds_with4 : ^1 ] ] ] ] ) ) < IP head > == [ object : [ head : [ rootgloss : ^1 ] ] ] -> ~ ( ( [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with1 : ^1 ] ] ] ] ] ] / [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with2 : ^1 ] ] ] ] ] ] ) / ( [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with3 : ^1 ] ] ] ] ] ] / [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with4 : ^1 ] ] ] ] ] ] ) ) < IP rule > = 2cNon-ImpersonalV-PastTransitive rule { IP option 2cII - subject initial, pro-drop, root clause } IP = I' < IP head > = < I' head > < IP head type root > = + < IP head type pro-drop > = + < IP head > == [ object : [ head : [ infl : [ polarity : - ] ] ] ] -> |if the object is negative, the verb must be negative\r\n [ infl : [ polarity : - ] ] ||    <IP head> == [object:[head:[type:[coordination:+]]]] ->\r\n ||                ~[type:[initialP:+]]\r\n |||    <IP head> == ~([infl:[tense:[past:+]]] & [type:[transitive:+]]) | past transitive must have overt subject CB 30May19  Ron says true only for Balochi, not Farsi 3Feb2020\r\n < IP rule > = 2cII |*****split rule for impersonalV and then non-past and past transitive*****\r\n rule { IP option 2cImpersonalVnonroot - subject initial, required, nonroot clause } IP = ( InitP ) DP I' < IP head > = < I' head > < IP head type root > = - < InitP head type root > = - < IP head type pro-drop > = - < IP head subject head agr > = < DP head reflexive head agr > | pass reflexive info\r\n < I' head subject > = < InitP head subject > | pass reflexive info\r\n { < DP head type comma > = - < DP head type apposition > = - / < DP head type apposition > = + | 17Jan03  CB\r\n / < DP head type apposition > = namely | 21Nov03  CB\r\n } < I' head subject > = < DP > < I' head type impersonal > = + | impersonal verbs do not agree **24Jul06 CB\r\n < IP head subject head type > = < DP head type > | pass DP type features for compounding, regardless of agreement 17Apr03 CB\r\n < IP head subject head possessor > = < DP head possessor > | pass DP possessor info for compounding, regardless of aggrement 17Apr03 CB\r\n { < DP head case > = oblique < DP head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < DP head agr person third > = + / < DP head agr person first > = + | pronouns different case CB 23May19\r\n < DP head case > = objective < DP head case_for_position > = objective | to know normal case for conjoined DPs\r\n / < DP head agr person second > = + | pronouns different case CB 23May19\r\n < DP head case > = objective < DP head case_for_position > = objective | to know normal case for conjoined DPs\r\n } < DP head type DO_contraction > = - | 17Feb03 CB\r\n < DP head type case-marked > = - < DP head type nonfinalcoordination > = - < DP > == ~ [ mother_node : - ] | if coordination, must be allowed initially\r\n < DP > == [ mother_node : + ] -> [ head : [ type : [ coordination : + ] ] ] |and be complete\r\n < IP head type initialP > <= < InitP head type initialP > < DP head type > == [ relative : + ] -> [ relcl : + ] | require rel suffix to only occur when relative clause present\r\n < IP head > == [ type : [ reciprocal : + ] ] -> [ subject : [ head : [ agr : [ number : [ plural : + ] ] ] ] ] < IP head > == [ object : [ head : [ type : [ reciprocal : + ] ] ] ] -> [ subject : [ head : [ agr : [ number : [ plural : + ] ] ] ] ] < IP head > == [ object : [ head : [ infl : [ polarity : - ] ] ] ] -> |if the object is negative, the verb must be negative\r\n [ infl : [ polarity : - ] ] < IP head > == [ subject : [ head : [ infl : [ polarity : - ] ] ] ] -> |if the subject is negative, the verb must be negative\r\n [ infl : [ polarity : - ] ] < IP head > == ~ [ object : [ head : [ type : [ conjunction_gloss : initial_ya ] ] ] ] | to restrict splitting between subject and object\r\n ||    <IP head> == [subject:[head:[type:[coordination:+]]]] ->\r\n ||                ~[type:[initialP:+]]\r\n < IP head > == ( ( [ subject : [ head : [ participle : [ cat : V ] ] ] ] / [ subject : [ head : [ possessor : [ head : [ participle : [ cat : V ] ] ] ] ] ] ) & [ type : [ no_intervening : + ] ] ) -> ( ( [ type : [ auxiliary : - copular : - passive : - ] ] / [ type : [ auxiliary : + participle : + ] ] ) / [ type : [ participle_passive : + ] ] ) | to force participle to be w/ V or Aux 12-APR-04\r\n < IP head > == [ rootgloss : ^1 ] -> ~ ( [ type : [ no_intervening : + ] ] & ( ( [ subject : [ head : [ type : [ compounds_with1 : ^1 ] ] ] ] / [ subject : [ head : [ type : [ compounds_with2 : ^1 ] ] ] ] ) / ( [ subject : [ head : [ type : [ compounds_with3 : ^1 ] ] ] ] / [ subject : [ head : [ type : [ compounds_with4 : ^1 ] ] ] ] ) ) ) < IP head > == [ rootgloss : ^1 ] -> ~ ( [ type : [ no_intervening : + ] ] & ( ( [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with1 : ^1 ] ] ] ] ] ] / [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with2 : ^1 ] ] ] ] ] ] ) / ( [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with3 : ^1 ] ] ] ] ] ] / [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with4 : ^1 ] ] ] ] ] ] ) ) ) < IP head > == [ object : [ head : [ rootgloss : ^1 ] ] ] -> ~ ( ( [ subject : [ head : [ type : [ compounds_with1 : ^1 ] ] ] ] / [ subject : [ head : [ type : [ compounds_with2 : ^1 ] ] ] ] ) / ( [ subject : [ head : [ type : [ compounds_with3 : ^1 ] ] ] ] / [ subject : [ head : [ type : [ compounds_with4 : ^1 ] ] ] ] ) ) < IP head > == [ object : [ head : [ rootgloss : ^1 ] ] ] -> ~ ( ( [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with1 : ^1 ] ] ] ] ] ] / [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with2 : ^1 ] ] ] ] ] ] ) / ( [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with3 : ^1 ] ] ] ] ] ] / [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with4 : ^1 ] ] ] ] ] ] ) ) < IP rule > = 2cImpersonalVnonroot rule { IP option 2cNon-ImpersonalVNonPastnonroot - subject initial, required, nonroot clause } IP = ( InitP ) DP I' < IP head > = < I' head > < IP head type root > = - < InitP head type root > = - < IP head type pro-drop > = - < IP head subject head agr > = < DP head reflexive head agr > | pass reflexive info\r\n < I' head subject > = < InitP head subject > | pass reflexive info\r\n { < DP head type comma > = - < DP head type apposition > = - / < DP head type apposition > = + | 17Jan03  CB\r\n / < DP head type apposition > = namely | 21Nov03  CB\r\n } < I' head type impersonal > = - < I' head infl tense past > = - { < I' head subject > = < DP > / < DP head type human > = - < DP head agr person third > = + < DP head agr number plural > = + < I' head subject head agr number singular > = + < I' head subject head agr number plural > = - < I' head subject head agr person second > = - | RL 2Feb02 allow 1st and 3rd person, but not 2nd.\r\n } < IP head subject head type > = < DP head type > | pass DP type features for compounding, regardless of agreement 17Apr03 CB\r\n < IP head subject head possessor > = < DP head possessor > | pass DP possessor info for compounding, regardless of aggrement 17Apr03 CB\r\n < DP head case_for_position > = direct | to know normal case for conjoined DPs\r\n < DP head case > = direct < DP head type DO_contraction > = - | 17Feb03 CB\r\n < DP head type case-marked > = - < DP head type nonfinalcoordination > = - < DP > == ~ [ mother_node : - ] | if coordination, must be allowed initially\r\n < DP > == [ mother_node : + ] -> [ head : [ type : [ coordination : + ] ] ] |and be complete\r\n < IP head type initialP > <= < InitP head type initialP > < DP head type > == [ relative : + ] -> [ relcl : + ] | require rel suffix to only occur when relative clause present\r\n < IP head > == [ type : [ reciprocal : + ] ] -> [ subject : [ head : [ agr : [ number : [ plural : + ] ] ] ] ] < IP head > == [ object : [ head : [ type : [ reciprocal : + ] ] ] ] -> [ subject : [ head : [ agr : [ number : [ plural : + ] ] ] ] ] < IP head > == [ object : [ head : [ infl : [ polarity : - ] ] ] ] -> |if the object is negative, the verb must be negative\r\n [ infl : [ polarity : - ] ] < IP head > == [ subject : [ head : [ infl : [ polarity : - ] ] ] ] -> |if the subject is negative, the verb must be negative\r\n [ infl : [ polarity : - ] ] < IP head > == ~ [ object : [ head : [ type : [ conjunction_gloss : initial_ya ] ] ] ] | to restrict splitting between subject and object\r\n ||    <IP head> == [subject:[head:[type:[coordination:+]]]] ->\r\n ||                ~[type:[initialP:+]]\r\n < IP head > == ( ( [ subject : [ head : [ participle : [ cat : V ] ] ] ] / [ subject : [ head : [ possessor : [ head : [ participle : [ cat : V ] ] ] ] ] ] ) & [ type : [ no_intervening : + ] ] ) -> ( ( [ type : [ auxiliary : - copular : - passive : - ] ] / [ type : [ auxiliary : + participle : + ] ] ) / [ type : [ participle_passive : + ] ] ) | to force participle to be w/ V or Aux 12-APR-04\r\n < IP head > == [ rootgloss : ^1 ] -> ~ ( [ type : [ no_intervening : + ] ] & ( ( [ subject : [ head : [ type : [ compounds_with1 : ^1 ] ] ] ] / [ subject : [ head : [ type : [ compounds_with2 : ^1 ] ] ] ] ) / ( [ subject : [ head : [ type : [ compounds_with3 : ^1 ] ] ] ] / [ subject : [ head : [ type : [ compounds_with4 : ^1 ] ] ] ] ) ) ) < IP head > == [ rootgloss : ^1 ] -> ~ ( [ type : [ no_intervening : + ] ] & ( ( [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with1 : ^1 ] ] ] ] ] ] / [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with2 : ^1 ] ] ] ] ] ] ) / ( [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with3 : ^1 ] ] ] ] ] ] / [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with4 : ^1 ] ] ] ] ] ] ) ) ) < IP head > == [ object : [ head : [ rootgloss : ^1 ] ] ] -> ~ ( ( [ subject : [ head : [ type : [ compounds_with1 : ^1 ] ] ] ] / [ subject : [ head : [ type : [ compounds_with2 : ^1 ] ] ] ] ) / ( [ subject : [ head : [ type : [ compounds_with3 : ^1 ] ] ] ] / [ subject : [ head : [ type : [ compounds_with4 : ^1 ] ] ] ] ) ) < IP head > == [ object : [ head : [ rootgloss : ^1 ] ] ] -> ~ ( ( [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with1 : ^1 ] ] ] ] ] ] / [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with2 : ^1 ] ] ] ] ] ] ) / ( [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with3 : ^1 ] ] ] ] ] ] / [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with4 : ^1 ] ] ] ] ] ] ) ) < IP rule > = 2cNon-ImpersonalVNonPastnonroot rule { IP option 2cNon-ImpersonalV-PastIntransitivenonroot - subject initial, required, nonroot clause } IP = ( InitP ) DP I' < IP head > = < I' head > < IP head type root > = - < InitP head type root > = - < IP head type pro-drop > = - < I' head subject > = < InitP head subject > | pass reflexive info\r\n { < DP head type comma > = - < DP head type apposition > = - / < DP head type apposition > = + | 17Jan03  CB\r\n / < DP head type apposition > = namely | 21Nov03  CB\r\n } < I' head type impersonal > = - < I' head infl tense past > = + < I' head type transitive > = - { < I' head subject > = < DP > / < DP head type human > = - < DP head agr person third > = + < DP head agr number plural > = + < I' head subject head agr number singular > = + < I' head subject head agr number plural > = - < I' head subject head agr person second > = - | RL 2Feb02 allow 1st and 3rd person, but not 2nd.\r\n } < IP head subject head type > = < DP head type > | pass DP type features for compounding, regardless of agreement 17Apr03 CB\r\n < IP head subject head possessor > = < DP head possessor > | pass DP possessor info for compounding, regardless of aggrement 17Apr03 CB\r\n < DP head case > = direct < DP head case_for_position > = direct | to know normal case for conjoined DPs\r\n < DP head type DO_contraction > = - | 17Feb03 CB\r\n < DP head type case-marked > = - < DP head type nonfinalcoordination > = - < DP > == ~ [ mother_node : - ] | if coordination, must be allowed initially\r\n < DP > == [ mother_node : + ] -> [ head : [ type : [ coordination : + ] ] ] |and be complete\r\n < IP head type initialP > <= < InitP head type initialP > < DP head type > == [ relative : + ] -> [ relcl : + ] | require rel suffix to only occur when relative clause present\r\n < IP head > == [ type : [ reciprocal : + ] ] -> [ subject : [ head : [ agr : [ number : [ plural : + ] ] ] ] ] < IP head > == [ subject : [ head : [ infl : [ polarity : - ] ] ] ] -> |if the subject is negative, the verb must be negative\r\n [ infl : [ polarity : - ] ] ||    <IP head> == [subject:[head:[type:[coordination:+]]]] ->\r\n ||                ~[type:[initialP:+]]\r\n < IP head > == ( ( [ subject : [ head : [ participle : [ cat : V ] ] ] ] / [ subject : [ head : [ possessor : [ head : [ participle : [ cat : V ] ] ] ] ] ] ) & [ type : [ no_intervening : + ] ] ) -> ( ( [ type : [ auxiliary : - copular : - passive : - ] ] / [ type : [ auxiliary : + participle : + ] ] ) / [ type : [ participle_passive : + ] ] ) | to force participle to be w/ V or Aux 12-APR-04\r\n < IP head > == [ rootgloss : ^1 ] -> ~ ( [ type : [ no_intervening : + ] ] & ( ( [ subject : [ head : [ type : [ compounds_with1 : ^1 ] ] ] ] / [ subject : [ head : [ type : [ compounds_with2 : ^1 ] ] ] ] ) / ( [ subject : [ head : [ type : [ compounds_with3 : ^1 ] ] ] ] / [ subject : [ head : [ type : [ compounds_with4 : ^1 ] ] ] ] ) ) ) < IP head > == [ rootgloss : ^1 ] -> ~ ( [ type : [ no_intervening : + ] ] & ( ( [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with1 : ^1 ] ] ] ] ] ] / [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with2 : ^1 ] ] ] ] ] ] ) / ( [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with3 : ^1 ] ] ] ] ] ] / [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with4 : ^1 ] ] ] ] ] ] ) ) ) < IP rule > = 2cNon-ImpersonalV-PastIntransitivenonroot rule { IP option 2cNon-ImpersonalV-PastTransitivenonroot - subject initial, required, nonroot clause } IP = ( InitP ) DP I' < IP head > = < I' head > < IP head type root > = - < InitP head type root > = - < IP head type pro-drop > = - < IP head subject head agr > = < DP head reflexive head agr > | pass reflexive info\r\n < I' head subject > = < InitP head subject > | pass reflexive info\r\n { < DP head type comma > = - < DP head type apposition > = - / < DP head type apposition > = + | 17Jan03  CB\r\n / < DP head type apposition > = namely | 21Nov03  CB\r\n } < I' head type impersonal > = - < I' head infl tense past > = + < I' head type transitive > = + { < I' head subject > = < DP > / < DP head type human > = - < DP head agr person third > = + < DP head agr number plural > = + < I' head subject head agr number singular > = + < I' head subject head agr number plural > = - < I' head subject head agr person second > = - | RL 2Feb02 allow 1st and 3rd person, but not 2nd.\r\n } < IP head subject head type > = < DP head type > | pass DP type features for compounding, regardless of agreement 17Apr03 CB\r\n < IP head subject head possessor > = < DP head possessor > | pass DP possessor info for compounding, regardless of aggrement 17Apr03 CB\r\n { < DP head case > = oblique < DP head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < DP head agr person third > = + / < DP head agr person first > = + | pronouns different case CB 23May19\r\n < DP head case > = direct < DP head case_for_position > = direct | to know normal case for conjoined DPs\r\n / < DP head agr person second > = + | pronouns different case CB 23May19\r\n < DP head case > = direct < DP head case_for_position > = direct | to know normal case for conjoined DPs\r\n } < DP head type DO_contraction > = - | 17Feb03 CB\r\n < DP head type case-marked > = - < DP head type nonfinalcoordination > = - < DP > == ~ [ mother_node : - ] | if coordination, must be allowed initially\r\n < DP > == [ mother_node : + ] -> [ head : [ type : [ coordination : + ] ] ] |and be complete\r\n < IP head type initialP > <= < InitP head type initialP > < DP head type > == [ relative : + ] -> [ relcl : + ] | require rel suffix to only occur when relative clause present\r\n < IP head > == [ type : [ reciprocal : + ] ] -> [ subject : [ head : [ agr : [ number : [ plural : + ] ] ] ] ] < IP head > == [ object : [ head : [ type : [ reciprocal : + ] ] ] ] -> [ subject : [ head : [ agr : [ number : [ plural : + ] ] ] ] ] < IP head > == [ object : [ head : [ infl : [ polarity : - ] ] ] ] -> |if the object is negative, the verb must be negative\r\n [ infl : [ polarity : - ] ] < IP head > == [ subject : [ head : [ infl : [ polarity : - ] ] ] ] -> |if the subject is negative, the verb must be negative\r\n [ infl : [ polarity : - ] ] < IP head > == ~ [ object : [ head : [ type : [ conjunction_gloss : initial_ya ] ] ] ] | to restrict splitting between subject and object\r\n ||    <IP head> == [subject:[head:[type:[coordination:+]]]] ->\r\n ||                ~[type:[initialP:+]]\r\n < IP head > == ( ( [ subject : [ head : [ participle : [ cat : V ] ] ] ] / [ subject : [ head : [ possessor : [ head : [ participle : [ cat : V ] ] ] ] ] ] ) & [ type : [ no_intervening : + ] ] ) -> ( ( [ type : [ auxiliary : - copular : - passive : - ] ] / [ type : [ auxiliary : + participle : + ] ] ) / [ type : [ participle_passive : + ] ] ) | to force participle to be w/ V or Aux 12-APR-04\r\n < IP head > == [ rootgloss : ^1 ] -> ~ ( [ type : [ no_intervening : + ] ] & ( ( [ subject : [ head : [ type : [ compounds_with1 : ^1 ] ] ] ] / [ subject : [ head : [ type : [ compounds_with2 : ^1 ] ] ] ] ) / ( [ subject : [ head : [ type : [ compounds_with3 : ^1 ] ] ] ] / [ subject : [ head : [ type : [ compounds_with4 : ^1 ] ] ] ] ) ) ) < IP head > == [ rootgloss : ^1 ] -> ~ ( [ type : [ no_intervening : + ] ] & ( ( [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with1 : ^1 ] ] ] ] ] ] / [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with2 : ^1 ] ] ] ] ] ] ) / ( [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with3 : ^1 ] ] ] ] ] ] / [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with4 : ^1 ] ] ] ] ] ] ) ) ) < IP head > == [ object : [ head : [ rootgloss : ^1 ] ] ] -> ~ ( ( [ subject : [ head : [ type : [ compounds_with1 : ^1 ] ] ] ] / [ subject : [ head : [ type : [ compounds_with2 : ^1 ] ] ] ] ) / ( [ subject : [ head : [ type : [ compounds_with3 : ^1 ] ] ] ] / [ subject : [ head : [ type : [ compounds_with4 : ^1 ] ] ] ] ) ) < IP head > == [ object : [ head : [ rootgloss : ^1 ] ] ] -> ~ ( ( [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with1 : ^1 ] ] ] ] ] ] / [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with2 : ^1 ] ] ] ] ] ] ) / ( [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with3 : ^1 ] ] ] ] ] ] / [ subject : [ head : [ possessor : [ head : [ type : [ compounds_with4 : ^1 ] ] ] ] ] ] ) ) < IP rule > = 2cNon-ImpersonalVPastTransitivenonroot rule { IP option 2cIInonroot - subject initial, pro-drop, nonroot clauses } IP = ( InitP ) I' < IP head > = < I' head > < IP head type root > = - < I' head subject > = < InitP head subject > | pass reflexive info\r\n < InitP head type root > = - < IP head type pro-drop > = + < IP head type initialP > <= < InitP head type initialP > < IP head > == [ object : [ head : [ infl : [ polarity : - ] ] ] ] -> |if the object is negative, the verb must be negative\r\n [ infl : [ polarity : - ] ] ||    <IP head> == [object:[head:[type:[coordination:+]]]] ->\r\n ||                ~[type:[initialP:+]]\r\n < IP rule > = 2cIInonroot |-***********************************************************\r\n rule { I' option 0 - conjoined I's }) (phraseStructureRule (nonTerminal I') (ruleDef =) (rightHandSide (nonTerminal I'_1) (nonTerminal Conj) (nonTerminal I'_2))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal I') (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal I'_1) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal I') (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | limit recursion\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal I'_1) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal I'_1) (featurePath (atomicValue head) (featurePath (atomicValue subject))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal I'_2) (featurePath (atomicValue head) (featurePath (atomicValue subject))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal I'_1) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue mood) (featurePath (atomicValue realis))))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal I'_2) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue mood) (featurePath (atomicValue realis))))) (closingWedge >) (comment | 15Jul03 CB\r\n)))) (constraint (unificationConstraint (disjunctiveUnificationConstraint { (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal I'_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue auxiliary)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | one of the two verbs has an auxiliary or both do.\r\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal I'_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue auxiliary)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal I'_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue auxiliary)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal I'_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue auxiliary)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal I'_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue auxiliary)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal I'_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue auxiliary)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) }))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue conjoins_IP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal I') (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 0) (comment |not for Sdn  \r\n)))))) (patrRule (ruleKW rule) (ruleIdentifier { I' option 1 - no auxiliaries } I' = ( AdvP / DP / PP ) VP < I' head > = < VP head > < I' head type auxiliary > = - { < I' head type participle > = - | the participle is only allowed when followed by an Aux 03Apr03 C\r\n / < I' head type participle > = + | OR when the verb is passive\r\n < I' head type passive > = + / < I' head type participle > = + | OR when the verb has past endings\r\n < I' head infl tense past > = + | 17Jul03 CB\r\n < I' head type passive > = - / < I' head type participle > = + | OR when the verb is present perfective\r\n < I' head infl tense present > = + < I' head type passive > = - < I' head infl aspect perfective > = + | Apr2020 CB\r\n } < I' head embedded infl > = < I' head infl > | enforce any subcategorization requirements from higher verb\r\n < VP head adjoined > = < PP > < VP head adjoined > = < DP > < VP head adjoined > = < AdvP > |    <AdvP head type temporal> = +\r\n < DP head type temporal > = + < DP head case > = direct < DP head type no_head_N > = - < DP head type comma > = - < PP head type sentential > = - | added 31Mar03 CB\r\n < PP head type stranded > = - | not missing a complement  22Aug2019\r\n < PP head > == ~ [ rootgloss : to ] | P not 'to' for IO - testing ***Jun2019\r\n < VP head > == [ adjoined : [ head : [ type : [ locative : + ] ] ] ] -> ~ [ type : [ motion : + ] ] |not motion VP with locative PP/AdvP/DP testing 29Jan2020\r\n < VP head > == ~ [ rootgloss : become ] < VP head > == ~ [ rootgloss_V_2 : become ] | 12-APR-04\r\n < I' rule > = 1 rule { I' option 1Sdn - no auxiliaries }) (phraseStructureRule (nonTerminal I') (ruleDef =) (rightHandSide (disjunctiveOptionalNonTerminal ( (nonTerminal AdvP) (disjunctionOptionalNonTerminal / (nonTerminal DP)) (disjunctionOptionalNonTerminal / (nonTerminal PP)) )) (nonTerminal VP))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal I') (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal I') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue auxiliary)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (disjunctiveUnificationConstraint { (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head) (featurePath (atomicValue rootgloss))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue become))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head) (featurePath (atomicValue rootgloss_V_2))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue become) (comment | 12-APR-04\r\n)))) }))) (constraint (unificationConstraint (disjunctiveUnificationConstraint { (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal I') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue participle)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | the participle is only allowed when followed by an Aux 03Apr03 CB\r\n))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | OR when Sdn is compound 17Apr03 CB\r\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal I') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue participle)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) } (comment |    <AdvP head type temporal> = +\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue temporal)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_head_N)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal PP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue sentential)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | added 31Mar03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal PP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue stranded)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not missing a complement  22Aug2019\r\n)))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal PP) (featurePath (atomicValue head)) (closingWedge >)) == (logConstraintExpression ~ (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue rootgloss)) : (featureStructureValue (atomicValue to)) (closingBracket ]) (comment | P not 'to' for IO - testing ***Jun2019\r\n)))))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal I') (featurePath (atomicValue head) (featurePath (atomicValue embedded) (featurePath (atomicValue infl)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal I') (featurePath (atomicValue head) (featurePath (atomicValue infl))) (closingWedge >) (comment | enforce any subcategorization requirements from higher verb\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal I') (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 1Sdn)))))) (patrRule (ruleKW rule) (ruleIdentifier { I' option 3 - Aux final, required } I' = VP ( AdvP / DP / PP ) Aux < I' head > = < VP head > < I' head type auxiliary > = + < I' head subject head agr > = < Aux head subject head agr > < VP head adjoined > = < PP > < VP head adjoined > = < DP > < VP head adjoined > = < AdvP > < VP head type comma > = - |    <AdvP head type temporal> = +\r\n < DP head type temporal > = + < DP head case > = direct < DP head type no_head_N > = - < DP head type comma > = - < PP head type sentential > = - | added 31Mar03 CB\r\n < PP head type stranded > = - | not missing a complement  22Aug2019\r\n < VP head type participle > = + | all auxiliaries require the verb to be in participle form (not future--different rule V F)\r\n < Aux head type object_agr_suffix > = - |CB 4Feb2020   no object agr\r\n < Aux head type copular_suffix > = - |CB 4Feb2020   not copular form\r\n < Aux head infl aspect perfective > = - |CB 4Feb2020   perfective uses V V rule\r\n |<I' head infl> = <Aux head infl>  | RL 13Feb02\r\n < PP head > == ~ [ rootgloss : to ] | P not 'to' for IO - testing ***Jun2019\r\n < VP head > == [ adjoined : [ head : [ type : [ locative : + ] ] ] ] -> ~ [ type : [ motion : + ] ] |not motion VP with locative PP/AdvP/DP testing 29Jan2020\r\n < I' head embedded infl > = < I' head infl > | enforce any subcategorization requirements from higher verb\r\n < I' rule > = 3 rule { I' option 4pst - Aux initial, required - for be.able.pst, requires embedded subjunctive } I' = ( AdvP_1 ) Aux ( AdvP / DP / PP ) VP < I' head > = < VP head > < VP head adjoined > = < PP > < VP head adjoined > = < DP > < VP head adjoined > = < AdvP > < I' head type auxiliary > = + < Aux rootgloss > = be.able < Aux head infl tense past > = + | Aux is past tense for this rule\r\n < VP head auxiliaryH infl tense past > = < Aux head infl tense past > < VP head auxiliaryH rootgloss > = < Aux rootgloss > < I' head subject head agr > = < Aux head subject head agr > < VP head type comma > = - |    <AdvP head type temporal> = +\r\n < DP head type temporal > = + < DP head case > = direct < DP head type no_head_N > = - < DP head type comma > = - < PP head type sentential > = - | added 31Mar03 CB\r\n < PP head type stranded > = - | not missing a complement  22Aug2019\r\n < PP head > == ~ [ rootgloss : to ] | P not 'to' for IO - testing ***Jun2019\r\n < VP head > == [ adjoined : [ head : [ type : [ locative : + ] ] ] ] -> ~ [ type : [ motion : + ] ] |not motion VP with locative PP testing 29Jan2020\r\n < VP head infl mood subjunctive > = + | embedded verb is present subjunctive\r\n < VP head infl mood realis > = - | embedded verb is present subjunctive\r\n < VP head infl tense present > = + | embedded verb is present subjunctive\r\n < Aux head type object_agr_suffix > = - |CB 4Feb2020   no object agr\r\n < Aux head type copular_suffix > = - |CB 4Feb2020   not copular form\r\n < Aux head infl aspect perfective > = - |CB 4Feb2020   perfective uses V V rule\r\n < I' head infl tense past > <= + | tense is from Aux\r\n |<I' head infl> = <Aux head infl>  | RL 13Feb02\r\n < I' head infl polarity > <= < Aux head infl polarity > | negation on Aux  Feb2020 CB\r\n ||    <I' head embedded infl> = <I' head infl>     | enforce any subcategorization requirements from higher verb\r\n < I' rule > = 4pst rule { I' option 4prs - Aux initial, required - for be.able.prs, requires embedded subjunctive } I' = ( AdvP_1 ) Aux ( AdvP / DP / PP ) VP < I' head > = < VP head > < VP head adjoined > = < PP > < VP head adjoined > = < DP > < VP head adjoined > = < AdvP > < I' head type auxiliary > = + < Aux rootgloss > = be.able < Aux head infl tense present > = + | Aux is present tense for this rule\r\n < VP head auxiliaryH infl tense present > = < Aux head infl tense past > < VP head auxiliaryH rootgloss > = < Aux rootgloss > < I' head subject head agr > = < Aux head subject head agr > < VP head type comma > = - |    <AdvP head type temporal> = +\r\n < DP head type temporal > = + < DP head case > = direct < DP head type no_head_N > = - < DP head type comma > = - < VP head subject > = < PP head reflexive > | pass reflexive info\r\n < VP head adjoined > = < PP > < PP head type sentential > = - | added 31Mar03 CB\r\n < PP head type stranded > = - | not missing a complement  22Aug2019\r\n < PP head > == ~ [ rootgloss : to ] | P not 'to' for IO - testing ***Jun2019\r\n < VP head > == [ adjoined : [ head : [ type : [ locative : + ] ] ] ] -> ~ [ type : [ motion : + ] ] |not motion VP with locative PP testing 29Jan2020\r\n < VP head infl mood subjunctive > = + | embedded verb is present subjunctive\r\n < VP head infl mood realis > = - | embedded verb is present subjunctive\r\n < VP head infl tense present > = + | embedded verb is present subjunctive\r\n < Aux head type object_agr_suffix > = - |CB 4Feb2020   no object agr\r\n < VP head type object_agr_suffix > = - |CB Apr2020   no object agr on V\r\n < Aux head type copular_suffix > = - |CB 4Feb2020   not copular form\r\n < Aux head infl aspect perfective > = - |CB 4Feb2020   perfective uses V V rule\r\n |<I' head infl> = <Aux head infl>  | RL 13Feb02\r\n < I' head infl polarity > <= < Aux head infl polarity > | negation on Aux  Feb2020 CB\r\n ||    <I' head embedded infl> = <I' head infl>     | enforce any subcategorization requirements from higher verb\r\n < I' rule > = 4prs |-***********************************************************\r\n rule { VP option 0adj - adjoined CP }) (phraseStructureRule (nonTerminal VP) (ruleDef =) (rightHandSide (nonTerminal VP_1) (nonTerminal CP))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal VP_1) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal CP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue root)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal CP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 21Nov03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue sentential)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal CP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) (comment | 04Apr03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 0adj)))))) (patrRule (ruleKW rule) (ruleIdentifier { VP option 0conj - conjoined VPs }) (phraseStructureRule (nonTerminal VP) (ruleDef =) (rightHandSide (nonTerminal VP_1) (nonTerminal Conj) (nonTerminal VP_2))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head) (featurePath (atomicValue rootgloss))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal VP_1) (featurePath (atomicValue head) (featurePath (atomicValue rootgloss))) (closingWedge >) (comment | for compounding constraints 12-APR-04\r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head) (featurePath (atomicValue rootgloss_V_2))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal VP_2) (featurePath (atomicValue head) (featurePath (atomicValue rootgloss))) (closingWedge >)) (comment | for Sdn Aux constraints\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head) (featurePath (atomicValue subject))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal VP_1) (featurePath (atomicValue head) (featurePath (atomicValue subject))) (closingWedge >) (comment | CB 16Jan03\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP_1) (featurePath (atomicValue head) (featurePath (atomicValue subject))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal VP_2) (featurePath (atomicValue head) (featurePath (atomicValue subject))) (closingWedge >) (comment | subjects agree\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue participle)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal VP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue participle)))) (closingWedge >) (comment | CB 16Jan03\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue participle)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal VP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue participle)))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal VP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >) (comment | CB 10Dec03\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal VP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head) (featurePath (atomicValue infl))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal VP_1) (featurePath (atomicValue head) (featurePath (atomicValue infl))) (closingWedge >) (comment | CB 16Jan03\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_intervening)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | for compounding constraint 15Apr03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | limit recursion\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP_1) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue conjoins_IP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment |    <VP_2 head infl mood realis> = +  | for subjunctive, use embedded rule  | removed  27Jan03\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP_2) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue mood) (featurePath (atomicValue realis))))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal VP_1) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue mood) (featurePath (atomicValue realis))))) (closingWedge >) (comment | added instead 27Jan03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue conj_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 09-APR-04 \r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue conj_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal VP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue conj_suffix)))) (closingWedge >) (comment | pass to IP 0b\r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal VP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) (comment | 04Apr03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 0conj) (comment |rule {VP option 1Adv - adjoined AdvP}\r\n)) (comment |VP = AdvP VP_1\r\n))) (constraint (comment |    <VP head> = <VP_1 head>\r\n)) (constraint (comment |    <VP_1 head type auxiliary> <= <VP head type auxiliary>  | trying to make something work\r\n)) (constraint (comment |    <VP_1 head auxiliaryH rootgloss> <= <VP head auxiliaryH rootgloss> | passing down Aux info \r\n)) (constraint (comment |    <VP_1 head auxiliaryH rootgloss> = <VP head auxiliaryH rootgloss> | passing down Aux info\r\n)) (constraint (comment |    <VP_1 head auxiliaryH> <= <VP head auxiliaryH> | passing down Aux info\r\n)) (constraint (comment |    <VP_1 head auxiliaryH> = <VP head auxiliaryH> | passing down Aux info\r\n)) (constraint (comment |    <AdvP head type comma> = -\r\n)) (constraint (comment ||    <AdvP head type manner> = +         | removed this restriction and eliminated AdvP w/in |VP 20Feb03 CB\r\n)) (constraint (comment |    {<AdvP head infl polarity> = +\t | either the adverb is not negative - 07-APR-04\r\n)) (constraint (comment |    /<AdvP head infl polarity> = -\t | or the adverb is negative\r\n)) (constraint (comment |     <VP_1 head infl polarity> = -\t | and the verb must be negative\r\n)) (constraint (comment |    /<AdvP head infl polarity> = -\t | or the adverb is negative\r\n)) (constraint (comment |     <VP_1 head infl polarity> = +\t | and the verb is subjuctive\r\n)) (constraint (comment |     <VP_1 head infl mood realis> = -\r\n)) (constraint (comment |    }\r\n)) (constraint (comment |    <VP head type no_intervening> <= -   | for compounding constraint\r\n)) (constraint (comment |    <VP rule> = 1Adv\r\n)) (constraint (comment ||added for Ability24 "every day"\r\n)) (constraint (comment |rule {VP option 1TempDP - adjoined DP, temporal only}\r\n)) (constraint (comment |VP = DP VP_1\r\n)) (constraint (comment |    <VP head> = <VP_1 head>\r\n)) (constraint (comment |    <VP_1 head type auxiliary> <= <VP head type auxiliary>  | trying to make something work\r\n)) (constraint (comment |    <VP_1 head auxiliaryH rootgloss> <= <VP head auxiliaryH rootgloss> | passing down Aux info \r\n)) (constraint (comment |    <VP_1 head auxiliaryH rootgloss> = <VP head auxiliaryH rootgloss> | passing down Aux info\r\n)) (constraint (comment |    <VP_1 head auxiliaryH> <= <VP head auxiliaryH> | passing down Aux info\r\n)) (constraint (comment |    <VP_1 head auxiliaryH> = <VP head auxiliaryH> | passing down Aux info\r\n)) (constraint (comment |    <DP head type temporal> = +\r\n)) (constraint (comment |    <DP head case> = direct\r\n)) (constraint (comment |    <DP head type no_head_N> = -\r\n)) (constraint (comment |    <DP head type comma> = -\r\n)) (constraint (comment |    <VP head type no_intervening> <= -   | for compounding constraint\r\n)) (constraint (comment |    <VP rule> = 1TempDP\r\n)) (constraint (comment ||VP_1 already compound or intervening material \r\n)) (constraint (comment |rule {VP option 1PPno - adjoined PP, no need for compound test}\r\n)) (constraint (comment |VP = PP VP_1\r\n)) (constraint (comment |    <VP head> = <VP_1 head>\r\n)) (constraint (comment |    <VP head subject> = <PP head reflexive> | pass reflexive info\r\n)) (constraint (comment |    <VP head adjoined> = <PP>\r\n)) (constraint (comment |    {<PP head type comma> = -\r\n)) (constraint (comment |    /<PP head type comma> = +\t\t | PP may have comma if object contains apposition |07-APR-04\r\n)) (constraint (comment |     <PP head object head type apposition> = +\r\n)) (constraint (comment |    }\r\n)) (constraint (comment |    <PP head type sentential> = -        | added 31Mar03 CB\r\n)) (constraint (comment |    <PP head type stranded> = -           | not missing a complement  22Aug2019\r\n)) (constraint (comment |    {<VP_1 head type no_intervening> = -  | for compounding constraint\r\n)) (constraint (comment |    /<VP_1 head type no_intervening> = +\r\n)) (constraint (comment |     <VP_1 head type compounded> = +      | or already compounded\r\n)) (constraint (comment |    }\r\n)) (constraint (comment |    <PP head> == ~[rootgloss: to]         | P not 'to' for IO - testing ***Jun2019\r\n)) (constraint (comment |    <VP head> == [adjoined:[head:[type:[locative:+]]]] -> ~[type:[motion:+]] |not motion VP |with locative PP testing 29Jan2020\r\n)) (constraint (comment |    <VP rule> = 1PPno\r\n)) (constraint (comment |rule {VP option 1PP - adjoined PP, possible compound situation}\r\n)) (constraint (comment |VP = PP VP_1\r\n)) (constraint (comment |    <VP head> = <VP_1 head>\r\n)) (constraint (comment |    <VP head subject> = <PP head reflexive> | pass reflexive info\r\n)) (constraint (comment |    <VP head adjoined> = <PP>\r\n)) (constraint (comment |    {<PP head type comma> = -\r\n)) (constraint (comment |    /<PP head type comma> = +\t\t | PP may have comma if object contains apposition |07-APR-04\r\n)) (constraint (comment |     <PP head object head type apposition> = +\r\n)) (constraint (comment |    }\r\n)) (constraint (comment |    <PP head type sentential> = -        | added 31Mar03 CB\r\n)) (constraint (comment |    <VP_1 head type no_intervening> = +\r\n)) (constraint (comment |    <VP_1 head type compounded> = -      | not already compounded\r\n)) (constraint (comment |    <VP head type no_intervening> <= -   | for compounding constraint\r\n)) (constraint (comment |    <PP head object head type> == [modifier-final:+] -> ~[compound:+]  | PPs with modified |objects whose final element is marked compound, must compound 16Jul03 CB\r\n)) (constraint (comment |    <PP head> == ~[rootgloss: to]         | P not 'to' for IO - testing ***Jun2019\r\n)) (constraint (comment |    <VP head> == [adjoined:[head:[type:[locative:+]]]] -> ~[type:[motion:+]] |not motion VP |with locative PP testing 29Jan2020\r\n)) (constraint (comment |    <VP rule> = 1PP\r\n)))) (patrRule (ruleKW rule) (ruleIdentifier { VP option 2a - V initial/final, intransitive or copular }) (phraseStructureRule (nonTerminal VP) (ruleDef =) (rightHandSide (nonTerminal V))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head) (featurePath (atomicValue rootgloss))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue rootgloss)) (closingWedge >)))) (constraint (unificationConstraint (disjunctiveUnificationConstraint { (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | or transitive within a relative clause\r\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | 20Nov03 CB\r\n)))) }))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | 09-APR-04 since allow case on V+participle for adjective use\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue finite)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | don't allow short or regular infinitive at end of verb phrase\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue passive)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_intervening)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | for compounding constraint\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue object_agr_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment |CB 24May19   no object agr\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 2a)))))) (patrRule (ruleKW rule) (ruleIdentifier { VP option 3b - V final, motion intransitive with locative }) (phraseStructureRule (nonTerminal VP) (ruleDef =) (rightHandSide (nonTerminal DP) (nonTerminal V))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head) (featurePath (atomicValue rootgloss))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue rootgloss)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue subject))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >) (comment | pass reflexive info\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue oblique) (comment | changed from direct per Ron 8Jan2020 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue locative)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | don't allow coordinate DPs 12Feb03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue nonfinalcoordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | 09-APR-04 since allow case on V+participle for adjective use\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue finite)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | don't allow short or regular infinitive at end of verb phrase\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment ||    <V head type copular> = -   |testing 28Jan2020 for be + participle \r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue motion)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue passive)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_intervening)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | for compounding constraint\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue object_agr_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment |CB 24May19   no object agr\r\n)))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relative)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relcl)) : (featureStructureValue (atomicValue +)) (closingBracket ]) (comment | require rel suffix to only occur when relative clause present\r\n)))))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 3b) (comment |added 30May19\r\n)))))) (patrRule (ruleKW rule) (ruleIdentifier { VP option 3bPP - V final, motion intransitive with locative PP or AdvP }) (phraseStructureRule (nonTerminal VP) (ruleDef =) (rightHandSide (disjunctiveTerminals { (nonTerminal PP) (disjunctionNonTerminal / (nonTerminal AdvP)) }) (nonTerminal V))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head) (featurePath (atomicValue rootgloss))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue rootgloss)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal PP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue locative)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal PP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue location_PP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | to rule out PP IO  22Aug2019\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal AdvP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue locative)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | 09-APR-04 since allow case on V+participle for adjective use\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue finite)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | don't allow short or regular infinitive at end of verb phrase\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment ||    <V head type copular> = -   |testing 28Jan2020 for be + participle \r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue motion)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue passive)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_intervening)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | for compounding constraint\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue object_agr_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment |CB 24May19   no object agr\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 3bPP) (comment |added Feb2020 for Ability 5-6 CB  split for past, then generic and definite\r\n)))))) (patrRule (ruleKW rule) (ruleIdentifier { VP option 3cTRpast - motion transitive } VP = DP_1 { PP / AdvP / DP_2 } V < VP head > = < V head > < VP head object > = < DP_1 > < VP head location > = < PP > < VP head location > = < AdvP > < VP head location > = < DP_2 > < VP head type pro-drop > = - | DP_1 should not be the subject Apr2020\r\n { < V head infl tense past > = + / < V head infl tense past > = - < VP head auxiliaryH rootgloss > = be.able |tense from Aux  Feb2020\r\n < VP head auxiliaryH infl tense past > = + |tense from Aux  Feb2020\r\n < VP head auxiliaryH infl tense present > = - |tense from Aux  Feb2020\r\n < VP head type auxiliary > = + | Aux must be present Apr2020\r\n < VP head infl mood subjunctive > = + | Apr2020\r\n } < DP_1 head type temporal > = - |Apr2020\r\n { < DP_1 head case > = direct < DP_1 head type pronoun > = - < DP_1 head case_for_position > = direct | to know normal case for conjoined DPs\r\n / < DP_1 head case > = direct < DP_1 head type pronoun > = + < DP_1 head agr person third > = + < DP_1 head agr person first > = - < DP_1 head agr person second > = - < DP_1 head case_for_position > = direct | to know normal case for conjoined DPs\r\n / < DP_1 head case > = objective < DP_1 head type pronoun > = + | pronouns different case CB 23May19\r\n < DP_1 head agr person first > = + < DP_1 head agr person third > = - < DP_1 head agr person second > = - < DP_1 head case_for_position > = objective | to know normal case for conjoined DPs\r\n / < DP_1 head case > = objective < DP_1 head type pronoun > = + | pronouns different case CB 23May19\r\n < DP_1 head agr person second > = + < DP_1 head agr person third > = - < DP_1 head agr person first > = - < DP_1 head case_for_position > = objective | to know normal case for conjoined DPs\r\n } < PP head type locative > = + < PP head type location_PP > = + | to rule out PP IO  22Aug2019\r\n < PP head type sentential > = - < DP_2 head type locative > = + < DP_2 head case > = oblique < AdvP head type locative > = + < V head type copular > = - < V head type passive > = - < V head type motion > = + { < V head type transitive_motion > = + | activated Apr2020, V must have transitive_motion\r\n / < V head infl valence causative > = + | or motion verb + causative\r\n } < V head type object_agr_suffix > = + |CB 24May19   must have object agreement\r\n < VP rule > = 3cTRpast rule { VP option 3cTRNonPastGeneric - motion transitive } VP = DP_1 { PP / AdvP / DP_2 } V < VP head > = < V head > < VP head object > = < DP_1 > < VP head location > = < PP > < VP head location > = < AdvP > < VP head location > = < DP_2 > < VP head type pro-drop > = - | DP_1 should not be the subject Apr2020\r\n < V head infl tense past > = - < DP_1 head type generic > = + | 30May19\r\n < DP_1 head type temporal > = - |Apr2020\r\n { < DP_1 head case > = direct < DP_1 head type pronoun > = - < DP_1 head case_for_position > = direct | to know normal case for conjoined DPs\r\n / < DP_1 head case > = oblique < DP_1 head type pronoun > = + < DP_1 head agr person third > = + < DP_1 head agr person first > = - < DP_1 head agr person second > = - < DP_1 head case_for_position > = oblique | to know normal case for conjoined DPs\r\n / < DP_1 head case > = objective < DP_1 head type pronoun > = + | pronouns different case CB 23May19\r\n < DP_1 head agr person first > = + < DP_1 head agr person third > = - < DP_1 head agr person second > = - < DP_1 head case_for_position > = objective | to know normal case for conjoined DPs\r\n / < DP_1 head case > = objective < DP_1 head type pronoun > = + | pronouns different case CB 23May19\r\n < DP_1 head agr person second > = + < DP_1 head agr person third > = - < DP_1 head agr person first > = - < DP_1 head case_for_position > = objective | to know normal case for conjoined DPs\r\n } < PP head type locative > = + < PP head type location_PP > = + | to rule out PP IO  22Aug2019\r\n < PP head type sentential > = - < DP_2 head type locative > = + < DP_2 head case > = oblique < AdvP head type locative > = + < V head type copular > = - < V head type passive > = - < V head type motion > = + { < V head type transitive_motion > = + | activated Apr2020, V must have transitive_motion\r\n / < V head infl valence causative > = + | or motion verb + causative\r\n } < V head type object_agr_suffix > = - |CB 24May19   cannot have object agreement\r\n < VP head auxiliaryH > == ~ ( [ rootgloss : be.able ] & [ infl : [ tense : [ past : + ] ] ] ) | no past Aux to change tense Feb2020\r\n < VP rule > = 3cTRNonPastGeneric rule { VP option 3cTRNonPastNonGenericIndefinite - motion transitive } VP = DP_1 { PP / AdvP / DP_2 } V < VP head > = < V head > < VP head object > = < DP_1 > < VP head location > = < PP > < VP head location > = < AdvP > < VP head location > = < DP_2 > < VP head type pro-drop > = - | DP_1 should not be the subject Apr2020\r\n < V head infl tense past > = - < DP_1 head type generic > = - | 30May19\r\n < DP_1 head type indefinite > = + < DP_1 head type temporal > = - |Apr2020\r\n { < DP_1 head case > = direct < DP_1 head type pronoun > = - < DP_1 head case_for_position > = direct | to know normal case for conjoined DPs\r\n / < DP_1 head case > = oblique < DP_1 head type pronoun > = + < DP_1 head agr person third > = + < DP_1 head agr person first > = - < DP_1 head agr person second > = - < DP_1 head case_for_position > = oblique | to know normal case for conjoined DPs\r\n / < DP_1 head case > = objective < DP_1 head type pronoun > = + | pronouns different case CB 23May19\r\n < DP_1 head agr person first > = + < DP_1 head agr person third > = - < DP_1 head agr person second > = - < DP_1 head case_for_position > = objective | to know normal case for conjoined DPs\r\n / < DP_1 head case > = objective < DP_1 head type pronoun > = + | pronouns different case CB 23May19\r\n < DP_1 head agr person second > = + < DP_1 head agr person third > = - < DP_1 head agr person first > = - < DP_1 head case_for_position > = objective | to know normal case for conjoined DPs\r\n } < PP head type locative > = + < PP head type location_PP > = + | to rule out PP IO  22Aug2019\r\n < PP head type sentential > = - < DP_2 head type locative > = + < DP_2 head case > = oblique < AdvP head type locative > = + < V head type copular > = - < V head type passive > = - < V head type motion > = + { < V head type transitive_motion > = + | activated Apr2020, V must have transitive_motion\r\n / < V head infl valence causative > = + | or motion verb + causative\r\n } < V head type object_agr_suffix > = - |CB 24May19   cannot have object agreement\r\n < VP head auxiliaryH > == ~ ( [ rootgloss : be.able ] & [ infl : [ tense : [ past : + ] ] ] ) | no past Aux to change tense Feb2020\r\n < VP rule > = 3cTRNonPastNonGenericIndefinite rule { VP option 3cTRNonPastNonGenericDefinite - motion transitive } VP = DP_1 { PP / AdvP / DP_2 } V < VP head > = < V head > < VP head object > = < DP_1 > < VP head location > = < PP > < VP head location > = < AdvP > < VP head location > = < DP_2 > < VP head type pro-drop > = - | DP_1 should not be the subject Apr2020\r\n < V head infl tense past > = - < DP_1 head type generic > = - | 30May19\r\n < DP_1 head type indefinite > = - < DP_1 head type temporal > = - |Apr2020\r\n { < DP_1 head case > = oblique < DP_1 head type pronoun > = - < DP_1 head case_for_position > = oblique | to know normal case for conjoined DPs\r\n / < DP_1 head case > = oblique < DP_1 head type pronoun > = + < DP_1 head agr person third > = + < DP_1 head agr person first > = - < DP_1 head agr person second > = - < DP_1 head case_for_position > = oblique | to know normal case for conjoined DPs\r\n / < DP_1 head case > = objective < DP_1 head type pronoun > = + | pronouns different case CB 23May19\r\n < DP_1 head agr person first > = + < DP_1 head agr person third > = - < DP_1 head agr person second > = - < DP_1 head case_for_position > = objective | to know normal case for conjoined DPs\r\n / < DP_1 head case > = objective < DP_1 head type pronoun > = + | pronouns different case CB 23May19\r\n < DP_1 head agr person second > = + < DP_1 head agr person third > = - < DP_1 head agr person first > = - < DP_1 head case_for_position > = objective | to know normal case for conjoined DPs\r\n } < PP head type locative > = + < PP head type location_PP > = + | to rule out PP IO  22Aug2019\r\n < PP head type sentential > = - < DP_2 head type locative > = + < DP_2 head case > = oblique < AdvP head type locative > = + < V head type copular > = - < V head type passive > = - < V head type motion > = + { < V head type transitive_motion > = + | activated Apr2020, V must have transitive_motion\r\n / < V head infl valence causative > = + | or motion verb + causative\r\n } < V head type object_agr_suffix > = - |CB 24May19   cannot have object agreement\r\n < VP head auxiliaryH > == ~ ( [ rootgloss : be.able ] & [ infl : [ tense : [ past : + ] ] ] ) | no past Aux to change tense Feb2020\r\n < VP rule > = 3cTRNonPastNonGenericDefinite rule { VP option 4badj - V final, copular w/ adj, not passive }) (phraseStructureRule (nonTerminal VP) (ruleDef =) (rightHandSide (nonTerminal AdjP) (nonTerminal V))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head) (featurePath (atomicValue rootgloss))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue rootgloss)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue copular)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal AdjP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal AdjP) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal AdjP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue genitive_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment |CB 16Aug19 Predicate adjectives not genitive suffix\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal AdjP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue attributive)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment |CB 9May19 Predicate adjectives not attributive\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | 09-APR-04 since allow case on V+participle for adjective use\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue finite)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | don't allow short or regular infinitive at end of verb phrase\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue passive)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_intervening)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | for compounding constraint\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue object_agr_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment |CB 24May19   no object agr\r\n)) (comment ||    <AdjP head type> == ~[compound:+]     | AdjPs which are marked compound, must compound 22Aug2019 for 3rdPn2Dir\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 4badj) (comment |rule added 19Nov03 CB \r\n)))))) (patrRule (ruleKW rule) (ruleIdentifier { VP option 4bPcop_sfx - V final, copular_suffix w/ P, not passive }) (phraseStructureRule (nonTerminal VP) (ruleDef =) (rightHandSide (nonTerminal P) (nonTerminal V))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head) (featurePath (atomicValue rootgloss))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue rootgloss)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue copular_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounded)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 06-APR-04 CB to eliminate P [N V]-copsfx\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | case for pronoun copular_suffix attached to\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | 09-APR-04 since allow case on V+participle for adjective use\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue finite)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | don't allow short or regular infinitive at end of verb phrase\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue passive)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_intervening)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | for compounding constraint\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue object_agr_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment |CB 24May19   no object agr\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 4bPcop_sfx)))))) (patrRule (ruleKW rule) (ruleIdentifier { VP option 4badjPP - V final, copular w/ adj then PP, not passive }) (phraseStructureRule (nonTerminal VP) (ruleDef =) (rightHandSide (nonTerminal AdjP) (nonTerminal PP) (nonTerminal V))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head) (featurePath (atomicValue rootgloss))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue rootgloss)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue copular)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue subject))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal PP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >) (comment | pass reflexive info\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal PP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal AdjP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal AdjP) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal AdjP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue attributive)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment |CB 9May19 Predicate adjectives not attributive\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal PP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue sentential)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | 09-APR-04 since allow case on V+participle for adjective use\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue finite)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | don't allow short or regular infinitive at end of verb phrase\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue passive)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_intervening)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | for compounding constraint\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue object_agr_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment |CB 24May19   no object agr\r\n)))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal PP) (featurePath (atomicValue head) (featurePath (atomicValue object) (featurePath (atomicValue head) (featurePath (atomicValue type))))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue modifier-final)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) ~ (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue compound)) : (featureStructureValue (atomicValue +)) (closingBracket ]) (comment | PPs with modified objects whose final element is marked compound, must compound 16Jul03 CB\r\n)))))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 4badjPP)))))) (patrRule (ruleKW rule) (ruleIdentifier { VP option 4bnom - V final, copular with predicate nominative, not passive } VP = DP V < VP head > = < V head > < VP head rootgloss > = < V rootgloss > < V head type copular > = + ||    <V head type copular_suffix> = -   | copular_suffix use 4bnomCop_sfx for correct case ||08Jan2020 CB\r\n < V head case > = direct | 09-APR-04 since allow case on V+participle for adjective use\r\n < V head infl finite > = + | don't allow short or regular infinitive at end of verb phrase\r\n < V head subject > = < DP head reflexive > | pass reflexive info\r\n { < DP head type comma > = - < DP head type apposition > = - / < DP head type apposition > = + | 17Jan03  CB\r\n / < DP head type apposition > = namely | 21Nov03  CB\r\n / < DP head type relcl > = + | can have comma if relcl 27Jan03 CB\r\n < DP head type comma > = + < DP head type apposition > = - } < DP head case_for_position > = direct | to know normal case for conjoined DPs\r\n < DP head case > = direct < VP head type passive > = - < V head object > = < DP > | for constraint on negative agreement, etc.\r\n < VP head type no_intervening > = - | for compounding constraint\r\n < V head type object_agr_suffix > = - |CB 24May19   no object agr\r\n < DP head type nonfinalcoordination > = - < DP > == ~ [ mother_node : - ] | if coordination, must be allowed initially\r\n < DP > == [ mother_node : + ] -> [ head : [ type : [ coordination : + ] ] ] |and be complete\r\n < DP head type > == [ modifier-final : - ] -> ~ [ sentential : + ] | nouns marked w/ sentential should be compound, unless modified 29Jan03CB\r\n < DP head type > == [ modifier-final : + ] -> ~ [ compound : + ] | modified DPs whose final element is marked compound, must compound 16Jul03 CB\r\n < VP head object head participle > = none | to force participle to be w/ V or Aux 12-APR-04\r\n < VP head object head possessor head participle > = none | to force participle to be w/ V or Aux 12-APR-04\r\n < VP head > == [ rootgloss : ^1 ] -> ~ ( [ object : [ head : [ type : [ modifier-final : - ] ] ] ] & ( ( [ object : [ head : [ type : [ compounds_with1 : ^1 ] ] ] ] / [ object : [ head : [ type : [ compounds_with2 : ^1 ] ] ] ] ) / ( [ object : [ head : [ type : [ compounds_with3 : ^1 ] ] ] ] / [ object : [ head : [ type : [ compounds_with4 : ^1 ] ] ] ] ) ) ) |21Jul03\r\n < DP head type > == [ relative : + ] -> [ relcl : + ] | require rel suffix to only occur when relative clause present\r\n < VP rule > = 4bnom |optional Adv added **19Jul06 CB DP_1 temporal added 24Jul2019 \r\n |removed 20Aug2019  (Adv / DP_1), reactivated Apr2020 all transitive rules\r\n |*****split rule for past and then generic and definite*****\r\n rule { VP option 5cPast - V final, transitive } VP = DP ( Adv / DP_1 ) V < VP head > = < V head > ||    <VP head type pro-drop> = -     | subject must be overt Ron says true only for Balochi Feb2020\r\n < VP head rootgloss > = < V rootgloss > < VP head object > = < DP > < VP head type transitive > = + < V head case > = direct | 09-APR-04 since allow case on V+participle for adjective use\r\n { < VP head infl tense past > = + < VP head infl tense present > = - / < VP head infl tense past > = - < VP head infl mood subjunctive > = + | Apr2020\r\n < VP head auxiliaryH rootgloss > = be.able |tense from Aux  Feb2020\r\n < VP head auxliairy infl tense past > = + | must be past Aux Apr2020\r\n < VP head type auxiliary > = + | Aux must be present Apr2020\r\n } < V head infl finite > = + | don't allow short or regular infinitive at end of verb phrase\r\n < V head type copular > = - < V head type passive > = - |    <Adv head type manner> = +\t     | manner Adv in this position ** 19Jul06 CB, enable after feature added to dictionary\r\n < Adv head type locative > = - < Adv head type temporal > = + < DP_1 head type locative > = - < DP_1 head type temporal > = + < DP_1 head case > = direct < DP_1 head type modifier-final > = - < DP_1 head type pronoun > = - < V head subject > = < DP head reflexive > | pass reflexive info\r\n { < DP head type comma > = - < DP head type apposition > = - / < DP head type apposition > = + | 17Jan03  CB\r\n / < DP head type apposition > = namely | 21Nov03  CB\r\n / < DP head type relcl > = + | can have comma if relcl 27Jan03 CB\r\n < DP head type comma > = + < DP head type apposition > = - } < DP head type temporal > = - |Apr2020\r\n { < DP head case > = direct < DP head type pronoun > = - < DP head case_for_position > = direct | to know normal case for conjoined DPs\r\n / < DP head case > = direct < DP head type pronoun > = + < DP head agr person third > = + < DP head agr person first > = - < DP head agr person second > = - < DP head case_for_position > = direct | to know normal case for conjoined DPs\r\n / < DP head case > = objective < DP head type pronoun > = + | pronouns different case CB 23May19\r\n < DP head agr person first > = + < DP head agr person third > = - < DP head agr person second > = - < DP head case_for_position > = objective | to know normal case for conjoined DPs\r\n / < DP head case > = objective < DP head type pronoun > = + | pronouns different case CB 23May19\r\n < DP head agr person second > = + < DP head agr person third > = - < DP head agr person first > = - < DP head case_for_position > = objective | to know normal case for conjoined DPs\r\n } < VP head type no_intervening > = - | for compounding constraint\r\n < DP head type nonfinalcoordination > = - < V head type object_agr_suffix > = + |CB 24May19   must have object agreement\r\n < DP > == ~ [ mother_node : - ] | if coordination, must be allowed initially\r\n < DP > == [ mother_node : + ] -> [ head : [ type : [ coordination : + ] ] ] |and be complete\r\n < DP head type > == [ modifier-final : + ] -> ~ [ compound : + ] | modified DPs whose final element is marked compound, must compound 16Jul03 CB\r\n < VP head > == [ rootgloss : ^1 ] -> ~ ( ( [ object : [ head : [ type : [ modifier-final : - ] ] ] ] & [ object : [ head : [ type : [ case-marked : - ] ] ] ] ) & ( ( [ object : [ head : [ type : [ compounds_with1 : ^1 ] ] ] ] / [ object : [ head : [ type : [ compounds_with2 : ^1 ] ] ] ] ) / ( [ object : [ head : [ type : [ compounds_with3 : ^1 ] ] ] ] / [ object : [ head : [ type : [ compounds_with4 : ^1 ] ] ] ] ) ) ) |21Jul03\r\n < VP head > == [ rootgloss : ^1 ] -> ~ ( ( [ object : [ head : [ relativity : [ conjoined : + ] ] ] ] ) & ( ( [ object : [ head : [ relativity : [ compounds_with1 : ^1 ] ] ] ] / [ object : [ head : [ relativity : [ compounds_with2 : ^1 ] ] ] ] ) / ( [ object : [ head : [ relativity : [ compounds_with3 : ^1 ] ] ] ] / [ object : [ head : [ relativity : [ compounds_with4 : ^1 ] ] ] ] ) ) ) |20Oct03  for special case of relcl2+kh and 0a-DP\r\n < DP head type > == [ relative : + ] -> [ relcl : + ] | require rel suffix to only occur when relative clause present\r\n < VP rule > = 5cPast rule { VP option 5cNonPastGeneric - V final, transitive } VP = DP ( Adv / DP_1 ) V < VP head > = < V head > < VP head rootgloss > = < V rootgloss > < V head object > = < DP > < V head type transitive > = + < V head case > = direct | 09-APR-04 since allow case on V+participle for adjective use\r\n < V head infl tense past > = - < V head infl finite > = + | don't allow short or regular infinitive at end of verb phrase\r\n < DP head type generic > = + | 30May19\r\n < V head type copular > = - < V head type passive > = - |    <Adv head type manner> = +\t     | manner Adv in this position ** 19Jul06 CB, enable after feature added to dictionary\r\n < Adv head type locative > = - < Adv head type temporal > = + < DP_1 head type locative > = - < DP_1 head type temporal > = + < DP_1 head case > = direct < DP_1 head type modifier-final > = - < DP_1 head type pronoun > = - < V head subject > = < DP head reflexive > | pass reflexive info\r\n { < DP head type comma > = - < DP head type apposition > = - / < DP head type apposition > = + | 17Jan03  CB\r\n / < DP head type apposition > = namely | 21Nov03  CB\r\n / < DP head type relcl > = + | can have comma if relcl 27Jan03 CB\r\n < DP head type comma > = + < DP head type apposition > = - } < DP head type temporal > = - |Apr2020\r\n { < DP head case > = direct < DP head case_for_position > = direct | to know normal case for conjoined DPs\r\n < DP head type pronoun > = - / < DP head case > = oblique | pronouns different case CB 23May19\r\n < DP head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + < DP head agr person third > = + < DP head agr person first > = - < DP head agr person second > = - / < DP head case > = objective < DP head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + | pronouns different case CB 23May19\r\n < DP head agr person first > = + < DP head agr person third > = - < DP head agr person second > = - / < DP head case > = objective < DP head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + | pronouns different case CB 23May19\r\n < DP head agr person second > = + < DP head agr person third > = - < DP head agr person first > = - } < VP head type no_intervening > = - | for compounding constraint\r\n < V head type object_agr_suffix > = - |CB 24May19   no object agr\r\n < DP head type nonfinalcoordination > = - < DP > == ~ [ mother_node : - ] | if coordination, must be allowed initially\r\n < DP > == [ mother_node : + ] -> [ head : [ type : [ coordination : + ] ] ] |and be complete\r\n < DP head type > == [ modifier-final : + ] -> ~ [ compound : + ] | modified DPs whose final element is marked compound, must compound 16Jul03 CB\r\n < VP head > == [ rootgloss : ^1 ] -> ~ ( ( [ object : [ head : [ type : [ modifier-final : - ] ] ] ] & [ object : [ head : [ type : [ case-marked : - ] ] ] ] ) & ( ( [ object : [ head : [ type : [ compounds_with1 : ^1 ] ] ] ] / [ object : [ head : [ type : [ compounds_with2 : ^1 ] ] ] ] ) / ( [ object : [ head : [ type : [ compounds_with3 : ^1 ] ] ] ] / [ object : [ head : [ type : [ compounds_with4 : ^1 ] ] ] ] ) ) ) |21Jul03\r\n < VP head > == [ rootgloss : ^1 ] -> ~ ( ( [ object : [ head : [ relativity : [ conjoined : + ] ] ] ] ) & ( ( [ object : [ head : [ relativity : [ compounds_with1 : ^1 ] ] ] ] / [ object : [ head : [ relativity : [ compounds_with2 : ^1 ] ] ] ] ) / ( [ object : [ head : [ relativity : [ compounds_with3 : ^1 ] ] ] ] / [ object : [ head : [ relativity : [ compounds_with4 : ^1 ] ] ] ] ) ) ) |20Oct03  for special case of relcl2+kh and 0a-DP\r\n < DP head type > == [ relative : + ] -> [ relcl : + ] | require rel suffix to only occur when relative clause present\r\n < VP head auxiliaryH > == ~ ( [ rootgloss : be.able ] & [ infl : [ tense : [ past : + ] ] ] ) | no past Aux to change tense Feb2020\r\n < VP rule > = 5cNonPastGeneric rule { VP option 5cNonPastNonGenericIndefinite - V final, transitive } VP = DP ( Adv / DP_1 ) V < VP head > = < V head > < VP head rootgloss > = < V rootgloss > < V head object > = < DP > < V head type transitive > = + < V head case > = direct | 09-APR-04 since allow case on V+participle for adjective use\r\n < V head infl tense past > = - < V head infl finite > = + | don't allow short or regular infinitive at end of verb phrase\r\n < DP head type generic > = - | 30May19\r\n < V head type copular > = - < V head type passive > = - |    <Adv head type manner> = +\t     | manner Adv in this position ** 19Jul06 CB, enable after feature added to dictionary\r\n < Adv head type locative > = - < Adv head type temporal > = + < DP_1 head type locative > = - < DP_1 head type temporal > = + < DP_1 head case > = direct < DP_1 head type modifier-final > = - < DP_1 head type pronoun > = - < V head subject > = < DP head reflexive > | pass reflexive info\r\n < DP head type indefinite > = + { < DP head type comma > = - < DP head type apposition > = - / < DP head type apposition > = + | 17Jan03  CB\r\n / < DP head type apposition > = namely | 21Nov03  CB\r\n / < DP head type relcl > = + | can have comma if relcl 27Jan03 CB\r\n < DP head type comma > = + < DP head type apposition > = - } < DP head type temporal > = - |Apr2020\r\n { < DP head case > = direct < DP head case_for_position > = direct | to know normal case for conjoined DPs\r\n < DP head type pronoun > = - / < DP head case > = oblique | pronouns different case CB 23May19\r\n < DP head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + < DP head agr person third > = + < DP head agr person first > = - < DP head agr person second > = - / < DP head case > = objective < DP head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + | pronouns different case CB 23May19\r\n < DP head agr person first > = + < DP head agr person third > = - < DP head agr person second > = - / < DP head case > = objective < DP head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + | pronouns different case CB 23May19\r\n < DP head agr person second > = + < DP head agr person third > = - < DP head agr person first > = - } < VP head type no_intervening > = - | for compounding constraint\r\n < V head type object_agr_suffix > = - |CB 24May19   no object agr\r\n < DP head type nonfinalcoordination > = - < DP > == ~ [ mother_node : - ] | if coordination, must be allowed initially\r\n < DP > == [ mother_node : + ] -> [ head : [ type : [ coordination : + ] ] ] |and be complete\r\n < DP head type > == [ modifier-final : + ] -> ~ [ compound : + ] | modified DPs whose final element is marked compound, must compound 16Jul03 CB\r\n < VP head > == [ rootgloss : ^1 ] -> ~ ( ( [ object : [ head : [ type : [ modifier-final : - ] ] ] ] & [ object : [ head : [ type : [ case-marked : - ] ] ] ] ) & ( ( [ object : [ head : [ type : [ compounds_with1 : ^1 ] ] ] ] / [ object : [ head : [ type : [ compounds_with2 : ^1 ] ] ] ] ) / ( [ object : [ head : [ type : [ compounds_with3 : ^1 ] ] ] ] / [ object : [ head : [ type : [ compounds_with4 : ^1 ] ] ] ] ) ) ) |21Jul03\r\n < VP head > == [ rootgloss : ^1 ] -> ~ ( ( [ object : [ head : [ relativity : [ conjoined : + ] ] ] ] ) & ( ( [ object : [ head : [ relativity : [ compounds_with1 : ^1 ] ] ] ] / [ object : [ head : [ relativity : [ compounds_with2 : ^1 ] ] ] ] ) / ( [ object : [ head : [ relativity : [ compounds_with3 : ^1 ] ] ] ] / [ object : [ head : [ relativity : [ compounds_with4 : ^1 ] ] ] ] ) ) ) |20Oct03  for special case of relcl2+kh and 0a-DP\r\n < DP head type > == [ relative : + ] -> [ relcl : + ] | require rel suffix to only occur when relative clause present\r\n < VP head auxiliaryH > == ~ ( [ rootgloss : be.able ] & [ infl : [ tense : [ past : + ] ] ] ) | no past Aux to change tense Feb2020\r\n < VP rule > = 5cNonPastNonGenericIndefinite rule { VP option 5cNonPastNonGenericDefinite - V final, transitive } VP = DP ( Adv / DP_1 ) V < VP head > = < V head > < VP head rootgloss > = < V rootgloss > < V head object > = < DP > < V head type transitive > = + < V head case > = direct | 09-APR-04 since allow case on V+participle for adjective use\r\n < V head infl tense past > = - < V head infl finite > = + | don't allow short or regular infinitive at end of verb phrase\r\n < DP head type generic > = - | 30May19\r\n < V head type copular > = - < V head type passive > = - |    <Adv head type manner> = +\t     | manner Adv in this position ** 19Jul06 CB, enable after feature added to dictionary\r\n < Adv head type locative > = - < Adv head type temporal > = + < DP_1 head type locative > = - < DP_1 head type temporal > = + < DP_1 head case > = direct < DP_1 head type modifier-final > = - < DP_1 head type pronoun > = - < V head subject > = < DP head reflexive > | pass reflexive info\r\n < DP head type indefinite > = - { < DP head type comma > = - < DP head type apposition > = - / < DP head type apposition > = + | 17Jan03  CB\r\n / < DP head type apposition > = namely | 21Nov03  CB\r\n / < DP head type relcl > = + | can have comma if relcl 27Jan03 CB\r\n < DP head type comma > = + < DP head type apposition > = - } < DP head type temporal > = - |Apr2020\r\n { < DP head case > = oblique < DP head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < DP head type pronoun > = - / < DP head case > = oblique | pronouns different case CB 23May19\r\n < DP head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + < DP head agr person third > = + < DP head agr person first > = - < DP head agr person second > = - / < DP head case > = objective < DP head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + | pronouns different case CB 23May19\r\n < DP head agr person first > = + < DP head agr person third > = - < DP head agr person second > = - / < DP head case > = objective < DP head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + | pronouns different case CB 23May19\r\n < DP head agr person second > = + < DP head agr person third > = - < DP head agr person first > = - } < VP head type no_intervening > = - | for compounding constraint\r\n < V head type object_agr_suffix > = - |CB 24May19   no object agr\r\n < DP head type nonfinalcoordination > = - < DP > == ~ [ mother_node : - ] | if coordination, must be allowed initially\r\n < DP > == [ mother_node : + ] -> [ head : [ type : [ coordination : + ] ] ] |and be complete\r\n < DP head type > == [ modifier-final : + ] -> ~ [ compound : + ] | modified DPs whose final element is marked compound, must compound 16Jul03 CB\r\n < VP head > == [ rootgloss : ^1 ] -> ~ ( ( [ object : [ head : [ type : [ modifier-final : - ] ] ] ] & [ object : [ head : [ type : [ case-marked : - ] ] ] ] ) & ( ( [ object : [ head : [ type : [ compounds_with1 : ^1 ] ] ] ] / [ object : [ head : [ type : [ compounds_with2 : ^1 ] ] ] ] ) / ( [ object : [ head : [ type : [ compounds_with3 : ^1 ] ] ] ] / [ object : [ head : [ type : [ compounds_with4 : ^1 ] ] ] ] ) ) ) |21Jul03\r\n < VP head > == [ rootgloss : ^1 ] -> ~ ( ( [ object : [ head : [ relativity : [ conjoined : + ] ] ] ] ) & ( ( [ object : [ head : [ relativity : [ compounds_with1 : ^1 ] ] ] ] / [ object : [ head : [ relativity : [ compounds_with2 : ^1 ] ] ] ] ) / ( [ object : [ head : [ relativity : [ compounds_with3 : ^1 ] ] ] ] / [ object : [ head : [ relativity : [ compounds_with4 : ^1 ] ] ] ] ) ) ) |20Oct03  for special case of relcl2+kh and 0a-DP\r\n < DP head type > == [ relative : + ] -> [ relcl : + ] | require rel suffix to only occur when relative clause present\r\n < VP head auxiliaryH > == ~ ( [ rootgloss : be.able ] & [ infl : [ tense : [ past : + ] ] ] ) | no past Aux to change tense Feb2020\r\n < VP rule > = 5cNonPastNonGenericDefinite |***Splitting this rule 26Jun2019 for case marking***adding object agreement for past only requirement 28Jun2019**All ditransitives now split Jan 2020**\r\n rule { VP option 6cIPPpast - V final, DP initial and ditransitive with PP, past only } VP = DP PP V < VP head > = < V head > { < VP head infl tense past > = + / < V head infl tense past > = - < VP head auxiliaryH rootgloss > = be.able |tense from Aux\r\n } < VP head rootgloss > = < V rootgloss > < V head object > = < DP > < V head indirectobject > = < PP head object > < PP head rootgloss > = to < V head type ditransitive > = + < V head type transitive > = + < V head case > = direct | 09-APR-04 since allow case on V+participle for adjective use\r\n < V head infl finite > = + | don't allow short or regular infinitive at end of verb phrase\r\n < V head type copular > = - < V head type motion > = - | Feb2020\r\n < V head subject > = < DP head reflexive > | pass reflexive info\r\n < V head subject > = < PP head reflexive > | pass reflexive info\r\n { < DP head type comma > = - < DP head type apposition > = - / < DP head type apposition > = + | 17Jan03  CB\r\n / < DP head type apposition > = namely | 21Nov03  CB\r\n / < DP head type relcl > = + | can have comma if relcl 27Jan03 CB\r\n < DP head type comma > = + < DP head type apposition > = - } < PP head type comma > = - < DP head type temporal > = - |Apr2020\r\n { < DP head case > = direct | 17Feb03 CB\r\n < DP head case_for_position > = direct | to know normal case for conjoined DPs\r\n < DP head type pronoun > = - / < DP head case > = direct < DP head case_for_position > = direct | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + < DP head agr person third > = + < DP head agr person first > = - < DP head agr person second > = - / < DP head case > = objective | first and second person pronouns get objective case\r\n < DP head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + < DP head agr person third > = - < DP head agr person first > = + < DP head agr person second > = - / < DP head case > = objective < DP head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + < DP head agr person third > = - < DP head agr person first > = - < DP head agr person second > = + } < PP head object head case_for_position > = objective | to know normal case for conjoined DPs \r\n < PP head object head case > = objective | IO always objective case in past\r\n < PP head type sentential > = - < VP head type passive > = - < VP head type no_intervening > = - | for compounding constraint\r\n < V head type object_agr_suffix > = + |CB 28Jun19   must have object agr\r\n < DP head type nonfinalcoordination > = - < DP > == ~ [ mother_node : - ] | if coordination, must be allowed initially\r\n < DP > == [ mother_node : + ] -> [ head : [ type : [ coordination : + ] ] ] |and be complete\r\n < DP head type > == [ relative : + ] -> [ relcl : + ] | require rel suffix to only occur when relative clause present\r\n < PP head object head type > == [ modifier-final : + ] -> ~ [ compound : + ] | PPs with modified objects whose final element is marked compound, must compound 16Jul03 CB\r\n < VP rule > = 6cIPPpast |split for past then generic and definite\r\n rule { VP option 6cIPPnonPastGeneric - V final, DP initial and ditransitive with PP } VP = DP PP V < VP head > = < V head > < VP head infl tense past > = - < VP head rootgloss > = < V rootgloss > < V head object > = < DP > < V head indirectobject > = < PP head object > | 22Aug2019\r\n < PP head rootgloss > = to < V head type ditransitive > = + < V head type transitive > = + < V head type motion > = - | Feb2020\r\n < V head case > = direct | 09-APR-04 since allow case on V+participle for adjective use\r\n < V head infl finite > = + | don't allow short or regular infinitive at end of verb phrase\r\n < DP head type generic > = + | 30May19\r\n < V head type copular > = - < V head type passive > = - < V head subject > = < DP head reflexive > | pass reflexive info\r\n < V head subject > = < PP head reflexive > | pass reflexive info\r\n { < DP head type comma > = - < DP head type apposition > = - / < DP head type apposition > = + | 17Jan03  CB\r\n / < DP head type apposition > = namely | 21Nov03  CB\r\n / < DP head type relcl > = + | can have comma if relcl 27Jan03 CB\r\n < DP head type comma > = + < DP head type apposition > = - } < PP head type comma > = - < DP head type temporal > = - |Apr2020\r\n { < DP head case > = direct < DP head case_for_position > = direct | to know normal case for conjoined DPs\r\n < DP head type pronoun > = - / < DP head case > = oblique | pronouns different case CB 23May19\r\n < DP head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + < DP head agr person third > = + < DP head agr person first > = - < DP head agr person second > = - / < DP head case > = objective < DP head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + | pronouns different case CB 23May19\r\n < DP head agr person first > = + < DP head agr person third > = - < DP head agr person second > = - / < DP head case > = objective < DP head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + | pronouns different case CB 23May19\r\n < DP head agr person second > = + < DP head agr person third > = - < DP head agr person first > = - } { < PP head object head case > = objective < PP head object head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type animate > = + < PP head object head type pronoun > = - / < PP head object head case > = oblique < PP head object head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < DP head type animate > = - < PP head object head type pronoun > = - / < PP head object head case > = oblique | pronouns different case CB 23May19\r\n < PP head object head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < DP head type animate > = - < PP head object head type pronoun > = + < PP head object head agr person third > = + < PP head object head agr person first > = - < PP head object head agr person second > = - / < PP head object head case > = objective | pronouns different case CB 23May19\r\n < PP head object head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type animate > = + < PP head object head type pronoun > = + < PP head object head agr person third > = + < PP head object head agr person first > = - < PP head object head agr person second > = - / < PP head object head case > = objective < PP head object head case_for_position > = objective | to know normal case for conjoined DPs\r\n < PP head object head type pronoun > = + | pronouns different case CB 23May19\r\n < PP head object head agr person first > = + < PP head object head agr person third > = - < PP head object head agr person second > = - / < PP head object head case > = objective < PP head object head case_for_position > = objective | to know normal case for conjoined DPs\r\n < PP head object head type pronoun > = + | pronouns different case CB 23May19\r\n < PP head object head agr person second > = + < PP head object head agr person third > = - < PP head object head agr person first > = - } < PP head type sentential > = - < VP head type passive > = - < VP head type no_intervening > = - | for compounding constraint\r\n < V head type object_agr_suffix > = - |CB 24May19   no object agr\r\n < DP head type nonfinalcoordination > = - < DP > == ~ [ mother_node : - ] | if coordination, must be allowed initially\r\n < DP > == [ mother_node : + ] -> [ head : [ type : [ coordination : + ] ] ] |and be complete\r\n < DP head type > == [ relative : + ] -> [ relcl : + ] | require rel suffix to only occur when relative clause present\r\n < PP head object head type > == [ modifier-final : + ] -> ~ [ compound : + ] | PPs with modified objects whose final element is marked compound, must compound 16Jul03 CB\r\n < VP head auxiliaryH > == ~ ( [ rootgloss : be.able ] & [ infl : [ tense : [ past : + ] ] ] ) | no past Aux to change tense Feb2020\r\n < VP rule > = 6cIPPnonPastGeneric rule { VP option 6cIPPnonPastNonGenericIndefinite - V final, DP initial and ditransitive with PP } VP = DP PP V < VP head > = < V head > < VP head infl tense past > = - < VP head rootgloss > = < V rootgloss > < V head object > = < DP > < V head indirectobject > = < PP head object > | 22Aug2019\r\n < PP head rootgloss > = to < DP head type generic > = - | 30May19\r\n < DP head type indefinite > = + < V head type ditransitive > = + < V head type transitive > = + < V head type motion > = - | Feb2020\r\n < V head case > = direct | 09-APR-04 since allow case on V+participle for adjective use\r\n < V head infl finite > = + | don't allow short or regular infinitive at end of verb phrase\r\n < V head type copular > = - < V head subject > = < DP head reflexive > | pass reflexive info\r\n < V head subject > = < PP head reflexive > | pass reflexive info\r\n { < DP head type comma > = - < DP head type apposition > = - / < DP head type apposition > = + | 17Jan03  CB\r\n / < DP head type apposition > = namely | 21Nov03  CB\r\n / < DP head type relcl > = + | can have comma if relcl 27Jan03 CB\r\n < DP head type comma > = + < DP head type apposition > = - } < PP head type comma > = - < DP head type temporal > = - |Apr2020\r\n { < DP head case > = direct < DP head case_for_position > = direct | to know normal case for conjoined DPs\r\n < DP head type pronoun > = - / < DP head case > = oblique | pronouns different case CB 23May19\r\n < DP head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + < DP head agr person third > = + < DP head agr person first > = - < DP head agr person second > = - / < DP head case > = objective < DP head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + | pronouns different case CB 23May19\r\n < DP head agr person first > = + < DP head agr person third > = - < DP head agr person second > = - / < DP head case > = objective < DP head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + | pronouns different case CB 23May19\r\n < DP head agr person second > = + < DP head agr person third > = - < DP head agr person first > = - } { < PP head object head case > = objective < PP head object head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type animate > = + < PP head object head type pronoun > = - / < PP head object head case > = oblique < PP head object head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < DP head type animate > = - < PP head object head type pronoun > = - / < PP head object head case > = oblique | pronouns different case CB 23May19\r\n < PP head object head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < DP head type animate > = - < PP head object head type pronoun > = + < PP head object head agr person third > = + < PP head object head agr person first > = - < PP head object head agr person second > = - / < PP head object head case > = objective | pronouns different case CB 23May19\r\n < PP head object head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type animate > = + < PP head object head type pronoun > = + < PP head object head agr person third > = + < PP head object head agr person first > = - < PP head object head agr person second > = - / < PP head object head case > = objective < PP head object head case_for_position > = objective | to know normal case for conjoined DPs\r\n < PP head object head type pronoun > = + | pronouns different case CB 23May19\r\n < PP head object head agr person first > = + < PP head object head agr person third > = - < PP head object head agr person second > = - / < PP head object head case > = objective < PP head object head case_for_position > = objective | to know normal case for conjoined DPs\r\n < PP head object head type pronoun > = + | pronouns different case CB 23May19\r\n < PP head object head agr person second > = + < PP head object head agr person third > = - < PP head object head agr person first > = - } < PP head type sentential > = - < VP head type passive > = - < VP head type no_intervening > = - | for compounding constraint\r\n < V head type object_agr_suffix > = - |CB 24May19   no object agr\r\n < DP head type nonfinalcoordination > = - < DP > == ~ [ mother_node : - ] | if coordination, must be allowed initially\r\n < DP > == [ mother_node : + ] -> [ head : [ type : [ coordination : + ] ] ] |and be complete\r\n < DP head type > == [ relative : + ] -> [ relcl : + ] | require rel suffix to only occur when relative clause present\r\n < PP head object head type > == [ modifier-final : + ] -> ~ [ compound : + ] | PPs with modified objects whose final element is marked compound, must compound 16Jul03 CB\r\n < VP head auxiliaryH > == ~ ( [ rootgloss : be.able ] & [ infl : [ tense : [ past : + ] ] ] ) | no past Aux to change tense Feb2020\r\n < VP rule > = 6cIPPnonPastNonGenericIndefinite rule { VP option 6cIPPnonPastNonGenericDefinite - V final, DP initial and ditransitive with PP } VP = DP PP V < VP head > = < V head > < VP head infl tense past > = - < VP head rootgloss > = < V rootgloss > < V head object > = < DP > < V head indirectobject > = < PP head object > | 22Aug2019\r\n < PP head rootgloss > = to < DP head type generic > = - < DP head type indefinite > = - < V head type ditransitive > = + < V head type transitive > = + < V head type motion > = - | Feb2020\r\n < V head case > = direct | 09-APR-04 since allow case on V+participle for adjective use\r\n < V head infl finite > = + | don't allow short or regular infinitive at end of verb phrase\r\n < V head type copular > = - < V head subject > = < DP head reflexive > | pass reflexive info\r\n < V head subject > = < PP head reflexive > | pass reflexive info\r\n |    {<DP head type comma> = -\r\n |     <DP head type apposition> = -\r\n |    /<DP head type apposition> = +    | 17Jan03  CB\r\n |    /<DP head type apposition> = namely    | 21Nov03  CB\r\n |    /<DP head type relcl> = +        | can have comma if relcl 27Jan03 CB\r\n |     <DP head type comma> = +\r\n |     <DP head type apposition> = -\r\n |    }\r\n < PP head type comma > = - < DP head type temporal > = - |Apr2020\r\n { < DP head case > = oblique < DP head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < DP head type pronoun > = - / < DP head case > = oblique | pronouns different case CB 23May19\r\n < DP head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + < DP head agr person third > = + < DP head agr person first > = - < DP head agr person second > = - / < DP head case > = objective < DP head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + | pronouns different case CB 23May19\r\n < DP head agr person first > = + < DP head agr person third > = - < DP head agr person second > = - / < DP head case > = objective < DP head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + | pronouns different case CB 23May19\r\n < DP head agr person second > = + < DP head agr person third > = - < DP head agr person first > = - } { < PP head object head case > = objective < PP head object head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type animate > = + < PP head object head type pronoun > = - / < PP head object head case > = oblique < PP head object head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < DP head type animate > = - < PP head object head type pronoun > = - / < PP head object head case > = oblique | pronouns different case CB 23May19\r\n < PP head object head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < DP head type animate > = - < PP head object head type pronoun > = + < PP head object head agr person third > = + < PP head object head agr person first > = - < PP head object head agr person second > = - / < PP head object head case > = objective | pronouns different case CB 23May19\r\n < PP head object head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type animate > = + < PP head object head type pronoun > = + < PP head object head agr person third > = + < PP head object head agr person first > = - < PP head object head agr person second > = - / < PP head object head case > = objective < PP head object head case_for_position > = objective | to know normal case for conjoined DPs\r\n < PP head object head type pronoun > = + | pronouns different case CB 23May19\r\n < PP head object head agr person first > = + < PP head object head agr person third > = - < PP head object head agr person second > = - / < PP head object head case > = objective < PP head object head case_for_position > = objective | to know normal case for conjoined DPs\r\n < PP head object head type pronoun > = + | pronouns different case CB 23May19\r\n < PP head object head agr person second > = + < PP head object head agr person third > = - < PP head object head agr person first > = - } < PP head type sentential > = - < VP head type passive > = - < VP head type no_intervening > = - | for compounding constraint\r\n < V head type object_agr_suffix > = - |CB 24May19   no object agr\r\n < DP head type nonfinalcoordination > = - < DP > == ~ [ mother_node : - ] | if coordination, must be allowed initially\r\n < DP > == [ mother_node : + ] -> [ head : [ type : [ coordination : + ] ] ] |and be complete\r\n < DP head type > == [ relative : + ] -> [ relcl : + ] | require rel suffix to only occur when relative clause present\r\n < PP head object head type > == [ modifier-final : + ] -> ~ [ compound : + ] | PPs with modified objects whose final element is marked compound, must compound 16Jul03 CB\r\n < VP head auxiliaryH > == ~ ( [ rootgloss : be.able ] & [ infl : [ tense : [ past : + ] ] ] ) | no past Aux to change tense Feb2020\r\n < VP rule > = 6cIPPnonPastNonGenericDefinite |***added 30May19 CB  For Object 3 *** split 26Jun2019\r\n rule { VP option 6cIDPpast - V final, PP initial and ditransitive with DP } VP = PP DP V < VP head > = < V head > { < VP head infl tense past > = + / < V head infl tense past > = - < VP head auxiliaryH rootgloss > = be.able |tense from Aux\r\n } < VP head rootgloss > = < V rootgloss > < V head object > = < DP > < V head indirectobject > = < PP head object > < PP head rootgloss > = to < V head type ditransitive > = + < V head type transitive > = + < V head case > = direct | 09-APR-04 since allow case on V+participle for adjective use\r\n < V head infl finite > = + | don't allow short or regular infinitive at end of verb phrase\r\n < V head type copular > = - < V head subject > = < DP head reflexive > | pass reflexive info\r\n < V head subject > = < PP head reflexive > | pass reflexive info\r\n { < DP head type comma > = - < DP head type apposition > = - / < DP head type apposition > = + | 17Jan03  CB\r\n / < DP head type apposition > = namely | 21Nov03  CB\r\n / < DP head type relcl > = + | can have comma if relcl 27Jan03 CB\r\n < DP head type comma > = + < DP head type apposition > = - } < PP head type comma > = - < DP head type temporal > = - |Apr2020\r\n { < DP head case > = direct | 17Feb03 CB\r\n < DP head case_for_position > = direct | to know normal case for conjoined DPs\r\n < DP head type pronoun > = - / < DP head case > = direct < DP head case_for_position > = direct | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + < DP head agr person third > = + < DP head agr person first > = - < DP head agr person second > = - / < DP head case > = objective | first and second person pronouns get objective case\r\n < DP head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + < DP head agr person third > = - < DP head agr person first > = + < DP head agr person second > = - / < DP head case > = objective < DP head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + < DP head agr person third > = - < DP head agr person first > = - < DP head agr person second > = + } < PP head object head case_for_position > = objective | to know normal case for conjoined DPs\r\n < PP head object head case > = objective | IO always objective case  \r\n < PP head type sentential > = - < VP head type passive > = - < VP head type no_intervening > = - | for compounding constraint\r\n < V head type object_agr_suffix > = + |CB 28Jun19   must have object agr\r\n < DP head type nonfinalcoordination > = - < DP > == ~ [ mother_node : - ] | if coordination, must be allowed initially\r\n < DP > == [ mother_node : + ] -> [ head : [ type : [ coordination : + ] ] ] |and be complete\r\n < DP head type > == [ relative : + ] -> [ relcl : + ] | require rel suffix to only occur when relative clause present\r\n < PP head object head type > == [ modifier-final : + ] -> ~ [ compound : + ] | PPs with modified objects whose final element is marked compound, must compound 16Jul03 CB\r\n < VP rule > = 6cIDPpast |split for past then generic and definite\r\n rule { VP option 6cIDPnonPastGeneric - V final, PP initial and ditransitive with DP } VP = PP DP V < VP head > = < V head > < VP head infl tense past > = - < VP head rootgloss > = < V rootgloss > < V head object > = < DP > < V head indirectobject > = < PP head object > | 22Aug2019\r\n < PP head rootgloss > = to < DP head type generic > = + | 30May19\r\n < V head type ditransitive > = + < V head type transitive > = + < V head case > = direct | 09-APR-04 since allow case on V+participle for adjective use\r\n < V head infl finite > = + | don't allow short or regular infinitive at end of verb phrase\r\n < V head type copular > = - < V head subject > = < DP head reflexive > | pass reflexive info\r\n < V head subject > = < PP head reflexive > | pass reflexive info\r\n { < DP head type comma > = - < DP head type apposition > = - / < DP head type apposition > = + | 17Jan03  CB\r\n / < DP head type apposition > = namely | 21Nov03  CB\r\n / < DP head type relcl > = + | can have comma if relcl 27Jan03 CB\r\n < DP head type comma > = + < DP head type apposition > = - } < PP head type comma > = - < DP head type temporal > = - |Apr2020\r\n { < DP head case > = direct < DP head case_for_position > = direct | to know normal case for conjoined DPs\r\n < DP head type pronoun > = - / < DP head case > = oblique | pronouns different case CB 23May19\r\n < DP head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + < DP head agr person third > = + < DP head agr person first > = - < DP head agr person second > = - / < DP head case > = objective < DP head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + | pronouns different case CB 23May19\r\n < DP head agr person first > = + < DP head agr person third > = - < DP head agr person second > = - / < DP head case > = objective < DP head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + | pronouns different case CB 23May19\r\n < DP head agr person second > = + < DP head agr person third > = - < DP head agr person first > = - } { < PP head object head case > = objective < PP head object head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type animate > = + < PP head object head type pronoun > = - / < PP head object head case > = oblique < PP head object head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < DP head type animate > = - < PP head object head type pronoun > = - / < PP head object head case > = oblique | pronouns different case CB 23May19\r\n < PP head object head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < DP head type animate > = - < PP head object head type pronoun > = + < PP head object head agr person third > = + < PP head object head agr person first > = - < PP head object head agr person second > = - / < PP head object head case > = objective | pronouns different case CB 23May19\r\n < PP head object head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type animate > = + < PP head object head type pronoun > = + < PP head object head agr person third > = + < PP head object head agr person first > = - < PP head object head agr person second > = - / < PP head object head case > = objective < PP head object head case_for_position > = objective | to know normal case for conjoined DPs\r\n < PP head object head type pronoun > = + | pronouns different case CB 23May19\r\n < PP head object head agr person first > = + < PP head object head agr person third > = - < PP head object head agr person second > = - / < PP head object head case > = objective < PP head object head case_for_position > = objective | to know normal case for conjoined DPs\r\n < PP head object head type pronoun > = + | pronouns different case CB 23May19\r\n < PP head object head agr person second > = + < PP head object head agr person third > = - < PP head object head agr person first > = - } < PP head type sentential > = - < VP head type passive > = - < VP head type no_intervening > = - | for compounding constraint\r\n < V head type object_agr_suffix > = - |CB 24May19   no object agr\r\n < DP head type nonfinalcoordination > = - < DP > == ~ [ mother_node : - ] | if coordination, must be allowed initially\r\n < DP > == [ mother_node : + ] -> [ head : [ type : [ coordination : + ] ] ] |and be complete\r\n < DP head type > == [ relative : + ] -> [ relcl : + ] | require rel suffix to only occur when relative clause present\r\n < PP head object head type > == [ modifier-final : + ] -> ~ [ compound : + ] | PPs with modified objects whose final element is marked compound, must compound 16Jul03 CB\r\n < VP head auxiliaryH > == ~ ( [ rootgloss : be.able ] & [ infl : [ tense : [ past : + ] ] ] ) | no past Aux to change tense Feb2020\r\n < VP rule > = 6cIDPnonPastGeneric rule { VP option 6cIDPnonPastNonGenericIndefinite - V final, PP initial and ditransitive with DP } VP = PP DP V < VP head > = < V head > < VP head infl tense past > = - < VP head rootgloss > = < V rootgloss > < V head object > = < DP > < V head indirectobject > = < PP head object > | 22Aug2019\r\n < PP head rootgloss > = to < DP head type generic > = - | 30May19\r\n < DP head type indefinite > = + < V head type ditransitive > = + < V head type transitive > = + < V head case > = direct | 09-APR-04 since allow case on V+participle for adjective use\r\n < V head infl finite > = + | don't allow short or regular infinitive at end of verb phrase\r\n < V head type copular > = - < V head subject > = < DP head reflexive > | pass reflexive info\r\n < V head subject > = < PP head reflexive > | pass reflexive info\r\n { < DP head type comma > = - < DP head type apposition > = - / < DP head type apposition > = + | 17Jan03  CB\r\n / < DP head type apposition > = namely | 21Nov03  CB\r\n / < DP head type relcl > = + | can have comma if relcl 27Jan03 CB\r\n < DP head type comma > = + < DP head type apposition > = - } < PP head type comma > = - < DP head type temporal > = - |Apr2020\r\n { < DP head case > = direct < DP head case_for_position > = direct | to know normal case for conjoined DPs\r\n < DP head type pronoun > = - / < DP head case > = oblique | pronouns different case CB 23May19\r\n < DP head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + < DP head agr person third > = + < DP head agr person first > = - < DP head agr person second > = - / < DP head case > = objective < DP head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + | pronouns different case CB 23May19\r\n < DP head agr person first > = + < DP head agr person third > = - < DP head agr person second > = - / < DP head case > = objective < DP head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + | pronouns different case CB 23May19\r\n < DP head agr person second > = + < DP head agr person third > = - < DP head agr person first > = - } { < PP head object head case > = objective < PP head object head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type animate > = + < PP head object head type pronoun > = - / < PP head object head case > = oblique < PP head object head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < DP head type animate > = - < PP head object head type pronoun > = - / < PP head object head case > = oblique | pronouns different case CB 23May19\r\n < PP head object head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < DP head type animate > = - < PP head object head type pronoun > = + < PP head object head agr person third > = + < PP head object head agr person first > = - < PP head object head agr person second > = - / < PP head object head case > = objective | pronouns different case CB 23May19\r\n < PP head object head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type animate > = + < PP head object head type pronoun > = + < PP head object head agr person third > = + < PP head object head agr person first > = - < PP head object head agr person second > = - / < PP head object head case > = objective < PP head object head case_for_position > = objective | to know normal case for conjoined DPs\r\n < PP head object head type pronoun > = + | pronouns different case CB 23May19\r\n < PP head object head agr person first > = + < PP head object head agr person third > = - < PP head object head agr person second > = - / < PP head object head case > = objective < PP head object head case_for_position > = objective | to know normal case for conjoined DPs\r\n < PP head object head type pronoun > = + | pronouns different case CB 23May19\r\n < PP head object head agr person second > = + < PP head object head agr person third > = - < PP head object head agr person first > = - } < PP head type sentential > = - < VP head type passive > = - < VP head type no_intervening > = - | for compounding constraint\r\n < V head type object_agr_suffix > = - |CB 24May19   no object agr\r\n < DP head type nonfinalcoordination > = - < DP > == ~ [ mother_node : - ] | if coordination, must be allowed initially\r\n < DP > == [ mother_node : + ] -> [ head : [ type : [ coordination : + ] ] ] |and be complete\r\n < DP head type > == [ relative : + ] -> [ relcl : + ] | require rel suffix to only occur when relative clause present\r\n < PP head object head type > == [ modifier-final : + ] -> ~ [ compound : + ] | PPs with modified objects whose final element is marked compound, must compound 16Jul03 CB\r\n < VP head auxiliaryH > == ~ ( [ rootgloss : be.able ] & [ infl : [ tense : [ past : + ] ] ] ) | no past Aux to change tense Feb2020\r\n < VP rule > = 6cIDPnonPastNonGenericIndefinite rule { VP option 6cIDPnonPastNonGenericDefinite - V final, PP initial and ditransitive with DP } VP = PP DP V < VP head > = < V head > < VP head infl tense past > = - < VP head rootgloss > = < V rootgloss > < V head object > = < DP > < V head indirectobject > = < PP head object > | 22Aug2019\r\n < PP head rootgloss > = to < DP head type generic > = - | 30May19\r\n < DP head type indefinite > = - < V head type ditransitive > = + < V head type transitive > = + < V head case > = direct | 09-APR-04 since allow case on V+participle for adjective use\r\n < V head infl finite > = + | don't allow short or regular infinitive at end of verb phrase\r\n < V head type copular > = - < V head subject > = < DP head reflexive > | pass reflexive info\r\n < V head subject > = < PP head reflexive > | pass reflexive info\r\n { < DP head type comma > = - < DP head type apposition > = - / < DP head type apposition > = + | 17Jan03  CB\r\n / < DP head type apposition > = namely | 21Nov03  CB\r\n / < DP head type relcl > = + | can have comma if relcl 27Jan03 CB\r\n < DP head type comma > = + < DP head type apposition > = - } < PP head type comma > = - < DP head type temporal > = - |Apr2020\r\n { < DP head case > = oblique < DP head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < DP head type pronoun > = - / < DP head case > = oblique | pronouns different case CB 23May19\r\n < DP head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + < DP head agr person third > = + < DP head agr person first > = - < DP head agr person second > = - / < DP head case > = objective < DP head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + | pronouns different case CB 23May19\r\n < DP head agr person first > = + < DP head agr person third > = - < DP head agr person second > = - / < DP head case > = objective < DP head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + | pronouns different case CB 23May19\r\n < DP head agr person second > = + < DP head agr person third > = - < DP head agr person first > = - } { < PP head object head case > = objective < PP head object head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type animate > = + < PP head object head type pronoun > = - / < PP head object head case > = oblique < PP head object head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < DP head type animate > = - < PP head object head type pronoun > = - / < PP head object head case > = oblique | pronouns different case CB 23May19\r\n < PP head object head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < DP head type animate > = - < PP head object head type pronoun > = + < PP head object head agr person third > = + < PP head object head agr person first > = - < PP head object head agr person second > = - / < PP head object head case > = objective | pronouns different case CB 23May19\r\n < PP head object head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type animate > = + < PP head object head type pronoun > = + < PP head object head agr person third > = + < PP head object head agr person first > = - < PP head object head agr person second > = - / < PP head object head case > = objective < PP head object head case_for_position > = objective | to know normal case for conjoined DPs\r\n < PP head object head type pronoun > = + | pronouns different case CB 23May19\r\n < PP head object head agr person first > = + < PP head object head agr person third > = - < PP head object head agr person second > = - / < PP head object head case > = objective < PP head object head case_for_position > = objective | to know normal case for conjoined DPs\r\n < PP head object head type pronoun > = + | pronouns different case CB 23May19\r\n < PP head object head agr person second > = + < PP head object head agr person third > = - < PP head object head agr person first > = - } < PP head type sentential > = - < VP head type passive > = - < VP head type no_intervening > = - | for compounding constraint\r\n < V head type object_agr_suffix > = - |CB 24May19   no object agr\r\n < DP head type nonfinalcoordination > = - < DP > == ~ [ mother_node : - ] | if coordination, must be allowed initially\r\n < DP > == [ mother_node : + ] -> [ head : [ type : [ coordination : + ] ] ] |and be complete\r\n < DP head type > == [ relative : + ] -> [ relcl : + ] | require rel suffix to only occur when relative clause present\r\n < PP head object head type > == [ modifier-final : + ] -> ~ [ compound : + ] | PPs with modified objects whose final element is marked compound, must compound 16Jul03 CB\r\n < VP head auxiliaryH > == ~ ( [ rootgloss : be.able ] & [ infl : [ tense : [ past : + ] ] ] ) | no past Aux to change tense Feb2020\r\n < VP rule > = 6cIDPnonPastNonGenericDefinite |*****************\r\n rule { VP option 6cIPP_1past - V final, DP initial and ditransitive with PP and PP_1, past only } VP = DP PP_1 PP V < VP head > = < V head > { < VP head infl tense past > = + / < V head infl tense past > = - < VP head auxiliaryH rootgloss > = be.able |tense from Aux\r\n } < VP head rootgloss > = < V rootgloss > < V head object > = < DP > < V head indirectobject > = < PP head object > < PP head rootgloss > = to < V head type ditransitive > = + < V head type transitive > = + < V head case > = direct | 09-APR-04 since allow case on V+participle for adjective use\r\n < V head infl finite > = + | don't allow short or regular infinitive at end of verb phrase\r\n < V head type copular > = - < V head subject > = < DP head reflexive > | pass reflexive info\r\n < V head subject > = < PP_1 head reflexive > | pass reflexive info\r\n < V head subject > = < PP head reflexive > | pass reflexive info\r\n { < DP head type comma > = - < DP head type apposition > = - / < DP head type apposition > = + | 17Jan03  CB\r\n / < DP head type apposition > = namely | 21Nov03  CB\r\n / < DP head type relcl > = + | can have comma if relcl 27Jan03 CB\r\n < DP head type comma > = + < DP head type apposition > = - } < PP head type comma > = - < PP_1 head type comma > = - < DP head type temporal > = - |Apr2020\r\n { < DP head case > = direct | 17Feb03 CB\r\n < DP head case_for_position > = direct | to know normal case for conjoined DPs\r\n < DP head type pronoun > = - / < DP head case > = direct < DP head case_for_position > = direct | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + < DP head agr person third > = + < DP head agr person first > = - < DP head agr person second > = - / < DP head case > = objective | first and second person pronouns get objective case\r\n < DP head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + < DP head agr person third > = - < DP head agr person first > = + < DP head agr person second > = - / < DP head case > = objective < DP head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + < DP head agr person third > = - < DP head agr person first > = - < DP head agr person second > = + } < PP head object head case_for_position > = objective | to know normal case for conjoined DPs \r\n < PP head object head case > = objective | IO always objective case in past\r\n < PP head type sentential > = - < PP_1 head type sentential > = - < VP head type passive > = - < VP head type no_intervening > = - | for compounding constraint\r\n < V head type object_agr_suffix > = + |CB 28Jun19   must have object agr\r\n < DP head type nonfinalcoordination > = - < DP > == ~ [ mother_node : - ] | if coordination, must be allowed initially\r\n < DP > == [ mother_node : + ] -> [ head : [ type : [ coordination : + ] ] ] |and be complete\r\n < DP head type > == [ relative : + ] -> [ relcl : + ] | require rel suffix to only occur when relative clause present\r\n < PP head object head type > == [ modifier-final : + ] -> ~ [ compound : + ] | PPs with modified objects whose final element is marked compound, must compound 16Jul03 CB\r\n < VP rule > = 6cIPP_1past |split for past then generic and definite\r\n rule { VP option 6cIPP_1nonPastGeneric - V final, DP initial and ditransitive with PP and PP_1 } VP = DP PP_1 PP V < VP head > = < V head > < VP head rootgloss > = < V rootgloss > < VP head infl tense past > = - < V head object > = < DP > < V head indirectobject > = < PP head object > | 22Aug2019\r\n < PP head rootgloss > = to < V head type ditransitive > = + < V head type transitive > = + < V head case > = direct | 09-APR-04 since allow case on V+participle for adjective use\r\n < V head infl finite > = + | don't allow short or regular infinitive at end of verb phrase\r\n < DP head type generic > = + | 30May19\r\n < V head type copular > = - < V head type passive > = - < V head subject > = < DP head reflexive > | pass reflexive info\r\n < V head subject > = < PP_1 head reflexive > | pass reflexive info\r\n < V head subject > = < PP head reflexive > | pass reflexive info\r\n { < DP head type comma > = - < DP head type apposition > = - / < DP head type apposition > = + | 17Jan03  CB\r\n / < DP head type apposition > = namely | 21Nov03  CB\r\n / < DP head type relcl > = + | can have comma if relcl 27Jan03 CB\r\n < DP head type comma > = + < DP head type apposition > = - } < PP head type comma > = - < PP_1 head type comma > = - < DP head type temporal > = - |Apr2020\r\n { < DP head case > = direct < DP head case_for_position > = direct | to know normal case for conjoined DPs\r\n < DP head type pronoun > = - / < DP head case > = oblique | pronouns different case CB 23May19\r\n < DP head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + < DP head agr person third > = + < DP head agr person first > = - < DP head agr person second > = - / < DP head case > = objective < DP head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + | pronouns different case CB 23May19\r\n < DP head agr person first > = + < DP head agr person third > = - < DP head agr person second > = - / < DP head case > = objective < DP head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + | pronouns different case CB 23May19\r\n < DP head agr person second > = + < DP head agr person third > = - < DP head agr person first > = - } { < PP head object head case > = objective < PP head object head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type animate > = + < PP head object head type pronoun > = - / < PP head object head case > = oblique < PP head object head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < DP head type animate > = - < PP head object head type pronoun > = - / < PP head object head case > = oblique | pronouns different case CB 23May19\r\n < PP head object head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < DP head type animate > = - < PP head object head type pronoun > = + < PP head object head agr person third > = + < PP head object head agr person first > = - < PP head object head agr person second > = - / < PP head object head case > = objective | pronouns different case CB 23May19\r\n < PP head object head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type animate > = + < PP head object head type pronoun > = + < PP head object head agr person third > = + < PP head object head agr person first > = - < PP head object head agr person second > = - / < PP head object head case > = objective < PP head object head case_for_position > = objective | to know normal case for conjoined DPs\r\n < PP head object head type pronoun > = + | pronouns different case CB 23May19\r\n < PP head object head agr person first > = + < PP head object head agr person third > = - < PP head object head agr person second > = - / < PP head object head case > = objective < PP head object head case_for_position > = objective | to know normal case for conjoined DPs\r\n < PP head object head type pronoun > = + | pronouns different case CB 23May19\r\n < PP head object head agr person second > = + < PP head object head agr person third > = - < PP head object head agr person first > = - } < PP head type sentential > = - < PP_1 head type sentential > = - < VP head type passive > = - < VP head type no_intervening > = - | for compounding constraint\r\n < V head type object_agr_suffix > = - |CB 24May19   no object agr\r\n < DP head type nonfinalcoordination > = - < DP > == ~ [ mother_node : - ] | if coordination, must be allowed initially\r\n < DP > == [ mother_node : + ] -> [ head : [ type : [ coordination : + ] ] ] |and be complete\r\n < DP head type > == [ relative : + ] -> [ relcl : + ] | require rel suffix to only occur when relative clause present\r\n < PP head object head type > == [ modifier-final : + ] -> ~ [ compound : + ] | PPs with modified objects whose final element is marked compound, must compound 16Jul03 CB\r\n < VP head auxiliaryH > == ~ ( [ rootgloss : be.able ] & [ infl : [ tense : [ past : + ] ] ] ) | no past Aux to change tense Feb2020\r\n < VP rule > = 6cIPP_1nonPastGeneric rule { VP option 6cIPP_1nonPastNonGenericIndefinite - V final, DP initial and ditransitive with PP and PP_1 } VP = DP PP_1 PP V < VP head > = < V head > < VP head rootgloss > = < V rootgloss > < VP head infl tense past > = - < V head object > = < DP > < V head indirectobject > = < PP head object > | 22Aug2019\r\n < PP head rootgloss > = to < DP head type generic > = - | 30May19\r\n < DP head type indefinite > = + < V head type ditransitive > = + < V head type transitive > = + < V head case > = direct | 09-APR-04 since allow case on V+participle for adjective use\r\n < V head infl finite > = + | don't allow short or regular infinitive at end of verb phrase\r\n < V head type copular > = - < V head subject > = < DP head reflexive > | pass reflexive info\r\n < V head subject > = < PP_1 head reflexive > | pass reflexive info\r\n < V head subject > = < PP head reflexive > | pass reflexive info\r\n { < DP head type comma > = - < DP head type apposition > = - / < DP head type apposition > = + | 17Jan03  CB\r\n / < DP head type apposition > = namely | 21Nov03  CB\r\n / < DP head type relcl > = + | can have comma if relcl 27Jan03 CB\r\n < DP head type comma > = + < DP head type apposition > = - } < PP head type comma > = - < PP_1 head type comma > = - < DP head type temporal > = - |Apr2020\r\n { < DP head case > = direct < DP head case_for_position > = direct | to know normal case for conjoined DPs\r\n < DP head type pronoun > = - / < DP head case > = oblique | pronouns different case CB 23May19\r\n < DP head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + < DP head agr person third > = + < DP head agr person first > = - < DP head agr person second > = - / < DP head case > = objective < DP head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + | pronouns different case CB 23May19\r\n < DP head agr person first > = + < DP head agr person third > = - < DP head agr person second > = - / < DP head case > = objective < DP head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + | pronouns different case CB 23May19\r\n < DP head agr person second > = + < DP head agr person third > = - < DP head agr person first > = - } { < PP head object head case > = objective < PP head object head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type animate > = + < PP head object head type pronoun > = - / < PP head object head case > = oblique < PP head object head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < DP head type animate > = - < PP head object head type pronoun > = - / < PP head object head case > = oblique | pronouns different case CB 23May19\r\n < PP head object head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < DP head type animate > = - < PP head object head type pronoun > = + < PP head object head agr person third > = + < PP head object head agr person first > = - < PP head object head agr person second > = - / < PP head object head case > = objective | pronouns different case CB 23May19\r\n < PP head object head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type animate > = + < PP head object head type pronoun > = + < PP head object head agr person third > = + < PP head object head agr person first > = - < PP head object head agr person second > = - / < PP head object head case > = objective < PP head object head case_for_position > = objective | to know normal case for conjoined DPs\r\n < PP head object head type pronoun > = + | pronouns different case CB 23May19\r\n < PP head object head agr person first > = + < PP head object head agr person third > = - < PP head object head agr person second > = - / < PP head object head case > = objective < PP head object head case_for_position > = objective | to know normal case for conjoined DPs\r\n < PP head object head type pronoun > = + | pronouns different case CB 23May19\r\n < PP head object head agr person second > = + < PP head object head agr person third > = - < PP head object head agr person first > = - } < PP head type sentential > = - < PP_1 head type sentential > = - < VP head type passive > = - < VP head type no_intervening > = - | for compounding constraint\r\n < V head type object_agr_suffix > = - |CB 24May19   no object agr\r\n < DP head type nonfinalcoordination > = - < DP > == ~ [ mother_node : - ] | if coordination, must be allowed initially\r\n < DP > == [ mother_node : + ] -> [ head : [ type : [ coordination : + ] ] ] |and be complete\r\n < DP head type > == [ relative : + ] -> [ relcl : + ] | require rel suffix to only occur when relative clause present\r\n < PP head object head type > == [ modifier-final : + ] -> ~ [ compound : + ] | PPs with modified objects whose final element is marked compound, must compound 16Jul03 CB\r\n < VP head auxiliaryH > == ~ ( [ rootgloss : be.able ] & [ infl : [ tense : [ past : + ] ] ] ) | no past Aux to change tense Feb2020\r\n < VP rule > = 6cIPP_1nonPastNonGenericIndefinite rule { VP option 6cIPP_1nonPastNonGenericDefinite - V final, DP initial and ditransitive with PP and PP_1 } VP = DP PP_1 PP V < VP head > = < V head > < VP head rootgloss > = < V rootgloss > < VP head infl tense past > = - < V head object > = < DP > < V head indirectobject > = < PP head object > | 22Aug2019\r\n < PP head rootgloss > = to < DP head type generic > = - < DP head type indefinite > = - < V head type ditransitive > = + < V head type transitive > = + < V head case > = direct | 09-APR-04 since allow case on V+participle for adjective use\r\n < V head infl finite > = + | don't allow short or regular infinitive at end of verb phrase\r\n < V head type copular > = - < V head subject > = < DP head reflexive > | pass reflexive info\r\n < V head subject > = < PP_1 head reflexive > | pass reflexive info\r\n < V head subject > = < PP head reflexive > | pass reflexive info\r\n { < DP head type comma > = - < DP head type apposition > = - / < DP head type apposition > = + | 17Jan03  CB\r\n / < DP head type apposition > = namely | 21Nov03  CB\r\n / < DP head type relcl > = + | can have comma if relcl 27Jan03 CB\r\n < DP head type comma > = + < DP head type apposition > = - } < PP head type comma > = - < PP_1 head type comma > = - < DP head type temporal > = - |Apr2020\r\n { < DP head case > = oblique < DP head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < DP head type pronoun > = - / < DP head case > = oblique | pronouns different case CB 23May19\r\n < DP head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + < DP head agr person third > = + < DP head agr person first > = - < DP head agr person second > = - / < DP head case > = objective < DP head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + | pronouns different case CB 23May19\r\n < DP head agr person first > = + < DP head agr person third > = - < DP head agr person second > = - / < DP head case > = objective < DP head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + | pronouns different case CB 23May19\r\n < DP head agr person second > = + < DP head agr person third > = - < DP head agr person first > = - } { < PP head object head case > = objective < PP head object head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type animate > = + < PP head object head type pronoun > = - / < PP head object head case > = oblique < PP head object head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < DP head type animate > = - < PP head object head type pronoun > = - / < PP head object head case > = oblique | pronouns different case CB 23May19\r\n < PP head object head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < DP head type animate > = - < PP head object head type pronoun > = + < PP head object head agr person third > = + < PP head object head agr person first > = - < PP head object head agr person second > = - / < PP head object head case > = objective | pronouns different case CB 23May19\r\n < PP head object head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type animate > = + < PP head object head type pronoun > = + < PP head object head agr person third > = + < PP head object head agr person first > = - < PP head object head agr person second > = - / < PP head object head case > = objective < PP head object head case_for_position > = objective | to know normal case for conjoined DPs\r\n < PP head object head type pronoun > = + | pronouns different case CB 23May19\r\n < PP head object head agr person first > = + < PP head object head agr person third > = - < PP head object head agr person second > = - / < PP head object head case > = objective < PP head object head case_for_position > = objective | to know normal case for conjoined DPs\r\n < PP head object head type pronoun > = + | pronouns different case CB 23May19\r\n < PP head object head agr person second > = + < PP head object head agr person third > = - < PP head object head agr person first > = - } < PP head type sentential > = - < PP_1 head type sentential > = - < VP head type passive > = - < VP head type no_intervening > = - | for compounding constraint\r\n < V head type object_agr_suffix > = - |CB 24May19   no object agr\r\n < DP head type nonfinalcoordination > = - < DP > == ~ [ mother_node : - ] | if coordination, must be allowed initially\r\n < DP > == [ mother_node : + ] -> [ head : [ type : [ coordination : + ] ] ] |and be complete\r\n < DP head type > == [ relative : + ] -> [ relcl : + ] | require rel suffix to only occur when relative clause present\r\n < PP head object head type > == [ modifier-final : + ] -> ~ [ compound : + ] | PPs with modified objects whose final element is marked compound, must compound 16Jul03 CB\r\n < VP head auxiliaryH > == ~ ( [ rootgloss : be.able ] & [ infl : [ tense : [ past : + ] ] ] ) | no past Aux to change tense Feb2020\r\n < VP rule > = 6cIPP_1nonPastNonGenericDefinite |*************\r\n rule { VP option 6cIPP_2past - V final, DP initial and ditransitive with PP & PP_1 & PP_2, past only } VP = DP PP_1 PP_2 PP V < VP head > = < V head > { < VP head infl tense past > = + / < V head infl tense past > = - < VP head auxiliaryH rootgloss > = be.able |tense from Aux\r\n } < VP head rootgloss > = < V rootgloss > < V head object > = < DP > < V head indirectobject > = < PP head object > < PP head rootgloss > = to < V head type ditransitive > = + < V head type transitive > = + < V head case > = direct | 09-APR-04 since allow case on V+participle for adjective use\r\n < V head infl finite > = + | don't allow short or regular infinitive at end of verb phrase\r\n < V head type copular > = - < V head subject > = < DP head reflexive > | pass reflexive info\r\n < V head subject > = < PP head reflexive > | pass reflexive info\r\n < V head subject > = < PP_1 head reflexive > | pass reflexive info\r\n < V head subject > = < PP_2 head reflexive > | pass reflexive info\r\n { < DP head type comma > = - < DP head type apposition > = - / < DP head type apposition > = + | 17Jan03  CB\r\n / < DP head type apposition > = namely | 21Nov03  CB\r\n / < DP head type relcl > = + | can have comma if relcl 27Jan03 CB\r\n < DP head type comma > = + < DP head type apposition > = - } < PP head type comma > = - < PP_1 head type comma > = - < PP_2 head type comma > = - < DP head type temporal > = - |Apr2020\r\n { < DP head case > = direct | 17Feb03 CB\r\n < DP head case_for_position > = direct | to know normal case for conjoined DPs\r\n < DP head type pronoun > = - / < DP head case > = direct < DP head case_for_position > = direct | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + < DP head agr person third > = + < DP head agr person first > = - < DP head agr person second > = - / < DP head case > = objective | first and second person pronouns get objective case\r\n < DP head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + < DP head agr person third > = - < DP head agr person first > = + < DP head agr person second > = - / < DP head case > = objective < DP head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + < DP head agr person third > = - < DP head agr person first > = - < DP head agr person second > = + } < PP head object head case_for_position > = objective | to know normal case for conjoined DPs \r\n < PP head object head case > = objective | IO always objective case in past\r\n < PP head type sentential > = - < PP_1 head type sentential > = - < PP_2 head type sentential > = - < VP head type passive > = - < VP head type no_intervening > = - | for compounding constraint\r\n < V head type object_agr_suffix > = + |CB 28Jun19   must have object agr\r\n < DP head type nonfinalcoordination > = - < DP > == ~ [ mother_node : - ] | if coordination, must be allowed initially\r\n < DP > == [ mother_node : + ] -> [ head : [ type : [ coordination : + ] ] ] |and be complete\r\n < DP head type > == [ relative : + ] -> [ relcl : + ] | require rel suffix to only occur when relative clause present\r\n < PP head object head type > == [ modifier-final : + ] -> ~ [ compound : + ] | PPs with modified objects whose final element is marked compound, must compound 16Jul03 CB\r\n < VP rule > = 6cIPP_2past |split for past then generic and definite\r\n rule { VP option 6cIPP_2nonPastGeneric - V final, DP initial and ditransitive with PP & PP_1 & PP_2 } VP = DP PP_1 PP_2 PP V < VP head > = < V head > < VP head infl tense past > = - < VP head rootgloss > = < V rootgloss > < VP head infl tense past > = - < V head object > = < DP > < V head indirectobject > = < PP head object > | 22Aug2019\r\n < PP head rootgloss > = to < V head type ditransitive > = + < V head type transitive > = + < V head case > = direct | 09-APR-04 since allow case on V+participle for adjective use\r\n < V head infl finite > = + | don't allow short or regular infinitive at end of verb phrase\r\n < DP head type generic > = + | 30May19\r\n < V head type copular > = - < V head subject > = < DP head reflexive > | pass reflexive info\r\n < V head subject > = < PP head reflexive > | pass reflexive info\r\n < V head subject > = < PP_1 head reflexive > | pass reflexive info\r\n < V head subject > = < PP_2 head reflexive > | pass reflexive info\r\n { < DP head type comma > = - < DP head type apposition > = - / < DP head type apposition > = + | 17Jan03  CB\r\n / < DP head type apposition > = namely | 21Nov03  CB\r\n / < DP head type relcl > = + | can have comma if relcl 27Jan03 CB\r\n < DP head type comma > = + < DP head type apposition > = - } < PP head type comma > = - < PP_1 head type comma > = - < PP_2 head type comma > = - < DP head type temporal > = - |Apr2020\r\n { < DP head case > = direct < DP head case_for_position > = direct | to know normal case for conjoined DPs\r\n < DP head type pronoun > = - / < DP head case > = oblique | pronouns different case CB 23May19\r\n < DP head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + < DP head agr person third > = + < DP head agr person first > = - < DP head agr person second > = - / < DP head case > = objective < DP head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + | pronouns different case CB 23May19\r\n < DP head agr person first > = + < DP head agr person third > = - < DP head agr person second > = - / < DP head case > = objective < DP head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + | pronouns different case CB 23May19\r\n < DP head agr person second > = + < DP head agr person third > = - < DP head agr person first > = - } { < PP head object head case > = objective < PP head object head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type animate > = + < PP head object head type pronoun > = - / < PP head object head case > = oblique < PP head object head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < DP head type animate > = - < PP head object head type pronoun > = - / < PP head object head case > = oblique | pronouns different case CB 23May19\r\n < PP head object head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < DP head type animate > = - < PP head object head type pronoun > = + < PP head object head agr person third > = + < PP head object head agr person first > = - < PP head object head agr person second > = - / < PP head object head case > = objective | pronouns different case CB 23May19\r\n < PP head object head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type animate > = + < PP head object head type pronoun > = + < PP head object head agr person third > = + < PP head object head agr person first > = - < PP head object head agr person second > = - / < PP head object head case > = objective < PP head object head case_for_position > = objective | to know normal case for conjoined DPs\r\n < PP head object head type pronoun > = + | pronouns different case CB 23May19\r\n < PP head object head agr person first > = + < PP head object head agr person third > = - < PP head object head agr person second > = - / < PP head object head case > = objective < PP head object head case_for_position > = objective | to know normal case for conjoined DPs\r\n < PP head object head type pronoun > = + | pronouns different case CB 23May19\r\n < PP head object head agr person second > = + < PP head object head agr person third > = - < PP head object head agr person first > = - } < PP head type sentential > = - < PP_1 head type sentential > = - < PP_2 head type sentential > = - < VP head type passive > = - < VP head type no_intervening > = - | for compounding constraint\r\n < V head type object_agr_suffix > = - |CB 24May19   no object agr\r\n < DP head type nonfinalcoordination > = - < DP > == ~ [ mother_node : - ] | if coordination, must be allowed initially\r\n < DP > == [ mother_node : + ] -> [ head : [ type : [ coordination : + ] ] ] |and be complete\r\n < DP head type > == [ relative : + ] -> [ relcl : + ] | require rel suffix to only occur when relative clause present\r\n < PP head object head type > == [ modifier-final : + ] -> ~ [ compound : + ] | PPs with modified objects whose final element is marked compound, must compound 16Jul03 CB\r\n < VP head auxiliaryH > == ~ ( [ rootgloss : be.able ] & [ infl : [ tense : [ past : + ] ] ] ) | no past Aux to change tense Feb2020\r\n < VP rule > = 6cIPP_2nonPastGeneric rule { VP option 6cIPP_2nonPastNonGenericIndefinite - V final, DP initial and ditransitive with PP & PP_1 & PP_2 } VP = DP PP_1 PP_2 PP V < VP head > = < V head > < VP head infl tense past > = - < VP head rootgloss > = < V rootgloss > < V head object > = < DP > < V head indirectobject > = < PP head object > | 22Aug2019\r\n < PP head rootgloss > = to < DP head type generic > = - | 30May19\r\n < DP head type indefinite > = + < V head type ditransitive > = + < V head type transitive > = + < V head case > = direct | 09-APR-04 since allow case on V+participle for adjective use\r\n < V head infl finite > = + | don't allow short or regular infinitive at end of verb phrase\r\n < V head type copular > = - < V head subject > = < DP head reflexive > | pass reflexive info\r\n < V head subject > = < PP head reflexive > | pass reflexive info\r\n < V head subject > = < PP_1 head reflexive > | pass reflexive info\r\n < V head subject > = < PP_2 head reflexive > | pass reflexive info\r\n { < DP head type comma > = - < DP head type apposition > = - / < DP head type apposition > = + | 17Jan03  CB\r\n / < DP head type apposition > = namely | 21Nov03  CB\r\n / < DP head type relcl > = + | can have comma if relcl 27Jan03 CB\r\n < DP head type comma > = + < DP head type apposition > = - } < PP head type comma > = - < PP_1 head type comma > = - < PP_2 head type comma > = - < DP head type temporal > = - |Apr2020\r\n { < DP head case > = direct < DP head case_for_position > = direct | to know normal case for conjoined DPs\r\n < DP head type pronoun > = - / < DP head case > = oblique | pronouns different case CB 23May19\r\n < DP head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + < DP head agr person third > = + < DP head agr person first > = - < DP head agr person second > = - / < DP head case > = objective < DP head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + | pronouns different case CB 23May19\r\n < DP head agr person first > = + < DP head agr person third > = - < DP head agr person second > = - / < DP head case > = objective < DP head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + | pronouns different case CB 23May19\r\n < DP head agr person second > = + < DP head agr person third > = - < DP head agr person first > = - } { < PP head object head case > = objective < PP head object head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type animate > = + < PP head object head type pronoun > = - / < PP head object head case > = oblique < PP head object head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < DP head type animate > = - < PP head object head type pronoun > = - / < PP head object head case > = oblique | pronouns different case CB 23May19\r\n < PP head object head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < DP head type animate > = - < PP head object head type pronoun > = + < PP head object head agr person third > = + < PP head object head agr person first > = - < PP head object head agr person second > = - / < PP head object head case > = objective | pronouns different case CB 23May19\r\n < PP head object head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type animate > = + < PP head object head type pronoun > = + < PP head object head agr person third > = + < PP head object head agr person first > = - < PP head object head agr person second > = - / < PP head object head case > = objective < PP head object head case_for_position > = objective | to know normal case for conjoined DPs\r\n < PP head object head type pronoun > = + | pronouns different case CB 23May19\r\n < PP head object head agr person first > = + < PP head object head agr person third > = - < PP head object head agr person second > = - / < PP head object head case > = objective < PP head object head case_for_position > = objective | to know normal case for conjoined DPs\r\n < PP head object head type pronoun > = + | pronouns different case CB 23May19\r\n < PP head object head agr person second > = + < PP head object head agr person third > = - < PP head object head agr person first > = - } < PP head type sentential > = - < PP_1 head type sentential > = - < PP_2 head type sentential > = - < VP head type passive > = - < VP head type no_intervening > = - | for compounding constraint\r\n < V head type object_agr_suffix > = - |CB 24May19   no object agr\r\n < DP head type nonfinalcoordination > = - < DP > == ~ [ mother_node : - ] | if coordination, must be allowed initially\r\n < DP > == [ mother_node : + ] -> [ head : [ type : [ coordination : + ] ] ] |and be complete\r\n < DP head type > == [ relative : + ] -> [ relcl : + ] | require rel suffix to only occur when relative clause present\r\n < PP head object head type > == [ modifier-final : + ] -> ~ [ compound : + ] | PPs with modified objects whose final element is marked compound, must compound 16Jul03 CB\r\n < VP head auxiliaryH > == ~ ( [ rootgloss : be.able ] & [ infl : [ tense : [ past : + ] ] ] ) | no past Aux to change tense Feb2020\r\n < VP rule > = 6cIPP_2nonPastNonGenericIndefinite rule { VP option 6cIPP_2nonPastNonGenericDefinite - V final, DP initial and ditransitive with PP & PP_1 & PP_2 } VP = DP PP_1 PP_2 PP V < VP head > = < V head > < VP head infl tense past > = - < VP head rootgloss > = < V rootgloss > < V head object > = < DP > < V head indirectobject > = < PP head object > | 22Aug2019\r\n < PP head rootgloss > = to < DP head type generic > = - < DP head type indefinite > = - < V head type ditransitive > = + < V head type transitive > = + < V head case > = direct | 09-APR-04 since allow case on V+participle for adjective use\r\n < V head infl finite > = + | don't allow short or regular infinitive at end of verb phrase\r\n < V head type copular > = - < V head subject > = < DP head reflexive > | pass reflexive info\r\n < V head subject > = < PP head reflexive > | pass reflexive info\r\n < V head subject > = < PP_1 head reflexive > | pass reflexive info\r\n < V head subject > = < PP_2 head reflexive > | pass reflexive info\r\n { < DP head type comma > = - < DP head type apposition > = - / < DP head type apposition > = + | 17Jan03  CB\r\n / < DP head type apposition > = namely | 21Nov03  CB\r\n / < DP head type relcl > = + | can have comma if relcl 27Jan03 CB\r\n < DP head type comma > = + < DP head type apposition > = - } < PP head type comma > = - < PP_1 head type comma > = - < PP_2 head type comma > = - < DP head type temporal > = - |Apr2020\r\n { < DP head case > = oblique < DP head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < DP head type pronoun > = - / < DP head case > = oblique | pronouns different case CB 23May19\r\n < DP head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + < DP head agr person third > = + < DP head agr person first > = - < DP head agr person second > = - / < DP head case > = objective < DP head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + | pronouns different case CB 23May19\r\n < DP head agr person first > = + < DP head agr person third > = - < DP head agr person second > = - / < DP head case > = objective < DP head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + | pronouns different case CB 23May19\r\n < DP head agr person second > = + < DP head agr person third > = - < DP head agr person first > = - } { < PP head object head case > = objective < PP head object head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type animate > = + < PP head object head type pronoun > = - / < PP head object head case > = oblique < PP head object head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < DP head type animate > = - < PP head object head type pronoun > = - / < PP head object head case > = oblique | pronouns different case CB 23May19\r\n < PP head object head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < DP head type animate > = - < PP head object head type pronoun > = + < PP head object head agr person third > = + < PP head object head agr person first > = - < PP head object head agr person second > = - / < PP head object head case > = objective | pronouns different case CB 23May19\r\n < PP head object head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type animate > = + < PP head object head type pronoun > = + < PP head object head agr person third > = + < PP head object head agr person first > = - < PP head object head agr person second > = - / < PP head object head case > = objective < PP head object head case_for_position > = objective | to know normal case for conjoined DPs\r\n < PP head object head type pronoun > = + | pronouns different case CB 23May19\r\n < PP head object head agr person first > = + < PP head object head agr person third > = - < PP head object head agr person second > = - / < PP head object head case > = objective < PP head object head case_for_position > = objective | to know normal case for conjoined DPs\r\n < PP head object head type pronoun > = + | pronouns different case CB 23May19\r\n < PP head object head agr person second > = + < PP head object head agr person third > = - < PP head object head agr person first > = - } < PP head type sentential > = - < PP_1 head type sentential > = - < PP_2 head type sentential > = - < VP head type passive > = - < VP head type no_intervening > = - | for compounding constraint\r\n < V head type object_agr_suffix > = - |CB 24May19   no object agr\r\n < DP head type nonfinalcoordination > = - < DP > == ~ [ mother_node : - ] | if coordination, must be allowed initially\r\n < DP > == [ mother_node : + ] -> [ head : [ type : [ coordination : + ] ] ] |and be complete\r\n < DP head type > == [ relative : + ] -> [ relcl : + ] | require rel suffix to only occur when relative clause present\r\n < PP head object head type > == [ modifier-final : + ] -> ~ [ compound : + ] | PPs with modified objects whose final element is marked compound, must compound 16Jul03 CB\r\n < VP head auxiliaryH > == ~ ( [ rootgloss : be.able ] & [ infl : [ tense : [ past : + ] ] ] ) | no past Aux to change tense Feb2020\r\n < VP rule > = 6cIPP_2nonPastNonGenericDefinite |rule added 31May19 for pn (1st/2nd) Object Case #3 ****assume pronoun IO only* split 28Jun2019***\r\n rule { VP option 6cIIDPpast - V final, pronoun DP_1 IO ( not NPrep ) and DP object } VP = DP_1 DP V < VP head > = < V head > { < VP head infl tense past > = + / < V head infl tense past > = - < VP head auxiliaryH rootgloss > = be.able |tense from Aux\r\n } < VP head rootgloss > = < V rootgloss > < V head object > = < DP > < V head indirectobject > = < DP_1 > < V head type ditransitive > = + < V head type transitive > = + < V head case > = direct | 09-APR-04 since allow case on V+participle for adjective use\r\n < V head infl finite > = + | don't allow short or regular infinitive at end of verb phrase\r\n < V head type copular > = - < V head subject > = < DP head reflexive > | pass reflexive info\r\n < V head subject > = < DP_1 head reflexive > | pass reflexive info\r\n { < DP head type comma > = - < DP head type apposition > = - / < DP head type apposition > = + | 17Jan03  CB\r\n / < DP head type apposition > = namely | 21Nov03  CB\r\n / < DP head type relcl > = + | can have comma if relcl 27Jan03 CB\r\n < DP head type comma > = + < DP head type apposition > = - } < DP head type temporal > = - |Apr2020\r\n { < DP head case > = direct | 17Feb03 CB\r\n < DP head case_for_position > = direct | to know normal case for conjoined DPs\r\n < DP head type pronoun > = - / < DP head case > = direct < DP head case_for_position > = direct | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + < DP head agr person third > = + < DP head agr person first > = - < DP head agr person second > = - / < DP head case > = objective | first and second person pronouns get objective case\r\n < DP head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + < DP head agr person third > = - < DP head agr person first > = + < DP head agr person second > = - / < DP head case > = objective < DP head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + < DP head agr person third > = - < DP head agr person first > = - < DP head agr person second > = + } < DP_1 head type comma > = - < DP_1 head type pronoun > = + < DP_1 head type apposition > = - < DP_1 head type case-marked > = - < DP_1 head type DO_contraction > = - < DP_1 head case > = objective < DP_1 head type genitive_suffix > = - < DP_1 head type locative > = - < VP head type passive > = - < VP head type no_intervening > = - | for compounding constraint\r\n < V head type object_agr_suffix > = + |CB 28Jun19   must have object agr\r\n < DP head type nonfinalcoordination > = - < DP > == ~ [ mother_node : - ] | if coordination, must be allowed initially\r\n < DP > == [ mother_node : + ] -> [ head : [ type : [ coordination : + ] ] ] |and be complete\r\n < DP head type > == [ modifier-final : + ] -> ~ [ compound : + ] | modified DPs whose final element is marked compound, must compound 16Jul03 CB\r\n < VP head > == [ rootgloss : ^1 ] -> ~ ( ( [ object : [ head : [ type : [ modifier-final : - ] ] ] ] & [ object : [ head : [ type : [ case-marked : - ] ] ] ] ) & ( ( [ object : [ head : [ type : [ compounds_with1 : ^1 ] ] ] ] / [ object : [ head : [ type : [ compounds_with2 : ^1 ] ] ] ] ) / ( [ object : [ head : [ type : [ compounds_with3 : ^1 ] ] ] ] / [ object : [ head : [ type : [ compounds_with4 : ^1 ] ] ] ] ) ) ) |21Jul03\r\n < DP head type > == [ relative : + ] -> [ relcl : + ] | require rel suffix to only occur when relative clause present\r\n < DP_1 head type > == [ relative : + ] -> [ relcl : + ] | require rel suffix to only occur when relative clause present\r\n < VP head > == [ subject : [ head : [ agr : [ person : [ first : + ] ] ] ] ] -> ~ [ indirectobject : [ head : [ agr : [ person : [ first : + ] ] ] ] ] |22Jan2020 for Pn3Obl1  \r\n < VP head > == [ subject : [ head : [ agr : [ person : [ second : + ] ] ] ] ] -> ~ [ indirectobject : [ head : [ agr : [ person : [ second : + ] ] ] ] ] < VP rule > = 6cIIDPpast |split for past then generic and definite\r\n rule { VP option 6cIIDPnonPastGeneric - V final, pronoun DP_1 IO ( not NPrep ) and DP object } VP = DP_1 DP V < VP head > = < V head > < VP head infl tense past > = - < VP head rootgloss > = < V rootgloss > < V head object > = < DP > < v head indirectobject > = < DP_1 > < DP head type generic > = + | 30May19\r\n < V head indirectobject > = < DP_1 > < V head type ditransitive > = + < V head type transitive > = + < V head case > = direct | 09-APR-04 since allow case on V+participle for adjective use\r\n < V head infl finite > = + | don't allow short or regular infinitive at end of verb phrase\r\n < V head type copular > = - < V head subject > = < DP head reflexive > | pass reflexive info\r\n < V head subject > = < DP_1 head reflexive > | pass reflexive info\r\n { < DP head type comma > = - < DP head type apposition > = - / < DP head type apposition > = + | 17Jan03  CB\r\n / < DP head type apposition > = namely | 21Nov03  CB\r\n / < DP head type relcl > = + | can have comma if relcl 27Jan03 CB\r\n < DP head type comma > = + < DP head type apposition > = - } < DP head type temporal > = - |Apr2020\r\n { < DP head case > = direct < DP head case_for_position > = direct | to know normal case for conjoined DPs\r\n < DP head type pronoun > = - / < DP head case > = oblique | pronouns different case CB 23May19\r\n < DP head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + < DP head agr person third > = + < DP head agr person first > = - < DP head agr person second > = - / < DP head case > = objective < DP head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + | pronouns different case CB 23May19\r\n < DP head agr person first > = + < DP head agr person third > = - < DP head agr person second > = - / < DP head case > = objective < DP head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + | pronouns different case CB 23May19\r\n < DP head agr person second > = + < DP head agr person third > = - < DP head agr person first > = - } < DP_1 head type comma > = - < DP_1 head type pronoun > = + { < DP_1 head case > = objective < DP_1 head agr person first > = + < DP_1 head agr person third > = - < DP_1 head agr person second > = - / < DP_1 head case > = objective < DP_1 head agr person second > = + < DP_1 head agr person third > = - < DP_1 head agr person first > = - / < DP_1 head case > = oblique | pronouns different case CB 23May19\r\n < DP head type animate > = - < DP_1 head agr person third > = + < DP_1 head agr person first > = - < DP_1 head agr person second > = - / < DP_1 head case > = objective | pronouns different case CB 23May19\r\n < DP head type animate > = + < DP_1 head agr person third > = + < DP_1 head agr person first > = - < DP_1 head agr person second > = - } < DP_1 head type apposition > = - < DP_1 head type case-marked > = - < DP_1 head type DO_contraction > = - < DP_1 head type genitive_suffix > = - < DP_1 head type locative > = - < VP head type passive > = - < VP head type no_intervening > = - | for compounding constraint\r\n < V head type object_agr_suffix > = - |CB 24May19   no object agr\r\n < DP head type nonfinalcoordination > = - < DP > == ~ [ mother_node : - ] | if coordination, must be allowed initially\r\n < DP > == [ mother_node : + ] -> [ head : [ type : [ coordination : + ] ] ] |and be complete\r\n < DP head type > == [ modifier-final : + ] -> ~ [ compound : + ] | modified DPs whose final element is marked compound, must compound 16Jul03 CB\r\n < VP head > == [ rootgloss : ^1 ] -> ~ ( ( [ object : [ head : [ type : [ modifier-final : - ] ] ] ] & [ object : [ head : [ type : [ case-marked : - ] ] ] ] ) & ( ( [ object : [ head : [ type : [ compounds_with1 : ^1 ] ] ] ] / [ object : [ head : [ type : [ compounds_with2 : ^1 ] ] ] ] ) / ( [ object : [ head : [ type : [ compounds_with3 : ^1 ] ] ] ] / [ object : [ head : [ type : [ compounds_with4 : ^1 ] ] ] ] ) ) ) |21Jul03\r\n < DP head type > == [ relative : + ] -> [ relcl : + ] | require rel suffix to only occur when relative clause present\r\n < DP_1 head type > == [ relative : + ] -> [ relcl : + ] | require rel suffix to only occur when relative clause present\r\n < VP head > == [ subject : [ head : [ agr : [ person : [ first : + ] ] ] ] ] -> ~ [ indirectobject : [ head : [ agr : [ person : [ first : + ] ] ] ] ] |22Jan2020 for Pn3Obl1  \r\n < VP head > == [ subject : [ head : [ agr : [ person : [ second : + ] ] ] ] ] -> ~ [ indirectobject : [ head : [ agr : [ person : [ second : + ] ] ] ] ] < VP head auxiliaryH > == ~ ( [ rootgloss : be.able ] & [ infl : [ tense : [ past : + ] ] ] ) | no past Aux to change tense Feb2020\r\n < VP rule > = 6cIIDPnonPastGeneric rule { VP option 6cIIDPnonPastNonGenericIndefinite - V final, pronoun DP_1 IO ( not NPrep ) and DP object } VP = DP_1 DP V < VP head > = < V head > < VP head infl tense past > = - < VP head rootgloss > = < V rootgloss > < V head object > = < DP > < V head indirectobject > = < DP_1 > < DP head type generic > = - | 30May19\r\n < DP head type indefinite > = + < V head type ditransitive > = + < V head type transitive > = + < V head case > = direct | 09-APR-04 since allow case on V+participle for adjective use\r\n < V head infl finite > = + | don't allow short or regular infinitive at end of verb phrase\r\n < V head type copular > = - < V head subject > = < DP head reflexive > | pass reflexive info\r\n < V head subject > = < DP_1 head reflexive > | pass reflexive info\r\n { < DP head type comma > = - < DP head type apposition > = - / < DP head type apposition > = + | 17Jan03  CB\r\n / < DP head type apposition > = namely | 21Nov03  CB\r\n / < DP head type relcl > = + | can have comma if relcl 27Jan03 CB\r\n < DP head type comma > = + < DP head type apposition > = - } < DP head type temporal > = - |Apr2020\r\n { < DP head case > = direct < DP head case_for_position > = direct | to know normal case for conjoined DPs\r\n < DP head type pronoun > = - / < DP head case > = oblique | pronouns different case CB 23May19\r\n < DP head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + < DP head agr person third > = + < DP head agr person first > = - < DP head agr person second > = - / < DP head case > = objective < DP head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + | pronouns different case CB 23May19\r\n < DP head agr person first > = + < DP head agr person third > = - < DP head agr person second > = - / < DP head case > = objective < DP head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + | pronouns different case CB 23May19\r\n < DP head agr person second > = + < DP head agr person third > = - < DP head agr person first > = - } < DP_1 head type comma > = - < DP_1 head type pronoun > = + { < DP_1 head case > = objective < DP_1 head agr person first > = + < DP_1 head agr person third > = - < DP_1 head agr person second > = - / < DP_1 head case > = objective < DP_1 head agr person second > = + < DP_1 head agr person third > = - < DP_1 head agr person first > = - / < DP_1 head case > = oblique | pronouns different case CB 23May19\r\n < DP head type animate > = - < DP_1 head agr person third > = + < DP_1 head agr person first > = - < DP_1 head agr person second > = - / < DP_1 head case > = objective | pronouns different case CB 23May19\r\n < DP head type animate > = + < DP_1 head agr person third > = + < DP_1 head agr person first > = - < DP_1 head agr person second > = - } < DP_1 head type apposition > = - < DP_1 head type case-marked > = - < DP_1 head type DO_contraction > = - < DP_1 head type genitive_suffix > = - < DP_1 head type locative > = - < VP head type passive > = - < VP head type no_intervening > = - | for compounding constraint\r\n < V head type object_agr_suffix > = - |CB 24May19   no object agr\r\n < DP head type nonfinalcoordination > = - < DP > == ~ [ mother_node : - ] | if coordination, must be allowed initially\r\n < DP > == [ mother_node : + ] -> [ head : [ type : [ coordination : + ] ] ] |and be complete\r\n < DP head type > == [ modifier-final : + ] -> ~ [ compound : + ] | modified DPs whose final element is marked compound, must compound 16Jul03 CB\r\n < VP head > == [ rootgloss : ^1 ] -> ~ ( ( [ object : [ head : [ type : [ modifier-final : - ] ] ] ] & [ object : [ head : [ type : [ case-marked : - ] ] ] ] ) & ( ( [ object : [ head : [ type : [ compounds_with1 : ^1 ] ] ] ] / [ object : [ head : [ type : [ compounds_with2 : ^1 ] ] ] ] ) / ( [ object : [ head : [ type : [ compounds_with3 : ^1 ] ] ] ] / [ object : [ head : [ type : [ compounds_with4 : ^1 ] ] ] ] ) ) ) |21Jul03\r\n < DP head type > == [ relative : + ] -> [ relcl : + ] | require rel suffix to only occur when relative clause present\r\n < DP_1 head type > == [ relative : + ] -> [ relcl : + ] | require rel suffix to only occur when relative clause present\r\n < VP head > == [ subject : [ head : [ agr : [ person : [ first : + ] ] ] ] ] -> ~ [ indirectobject : [ head : [ agr : [ person : [ first : + ] ] ] ] ] |22Jan2020 for Pn3Obl1  \r\n < VP head > == [ subject : [ head : [ agr : [ person : [ second : + ] ] ] ] ] -> ~ [ indirectobject : [ head : [ agr : [ person : [ second : + ] ] ] ] ] < VP head auxiliaryH > == ~ ( [ rootgloss : be.able ] & [ infl : [ tense : [ past : + ] ] ] ) | no past Aux to change tense Feb2020\r\n < VP rule > = 6cIIDPnonPastNonGenericIndefinite rule { VP option 6cIIDPnonPastNonGenericDefinite - V final, pronoun DP_1 IO ( not NPrep ) and DP object } VP = DP_1 DP V < VP head > = < V head > < VP head infl tense past > = - < VP head rootgloss > = < V rootgloss > < V head object > = < DP > < V head indirectobject > = < DP_1 > < DP head type generic > = - | 30May19\r\n < DP head type indefinite > = - < V head indirectobject > = < DP_1 > < V head type ditransitive > = + < V head type transitive > = + < V head case > = direct | 09-APR-04 since allow case on V+participle for adjective use\r\n < V head infl finite > = + | don't allow short or regular infinitive at end of verb phrase\r\n < V head type copular > = - < V head subject > = < DP head reflexive > | pass reflexive info\r\n < V head subject > = < DP_1 head reflexive > | pass reflexive info\r\n { < DP head type comma > = - < DP head type apposition > = - / < DP head type apposition > = + | 17Jan03  CB\r\n / < DP head type apposition > = namely | 21Nov03  CB\r\n / < DP head type relcl > = + | can have comma if relcl 27Jan03 CB\r\n < DP head type comma > = + < DP head type apposition > = - } < DP head type temporal > = - |Apr2020\r\n { < DP head case > = oblique < DP head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < DP head type pronoun > = - / < DP head case > = oblique | pronouns different case CB 23May19\r\n < DP head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + < DP head agr person third > = + < DP head agr person first > = - < DP head agr person second > = - / < DP head case > = objective < DP head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + | pronouns different case CB 23May19\r\n < DP head agr person first > = + < DP head agr person third > = - < DP head agr person second > = - / < DP head case > = objective < DP head case_for_position > = objective | to know normal case for conjoined DPs\r\n < DP head type pronoun > = + | pronouns different case CB 23May19\r\n < DP head agr person second > = + < DP head agr person third > = - < DP head agr person first > = - } < DP_1 head type comma > = - < DP_1 head type pronoun > = + { < DP_1 head case > = objective < DP_1 head agr person first > = + < DP_1 head agr person third > = - < DP_1 head agr person second > = - / < DP_1 head case > = objective < DP_1 head agr person second > = + < DP_1 head agr person third > = - < DP_1 head agr person first > = - / < DP_1 head case > = oblique | pronouns different case CB 23May19\r\n < DP head type animate > = - < DP_1 head agr person third > = + < DP_1 head agr person first > = - < DP_1 head agr person second > = - / < DP_1 head case > = objective | pronouns different case CB 23May19\r\n < DP head type animate > = + < DP_1 head agr person third > = + < DP_1 head agr person first > = - < DP_1 head agr person second > = - } < DP_1 head type apposition > = - < DP_1 head type case-marked > = - < DP_1 head type DO_contraction > = - < DP_1 head type genitive_suffix > = - < DP_1 head type locative > = - < VP head type passive > = - < VP head type no_intervening > = - | for compounding constraint\r\n < V head type object_agr_suffix > = - |CB 24May19   no object agr\r\n < DP head type nonfinalcoordination > = - < DP > == ~ [ mother_node : - ] | if coordination, must be allowed initially\r\n < DP > == [ mother_node : + ] -> [ head : [ type : [ coordination : + ] ] ] |and be complete\r\n < DP head type > == [ modifier-final : + ] -> ~ [ compound : + ] | modified DPs whose final element is marked compound, must compound 16Jul03 CB\r\n < VP head > == [ rootgloss : ^1 ] -> ~ ( ( [ object : [ head : [ type : [ modifier-final : - ] ] ] ] & [ object : [ head : [ type : [ case-marked : - ] ] ] ] ) & ( ( [ object : [ head : [ type : [ compounds_with1 : ^1 ] ] ] ] / [ object : [ head : [ type : [ compounds_with2 : ^1 ] ] ] ] ) / ( [ object : [ head : [ type : [ compounds_with3 : ^1 ] ] ] ] / [ object : [ head : [ type : [ compounds_with4 : ^1 ] ] ] ] ) ) ) |21Jul03\r\n < DP head type > == [ relative : + ] -> [ relcl : + ] | require rel suffix to only occur when relative clause present\r\n < DP_1 head type > == [ relative : + ] -> [ relcl : + ] | require rel suffix to only occur when relative clause present\r\n < VP head > == [ subject : [ head : [ agr : [ person : [ first : + ] ] ] ] ] -> ~ [ indirectobject : [ head : [ agr : [ person : [ first : + ] ] ] ] ] |22Jan2020 for Pn3Obl1  \r\n < VP head > == [ subject : [ head : [ agr : [ person : [ second : + ] ] ] ] ] -> ~ [ indirectobject : [ head : [ agr : [ person : [ second : + ] ] ] ] ] < VP head auxiliaryH > == ~ ( [ rootgloss : be.able ] & [ infl : [ tense : [ past : + ] ] ] ) | no past Aux to change tense Feb2020\r\n < VP rule > = 6cIIDPnonPastNonGenericDefinite | 8a and 8aQ separated 06-APR-04 to account for embedded questions with kh Aya where the main verb requires embedded_subjunctive, but not in questions\r\n rule { VP option 8a - V initial, sentential complement - non question }) (phraseStructureRule (nonTerminal VP) (ruleDef =) (rightHandSide (nonTerminal V) (disjunctiveTerminals { (nonTerminal IP) (disjunctionNonTerminal / (nonTerminal CP)) }))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head) (featurePath (atomicValue rootgloss))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue rootgloss)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue root)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal CP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue root)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal CP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue question)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_intervening)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | for compounding constraint\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue object_agr_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment |CB 24May19   no object agr\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue embedded)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head) (featurePath (atomicValue embedded))) (closingWedge >) (comment | pass down and check on verb\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue embedded)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal CP) (featurePath (atomicValue head) (featurePath (atomicValue embedded))) (closingWedge >) (comment | pass down and check on verb\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | 09-APR-04 since allow case on V+participle for adjective use\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue finite)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | don't allow short or regular infinitive at end of verb phrase\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue sentential)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not a rel clause 21Nov03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal CP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not a rel clause 21Nov03 CB\r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal CP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 8a)))))) (patrRule (ruleKW rule) (ruleIdentifier { VP option 8aQ - V initial, question complement }) (phraseStructureRule (nonTerminal VP) (ruleDef =) (rightHandSide (nonTerminal V) (nonTerminal CP))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head) (featurePath (atomicValue rootgloss))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue rootgloss)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal CP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue root)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal CP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue question)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_intervening)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | for compounding constraint\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue object_agr_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment |CB 24May19   no object agr\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | 09-APR-04 since allow case on V+participle for adjective use\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue finite)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | don't allow short or regular infinitive at end of verb phrase\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue sentential)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal CP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not a rel clause 21Nov03 CB\r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal CP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 8aQ) (comment | added 07-APR-04 CB for mmkn ast yxyy hman msyx baSd.\r\n)))))) (patrRule (ruleKW rule) (ruleIdentifier { VP option 8adj - V final, copular w/ adj, plus sentential }) (phraseStructureRule (nonTerminal VP) (ruleDef =) (rightHandSide (nonTerminal AdjP) (nonTerminal V) (nonTerminal IP))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head) (featurePath (atomicValue rootgloss))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue rootgloss)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue copular)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal AdjP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal AdjP) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue finite)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | don't allow short or regular infinitive at end of verb phrase\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue passive)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_intervening)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | for compounding constraint\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue object_agr_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment |CB 24May19   no object agr\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue root)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal AdjP) (featurePath (atomicValue embedded)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head) (featurePath (atomicValue embedded))) (closingWedge >) (comment | pass down and check on verb, sentential & embedded from Adj\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal AdjP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue sentential)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | 09-APR-04 since allow case on V+participle for adjective use\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue finite)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | don't allow short or regular infinitive at end of verb phrase\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not a rel clause 21Nov03 CB\r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal AdjP) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression ~ (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue compound)) : (featureStructureValue (atomicValue +)) (closingBracket ]) (comment | AdjPs which are marked compound, must compound\r\n)))))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 8adj)))))) (patrRule (ruleKW rule) (ruleIdentifier { VP option 9passI - V participle, passive }) (phraseStructureRule (nonTerminal VP) (ruleDef =) (rightHandSide (nonTerminal V_1) (nonTerminal V_2))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V_2) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head) (featurePath (atomicValue rootgloss))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue rootgloss)) (closingWedge >) (comment | 12-APR-04 for compounding constraints\r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head) (featurePath (atomicValue rootgloss_V_2))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal V_2) (featurePath (atomicValue rootgloss)) (closingWedge >)) (comment | 12-APR-04 for no Aux rule\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head) (featurePath (atomicValue subject))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue head) (featurePath (atomicValue subject))) (closingWedge >) (comment |    <V_2 head type comma> = -     | 03Apr03 CB need , at end of relcl\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue passive)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue participle)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | 09-APR-04 since allow case on V+participle for adjective use\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_2) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | 09-APR-04 since allow case on V+participle for adjective use\r\n)) (comment |      <V_1 head type compounded> = -         | RL 29Mar03  Need compounding for sentences like: bh^^wasvhE aw parsa Smrdh my^Swd\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_2) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue finite)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | don't allow short or regular infinitive at end of verb phrase\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_intervening)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | for compounding constraint\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue object_agr_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment |CB 24May19   no object agr\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue object_agr_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment |CB 24May19   no object agr\r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue participle_passive)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | 12-APR-04 to restrict V+participle\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 9passI)))))) (patrRule (ruleKW rule) (ruleIdentifier { VP option 9f - V final, passive }) (phraseStructureRule (nonTerminal VP) (ruleDef =) (rightHandSide (nonTerminal V))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head) (featurePath (atomicValue rootgloss))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue rootgloss)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue passive)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | 09-APR-04 since allow case on V+participle for adjective use\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue finite)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | don't allow short or regular infinitive at end of verb phrase\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_intervening)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | for compounding constraint\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue object_agr_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment |CB 24May19   no object agr\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal VP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 9f) (comment | F and Fcop were identical, except for copular feature, so combined 10Dec03\r\n)))))) (patrRule (ruleKW rule) (ruleIdentifier { V option F - Aux initial, required -- Future }) (phraseStructureRule (nonTerminal V) (ruleDef =) (rightHandSide (nonTerminal Aux) (nonTerminal V_1))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal Aux) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Aux) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | 09-APR-04 since allow case on V+participle for adjective use\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue finite)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue short) (comment | requires the verb to have the feature short_infinitive\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Aux) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue tense) (featurePath (atomicValue future))))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | requires that the auxillary have the future feature.\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue rootgloss)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue rootgloss)) (closingWedge >) (comment | RL 16Jan03 pass up the root gloss so compounding works.\r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) (comment | type features come from V, agr from Aux\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue rootgloss_V_2))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue head) (featurePath (atomicValue rootgloss_V_2))) (closingWedge >) (comment | 13-APR-04 restrict Aux \r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue object_agr_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment |CB 24May19   no object agr\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Aux) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue object_agr_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment |CB 24May19   no object agr\r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue finite)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | future adds finiteness, then can fit other rules 03Apr03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue F) (comment |Added22Jan2020 for Pn3Obl3 **split by transitive & intransitive for object agr marking*\r\n)))))) (patrRule (ruleKW rule) (ruleIdentifier { V option Prt - Participle & perfective Aux ( V ) }) (phraseStructureRule (nonTerminal V) (ruleDef =) (rightHandSide (optionalTerminals ( (nonTerminal V_2) (nonTerminal Conj) )) (nonTerminal V_1) (nonTerminal Aux))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal Aux) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | 09-APR-04 since allow case on V+participle for adjective use\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_2) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | 09-APR-04 since allow case on V+participle for adjective use\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue rootgloss)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal Aux) (featurePath (atomicValue rootgloss)) (closingWedge >) (comment | RL 16Jan03 pass up the root gloss so compounding works.\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue rootgloss_V_2))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue none) (comment | to prevent become rule Feb2020\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue object_agr_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment |CB 24May19   no object agr\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue object_agr_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment |CB 24May19   no object agr\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Aux) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue object_agr_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment |CB 24May19   no object agr\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue participle)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue participle)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Aux) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue aspect) (featurePath (atomicValue perfective))))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment |changed from copular 29Jan2020\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue copular)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | V construction not copular 31Jan2020 \r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue motion)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue motion)))) (closingWedge >)) (comment | changed 27Jan2020 for Pn3Gen2  \r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue -)) (comment | changed 27Jan2020 for Pn3Gen2  \r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue tense) (featurePath (atomicValue past))))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | changed 27Jan2020 for Pn3Gen2  \r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue participle)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | changed 27Jan2020 for Pn3Gen2  \r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue Prt)))))) (patrRule (ruleKW rule) (ruleIdentifier { V option PrtTrPst - Transitive Participle & perfective Aux Pst }) (phraseStructureRule (nonTerminal V) (ruleDef =) (rightHandSide (optionalTerminals ( (nonTerminal V_2) (nonTerminal Conj) )) (nonTerminal V_1) (nonTerminal Aux))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal Aux) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | 09-APR-04 since allow case on V+participle for adjective use\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_2) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | 09-APR-04 since allow case on V+participle for adjective use\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue rootgloss)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal Aux) (featurePath (atomicValue rootgloss)) (closingWedge >) (comment | RL 16Jan03 pass up the root gloss so compounding works.\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue rootgloss_V_2))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue none) (comment | to prevent become rule Feb2020\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue object_agr_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment |CB 24May19   no object agr\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue object_agr_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment |CB 24May19   no object agr\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Aux) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue object_agr_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment |CB 24May19   must have object agr\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Aux) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue tense) (featurePath (atomicValue past))))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue participle)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue participle)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Aux) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue aspect) (featurePath (atomicValue perfective))))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment |changed from copular 29Jan2020\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue copular)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | V construction not copular 31Jan2020 \r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue motion)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue motion)))) (closingWedge >)) (comment | changed 27Jan2020 for Pn3Gen2  \r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | changed 27Jan2020 for Pn3Gen2  \r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue tense) (featurePath (atomicValue past))))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | changed 27Jan2020 for Pn3Gen2  \r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue participle)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | changed 27Jan2020 for Pn3Gen2  \r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue PrtTrPst) (comment |new rule Apr2020 split for V-Participle 3,15\r\n)))))) (patrRule (ruleKW rule) (ruleIdentifier { V option PrtTrPrs - Transitive Participle & perfective Aux Pres }) (phraseStructureRule (nonTerminal V) (ruleDef =) (rightHandSide (optionalTerminals ( (nonTerminal V_2) (nonTerminal Conj) )) (nonTerminal V_1) (nonTerminal Aux))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal Aux) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | 09-APR-04 since allow case on V+participle for adjective use\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_2) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | 09-APR-04 since allow case on V+participle for adjective use\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue rootgloss)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal Aux) (featurePath (atomicValue rootgloss)) (closingWedge >) (comment | RL 16Jan03 pass up the root gloss so compounding works.\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue rootgloss_V_2))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue none) (comment | to prevent become rule Feb2020\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue object_agr_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment |CB 24May19   no object agr\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue object_agr_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment |CB 24May19   no object agr\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Aux) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue object_agr_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment |CB 24May19   no object agr\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Aux) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue tense) (featurePath (atomicValue present))))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue participle)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue participle)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Aux) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue aspect) (featurePath (atomicValue perfective))))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment |changed from copular 29Jan2020\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue copular)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | V construction not copular 31Jan2020 \r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue motion)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue motion)))) (closingWedge >)) (comment | changed 27Jan2020 for Pn3Gen2  \r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | changed 27Jan2020 for Pn3Gen2  \r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue tense) (featurePath (atomicValue past))))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue -)) (comment | changed 27Jan2020 for Pn3Gen2  \r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue tense) (featurePath (atomicValue present))))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | changed 27Jan2020 for Pn3Gen2  \r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue participle)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | changed 27Jan2020 for Pn3Gen2  \r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue PrtTrPrs) (comment |This did not work so compound optional in two rules above |participles split off  \r\n)) (comment |rule {V option conjoinedPart}\r\n))) (constraint (comment |V = V_1 Conj V_2\r\n)) (constraint (comment |    <V head> = <V_2 head>                 | all V's share most features\r\n)) (constraint (comment |    <V head rootgloss> = <V_1 rootgloss>  | rootgloss from V_1 for compounding info\r\n)) (constraint (comment |    <V head rootgloss_V_2> <= <V_2 rootgloss> | for Aux constraints 12-APR-04 \r\n)) (constraint (comment |    <V head infl> = <V_1 head infl>       | all V's share most features\r\n)) (constraint (comment |    <V head subject> = <V_1 head subject>    \r\n)) (constraint (comment |    <V_1 head type transitive> = +\r\n)) (constraint (comment |    <V_2 head type transitive> = +\r\n)) (constraint (comment |    <V_1 head case> = direct       | 09-APR-04 since allow case on V+participle for adjective use\r\n)) (constraint (comment |    <V_2 head case> = direct      | 09-APR-04 since allow case on V+participle for adjective use\r\n)) (constraint (comment |    <V_1 head type participle> = +\r\n)) (constraint (comment |    <V_2 head type participle> = +\r\n)) (constraint (comment |    <V head type copular> = <V_1 head type copular>\r\n)) (constraint (comment |    <V head type passive> = <V_1 head type passive>\r\n)) (constraint (comment |    <V head type motion> = <V_1 head type motion>\r\n)) (constraint (comment |    <V_1 head type object_agr_suffix> = -   |obj suffixes only on aux  6Feb2020\r\n)) (constraint (comment |    <V_2 head type object_agr_suffix> = -\r\n)) (constraint (comment |    <Conj gloss> = and\r\n)) (constraint (comment |    <V conjoined> <= +       | for compounding constraint in V rule 1\r\n)) (constraint (comment |    <V rule> = conjoinedPart\r\n)) (constraint (comment | object agreement restrictions not added below here for now. SHould not need since all V's marked above 05May19\r\n)))) (patrRule (ruleKW rule) (ruleIdentifier { V option 1 - compound with noun }) (phraseStructureRule (nonTerminal V) (ruleDef =) (rightHandSide (nonTerminal N) (nonTerminal V_1))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue rootgloss)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue rootgloss)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue reflexivity)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue indefinite)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue proper)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue finite)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | case marking getting through #3 Apr2020????\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment |Apr2020\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number) (featurePath (atomicValue plural))))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue copular_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue genitive_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment |Apr2020\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier_required)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment |Apr2020\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | 09-APR-04 since allow case on V+participle for adjective use\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not conjoined V's\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (disjunctiveUnificationConstraint { (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue rootgloss)) (closingWedge >))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with2)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue rootgloss)) (closingWedge >)))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with3)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue rootgloss)) (closingWedge >)))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with4)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue rootgloss)) (closingWedge >)))) }))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounded)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | to prevent double compounding\r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounded)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | to prevent double compounding\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue sentential)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal N) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue sentential)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal N) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal N) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue ditransitive)))) (closingWedge >)) (comment |Apr2020 \r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue passive)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal N) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue passive)))) (closingWedge >)) (comment | let N override passive RL 20Mar03\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue copular)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue -)) (comment | RL 28Mar03 compound verbs are never copular\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue embedded)) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal N) (featurePath (atomicValue embedded)) (closingWedge >)))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal N) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression ~ (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue compound)) : (featureStructureValue (atomicValue -)) (closingBracket ]) (comment | words which never compound should be marked -compound\r\n)))))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 1) (comment | rule added **19Jul06 CB\r\n)))))) (patrRule (ruleKW rule) (ruleIdentifier { V option 1dblN - double compound with noun }) (phraseStructureRule (nonTerminal V) (ruleDef =) (rightHandSide (nonTerminal N_1) (nonTerminal Conj) (nonTerminal N_2) (nonTerminal V_1))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue rootgloss)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue rootgloss)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue gloss)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue and)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue reflexivity)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue indefinite)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue proper)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N_1) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue finite)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N_1) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N_1) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number) (featurePath (atomicValue plural))))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue copular_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue reflexivity)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue indefinite)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue proper)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N_2) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue finite)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N_2) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N_2) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number) (featurePath (atomicValue plural))))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue copular_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | 09-APR-04 since allow case on V+participle for adjective use\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not conjoined V's\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (disjunctiveUnificationConstraint { (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue rootgloss)) (closingWedge >))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with2)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue rootgloss)) (closingWedge >)))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with3)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue rootgloss)) (closingWedge >)))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with4)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue rootgloss)) (closingWedge >)))) }))) (constraint (unificationConstraint (disjunctiveUnificationConstraint { (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue rootgloss)) (closingWedge >))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with2)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue rootgloss)) (closingWedge >)))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with3)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue rootgloss)) (closingWedge >)))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with4)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue rootgloss)) (closingWedge >)))) }))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounded)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | to prevent double compounding\r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounded)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | to prevent double compounding\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue sentential)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal N_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue sentential)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal N_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue passive)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal N_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue passive)))) (closingWedge >)) (comment | let N override passive RL 20Mar03\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue copular)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue -)) (comment | RL 28Mar03 compound verbs are never copular\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue embedded)) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal N_2) (featurePath (atomicValue embedded)) (closingWedge >)))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal N_1) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression ~ (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue compound)) : (featureStructureValue (atomicValue -)) (closingBracket ]) (comment | words which never compound should be marked -compound\r\n)))))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal N_2) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression ~ (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue compound)) : (featureStructureValue (atomicValue -)) (closingBracket ]) (comment | words which never compound should be marked -compound\r\n)))))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 1dblN)))))) (patrRule (ruleKW rule) (ruleIdentifier { V option 2 - compound with adjective }) (phraseStructureRule (nonTerminal V) (ruleDef =) (rightHandSide (nonTerminal Adj) (nonTerminal V_1))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue rootgloss)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue rootgloss)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Adj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Adj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Adj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue indefinite)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Adj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue attributive)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | CB 23May2019 assuming like predicate adjectives\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Adj) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Adj) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number) (featurePath (atomicValue plural))))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment |RL 22Apr202\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Adj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue copular_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (disjunctiveUnificationConstraint { (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Adj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue rootgloss)) (closingWedge >))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Adj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with2)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue rootgloss)) (closingWedge >)))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Adj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with3)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue rootgloss)) (closingWedge >)))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Adj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with4)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue rootgloss)) (closingWedge >)))) }))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | 09-APR-04 since allow case on V+participle for adjective use\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounded)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | to prevent double compounding\r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounded)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | to prevent double compounding\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue sentential)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal Adj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue sentential)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal Adj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue ditransitive)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal Adj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue ditransitive)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue passive)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal Adj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue passive)))) (closingWedge >)) (comment | let Adj override passive RL 20Mar03\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue copular)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue -)) (comment | RL 28Mar03 compound verbs are never copular\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue embedded)) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal Adj) (featurePath (atomicValue embedded)) (closingWedge >)))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal Adj) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression ~ (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue compound)) : (featureStructureValue (atomicValue -)) (closingBracket ]) (comment | words which never compound should be marked -compound\r\n)))))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 2) (comment | rule added **19Jul06 CB\r\n)))))) (patrRule (ruleKW rule) (ruleIdentifier { V option 2dblAdj - double compound with adjective }) (phraseStructureRule (nonTerminal V) (ruleDef =) (rightHandSide (nonTerminal Adj_1) (nonTerminal Conj) (nonTerminal Adj_2) (nonTerminal V_1))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue rootgloss)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue rootgloss)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue gloss)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue and)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Adj_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Adj_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Adj_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue indefinite)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Adj_1) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Adj_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue copular_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Adj_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Adj_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Adj_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue indefinite)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Adj_2) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Adj_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue copular_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (disjunctiveUnificationConstraint { (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Adj_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue rootgloss)) (closingWedge >))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Adj_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with2)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue rootgloss)) (closingWedge >)))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Adj_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with3)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue rootgloss)) (closingWedge >)))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Adj_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with4)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue rootgloss)) (closingWedge >)))) }))) (constraint (unificationConstraint (disjunctiveUnificationConstraint { (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Adj_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue rootgloss)) (closingWedge >))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Adj_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with2)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue rootgloss)) (closingWedge >)))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Adj_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with3)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue rootgloss)) (closingWedge >)))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Adj_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with4)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue rootgloss)) (closingWedge >)))) }))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | 09-APR-04 since allow case on V+participle for adjective use\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounded)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | to prevent double compounding\r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounded)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | to prevent double compounding\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue sentential)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal Adj_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue sentential)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal Adj_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue passive)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal Adj_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue passive)))) (closingWedge >)) (comment | let Adj override passive RL 20Mar03\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue copular)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue -)) (comment | RL 28Mar03 compound verbs are never copular\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue embedded)) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal Adj_2) (featurePath (atomicValue embedded)) (closingWedge >)))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal Adj_1) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression ~ (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue compound)) : (featureStructureValue (atomicValue -)) (closingBracket ]) (comment | words which never compound should be marked -compound\r\n)))))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal Adj_2) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression ~ (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue compound)) : (featureStructureValue (atomicValue -)) (closingBracket ]) (comment | words which never compound should be marked -compound\r\n)))))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 2dblAdj) (comment |does this need to be changed for compound as above??  If so, check DP rules.\r\n)))))) (patrRule (ruleKW rule) (ruleIdentifier { V option 3 - compound with 'alone' }) (phraseStructureRule (nonTerminal V) (ruleDef =) (rightHandSide (nonTerminal Deg) (nonTerminal V_1))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue rootgloss)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue rootgloss)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | 09-APR-04 since allow case on V+participle for adjective use\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounded)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | to prevent double compounding\r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounded)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | to prevent double compounding\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 3) (comment |conjoined V's  added 20Oct03 CB |may need to add participle and/or other type features\r\n)) (comment |04Dec03 RL Require the verbs to be transitive. I think this is the situation that created\r\n))) (constraint (comment |the need for this rule. Acts 14:5. For the intransitive case like Acts 13:9 compounding works\r\n)) (constraint (comment |fine with VP rule 0conj\r\n)) (constraint (comment |Not for participles  Feb2020\r\n)))) (patrRule (ruleKW rule) (ruleIdentifier { V option conjoined }) (phraseStructureRule (nonTerminal V) (ruleDef =) (rightHandSide (nonTerminal V_1) (nonTerminal Conj) (nonTerminal V_2))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V_2) (featurePath (atomicValue head)) (closingWedge >) (comment | all V's share most features\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue rootgloss))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue rootgloss)) (closingWedge >) (comment | rootgloss from V_1 for compounding info\r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue rootgloss_V_2))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal V_2) (featurePath (atomicValue rootgloss)) (closingWedge >)) (comment | for Aux constraints 12-APR-04 \r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue infl))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue head) (featurePath (atomicValue infl))) (closingWedge >) (comment | all V's share most features\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue subject))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue head) (featurePath (atomicValue subject))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue transitive)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue participle)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue participle)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | 09-APR-04 since allow case on V+participle for adjective use\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V_2) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | 09-APR-04 since allow case on V+participle for adjective use\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue copular)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue copular)))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue passive)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue passive)))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue motion)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal V_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue motion)))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue gloss)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue and)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue conjoined)) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | for compounding constraint in V rule 1\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue conjoined) (comment |-****Coordinate DPs without recursion\r\n)))))) (patrRule (ruleKW rule) (ruleIdentifier { DP option Sand - single with 'and' }) (phraseStructureRule (nonTerminal DP) (ruleDef =) (rightHandSide (optionalTerminals ( (nonTerminal Conj_1) )) (nonTerminal DP_1) (nonTerminal Conj) (nonTerminal DP_2))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >) (comment | pass reflexive info\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >) (comment | pass reflexive info\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue nonfinalcoordination)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | for AdjP case 14Aug03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue nonfinalcoordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | for AdjP case 14Aug03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DO_contraction)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue gloss)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue and)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj_1) (featurePath (atomicValue gloss)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue also)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue conjoins_DP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | initial DP in coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not initial DP in coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not initial DP in coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | to restrict recursion\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-final)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | set feature for mother DP\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | set feature for mother DP\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | set feature for mother DP\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person)))) (closingWedge >) (comment | initial DP gives person\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue human)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue human)))) (closingWedge >) (comment | initial DP gives human\r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pronoun)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pronoun)))) (closingWedge >)) (comment | pronoun from final DP\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue proper)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue proper)))) (closingWedge >)) (comment | proper from final DP\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_head_N)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_head_N)))) (closingWedge >)) (comment | no_head_N from final DP\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue locative)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue locative)))) (closingWedge >) (comment | initial DP gives locative Jan03CB**\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue apposition)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue apposition)))) (closingWedge >) (comment | final DP gives apposition 31Mar03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >) (comment | case determined by\r\n)) (comment | position in sentence\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >) (comment | for apposition 22Jan03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | initial conjuncts unmarked\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-final)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | final conjuncts have case\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number) (featurePath (atomicValue plural))))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | plural comes from 'and'\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number) (featurePath (atomicValue singular))))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue -)))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relative)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relcl)) : (featureStructureValue (atomicValue +)) (closingBracket ]) (comment | require rel suffix to only occur when relative clause present\r\n)))))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relative)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relcl)) : (featureStructureValue (atomicValue +)) (closingBracket ]) (comment | require rel suffix to only occur when relative clause present\r\n)))))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) (comment | 24Jul03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue Sand)))))) (patrRule (ruleKW rule) (ruleIdentifier { DP option Sor - single with 'or' }) (phraseStructureRule (nonTerminal DP) (ruleDef =) (rightHandSide (optionalTerminals ( (nonTerminal Conj_1) )) (nonTerminal DP_1) (nonTerminal Conj) (nonTerminal DP_2))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >) (comment | pass reflexive info\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >) (comment | pass reflexive info\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue nonfinalcoordination)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | for AdjP case 14Aug03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue nonfinalcoordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | for AdjP case 14Aug03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DO_contraction)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue gloss)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue or)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj_1) (featurePath (atomicValue gloss)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue or)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue conjoins_DP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | initial DP in coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not initial DP in coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not initial DP in coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | to restrict recursion\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-final)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | set feature for mother DP\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | set feature for mother DP\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | set feature for mother DP\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person)))) (closingWedge >) (comment | initial DP gives person\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number)))) (closingWedge >) (comment | initial DP gives number\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue human)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue human)))) (closingWedge >) (comment | initial DP gives human\r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pronoun)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pronoun)))) (closingWedge >)) (comment | pronoun from final DP\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue proper)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue proper)))) (closingWedge >)) (comment | proper from final DP\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_head_N)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_head_N)))) (closingWedge >)) (comment | no_head_N from final DP\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue locative)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue locative)))) (closingWedge >) (comment | initial DP gives locative Jan03CB**\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue apposition)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue apposition)))) (closingWedge >) (comment | final DP gives apposition 31Mar03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >) (comment | case determined by\r\n)) (comment | position in sentence\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >) (comment | for apposition 22Jan03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | initial conjuncts unmarked\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >) (comment | final conjuncts have case\r\n)))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relative)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relcl)) : (featureStructureValue (atomicValue +)) (closingBracket ]) (comment | require rel suffix to only occur when relative clause present\r\n)))))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relative)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relcl)) : (featureStructureValue (atomicValue +)) (closingBracket ]) (comment | require rel suffix to only occur when relative clause present\r\n)))))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) (comment | 24Jul03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue Sor)))))) (patrRule (ruleKW rule) (ruleIdentifier { DP option Swhether - single with 'whether' }) (phraseStructureRule (nonTerminal DP) (ruleDef =) (rightHandSide (nonTerminal Conj_1) (nonTerminal DP_1) (nonTerminal Conj) (nonTerminal DP_2))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >) (comment | pass reflexive info\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >) (comment | pass reflexive info\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue nonfinalcoordination)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | for AdjP case 14Aug03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue nonfinalcoordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | for AdjP case 14Aug03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DO_contraction)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue gloss)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue whether)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj_1) (featurePath (atomicValue gloss)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue whether)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue conjoins_DP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | initial DP in coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not initial DP in coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not initial DP in coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | to restrict recursion\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-final)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | set feature for mother DP\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | set feature for mother DP\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | set feature for mother DP\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person)))) (closingWedge >) (comment | initial DP gives person\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number)))) (closingWedge >) (comment | initial DP gives number\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue human)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue human)))) (closingWedge >) (comment | initial DP gives human\r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pronoun)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pronoun)))) (closingWedge >)) (comment | pronoun from final DP\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue proper)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue proper)))) (closingWedge >)) (comment | proper from final DP\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_head_N)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_head_N)))) (closingWedge >)) (comment | no_head_N from final DP\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue locative)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue locative)))) (closingWedge >) (comment | initial DP gives locative Jan03CB**\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue apposition)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue apposition)))) (closingWedge >) (comment | final DP gives apposition 31Mar03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >) (comment | case determined by\r\n)) (comment | position in sentence\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >) (comment | for apposition 22Jan03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | initial conjuncts unmarked\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >) (comment | final conjuncts have case\r\n)))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relative)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relcl)) : (featureStructureValue (atomicValue +)) (closingBracket ]) (comment | require rel suffix to only occur when relative clause present\r\n)))))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relative)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relcl)) : (featureStructureValue (atomicValue +)) (closingBracket ]) (comment | require rel suffix to only occur when relative clause present\r\n)))))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) (comment | 24Jul03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue Swhether) (comment |***************************\r\n)) (comment |-****Coordinate DPs, initial (with recursion)\r\n))))) (patrRule (ruleKW rule) (ruleIdentifier { DP option Iand - initial with 'and' }) (phraseStructureRule (nonTerminal DP) (ruleDef =) (rightHandSide (optionalTerminals ( (nonTerminal Conj_1) )) (nonTerminal DP_1) (nonTerminal Conj) (nonTerminal DP_2))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >) (comment | pass reflexive info\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >) (comment | pass reflexive info\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue initial)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue nonfinalcoordination)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | for AdjP case 14Aug03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DO_contraction)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue gloss)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue and)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj_1) (featurePath (atomicValue gloss)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue also)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue conjoins_DP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | initial DP in coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not initial DP in coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not initial DP in coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | to restrict recursion\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue conjunction) (featurePath (atomicValue gloss))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue gloss)) (closingWedge >) (comment | pass Conj info to DP_2 to correctly restrict Conj possible in recursion\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-final)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | set feature for mother DP\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | set feature for mother DP\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | set feature for mother DP\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person)))) (closingWedge >) (comment | initial DP gives person\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue human)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue human)))) (closingWedge >) (comment | initial DP gives human\r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pronoun)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pronoun)))) (closingWedge >)) (comment | pronoun from final DP\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue proper)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue proper)))) (closingWedge >)) (comment | proper from final DP\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_head_N)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_head_N)))) (closingWedge >)) (comment | no_head_N from final DP\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue locative)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue locative)))) (closingWedge >) (comment | initial DP gives locative Jan03CB**\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue apposition)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue apposition)))) (closingWedge >) (comment | final DP gives apposition 31Mar03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >) (comment | case determined by\r\n)) (comment | position in sentence\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >) (comment | for apposition 22Jan03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >) (comment | non-final conjunct\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | initial conjuncts unmarked\r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number) (featurePath (atomicValue plural))))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | plural comes from 'and'\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number) (featurePath (atomicValue singular))))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue -)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) (comment | final overrules\r\n))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relative)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relcl)) : (featureStructureValue (atomicValue +)) (closingBracket ]) (comment | require rel suffix to only occur when relative clause present\r\n)))))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relative)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relcl)) : (featureStructureValue (atomicValue +)) (closingBracket ]) (comment | require rel suffix to only occur when relative clause present\r\n)))))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) (comment | 24Jul03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue Iand)))))) (patrRule (ruleKW rule) (ruleIdentifier { DP option I2or - initial with two 'or' }) (phraseStructureRule (nonTerminal DP) (ruleDef =) (rightHandSide (nonTerminal Conj_1) (nonTerminal DP_1) (nonTerminal Conj) (nonTerminal DP_2))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >) (comment | pass reflexive info\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >) (comment | pass reflexive info\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue initial)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue nonfinalcoordination)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | for AdjP case 14Aug03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue conjunction_gloss)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue initial_ya) (comment | to restrict splitting between subject and object\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DO_contraction)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue gloss)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue or)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj_1) (featurePath (atomicValue gloss)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue or)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue conjoins_DP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | initial DP in coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not initial DP in coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not initial DP in coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | to restrict recursion\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue conjunction) (featurePath (atomicValue gloss))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue gloss)) (closingWedge >) (comment | pass Conj info to DP_2 to correctly restrict Conj possible in recursion\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-final)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | set feature for mother DP\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | set feature for mother DP\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | set feature for mother DP\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person)))) (closingWedge >) (comment | initial DP gives person\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number)))) (closingWedge >) (comment | initial DP gives number\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue human)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue human)))) (closingWedge >) (comment | initial DP gives human\r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pronoun)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pronoun)))) (closingWedge >)) (comment | pronoun from final DP\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue proper)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue proper)))) (closingWedge >)) (comment | proper from final DP\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_head_N)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_head_N)))) (closingWedge >)) (comment | no_head_N from final DP\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue locative)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue locative)))) (closingWedge >) (comment | initial DP gives locative Jan03CB**\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue apposition)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue apposition)))) (closingWedge >) (comment | final DP gives apposition 31Mar03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >) (comment | case determined by\r\n)) (comment | position in sentence\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >) (comment | for apposition 22Jan03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >) (comment | non-final conjunct\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | initial conjuncts unmarked\r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) (comment | final overrules\r\n))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relative)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relcl)) : (featureStructureValue (atomicValue +)) (closingBracket ]) (comment | require rel suffix to only occur when relative clause present\r\n)))))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relative)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relcl)) : (featureStructureValue (atomicValue +)) (closingBracket ]) (comment | require rel suffix to only occur when relative clause present\r\n)))))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) (comment | 24Jul03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue I2or)))))) (patrRule (ruleKW rule) (ruleIdentifier { DP option Ior - initial with 'or' }) (phraseStructureRule (nonTerminal DP) (ruleDef =) (rightHandSide (nonTerminal DP_1) (nonTerminal Conj) (nonTerminal DP_2))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >) (comment | pass reflexive info\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >) (comment | pass reflexive info\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue initial)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue nonfinalcoordination)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | for AdjP case 14Aug03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DO_contraction)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue gloss)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue or)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue conjoins_DP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | initial DP in coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not initial DP in coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not initial DP in coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | to restrict recursion\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue conjunction) (featurePath (atomicValue gloss))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue gloss)) (closingWedge >) (comment | pass Conj info to DP_2 to correctly restrict Conj possible in recursion\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-final)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | set feature for mother DP\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | set feature for mother DP\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | set feature for mother DP\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person)))) (closingWedge >) (comment | initial DP gives person\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number)))) (closingWedge >) (comment | initial DP gives number\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue human)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue human)))) (closingWedge >) (comment | initial DP gives human\r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pronoun)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pronoun)))) (closingWedge >)) (comment | pronoun from final DP\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue proper)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue proper)))) (closingWedge >)) (comment | proper from final DP\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_head_N)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_head_N)))) (closingWedge >)) (comment | no_head_N from final DP\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue locative)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue locative)))) (closingWedge >) (comment | initial DP gives locative Jan03CB**\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue apposition)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue apposition)))) (closingWedge >) (comment | final DP gives apposition 31Mar03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >) (comment | case determined by\r\n)) (comment | position in sentence\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >) (comment | for apposition 22Jan03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >) (comment | non-final conjunct\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | initial conjuncts unmarked\r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) (comment | final overrules\r\n))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relative)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relcl)) : (featureStructureValue (atomicValue +)) (closingBracket ]) (comment | require rel suffix to only occur when relative clause present\r\n)))))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relative)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relcl)) : (featureStructureValue (atomicValue +)) (closingBracket ]) (comment | require rel suffix to only occur when relative clause present\r\n)))))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) (comment | 24Jul03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue Ior)))))) (patrRule (ruleKW rule) (ruleIdentifier { DP option Iwhether - initial with 'whether' }) (phraseStructureRule (nonTerminal DP) (ruleDef =) (rightHandSide (nonTerminal Conj_1) (nonTerminal DP_1) (nonTerminal Conj) (nonTerminal DP_2))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >) (comment | pass reflexive info\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >) (comment | pass reflexive info\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue initial)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue nonfinalcoordination)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | for AdjP case 14Aug03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DO_contraction)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue gloss)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue whether)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj_1) (featurePath (atomicValue gloss)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue whether)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue conjoins_DP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | initial DP in coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not initial DP in coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not initial DP in coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | to restrict recursion\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue conjunction) (featurePath (atomicValue gloss))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue gloss)) (closingWedge >) (comment | pass Conj info to DP_2 to correctly restrict Conj possible in recursion\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-final)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | set feature for mother DP\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | set feature for mother DP\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | set feature for mother DP\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person)))) (closingWedge >) (comment | initial DP gives person\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number)))) (closingWedge >) (comment | initial DP gives number\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue human)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue human)))) (closingWedge >) (comment | initial DP gives human\r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pronoun)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pronoun)))) (closingWedge >)) (comment | pronoun from final DP\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue proper)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue proper)))) (closingWedge >)) (comment | proper from final DP\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_head_N)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_head_N)))) (closingWedge >)) (comment | no_head_N from final DP\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue locative)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue locative)))) (closingWedge >) (comment | initial DP gives locative Jan03CB**\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue apposition)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue apposition)))) (closingWedge >) (comment | final DP gives apposition 31Mar03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >) (comment | case determined by\r\n)) (comment | position in sentence\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >) (comment | for apposition 22Jan03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >) (comment | non-final conjunct\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | initial conjuncts unmarked\r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) (comment | final overrules\r\n))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relative)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relcl)) : (featureStructureValue (atomicValue +)) (closingBracket ]) (comment | require rel suffix to only occur when relative clause present\r\n)))))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relative)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relcl)) : (featureStructureValue (atomicValue +)) (closingBracket ]) (comment | require rel suffix to only occur when relative clause present\r\n)))))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) (comment | 24Jul03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue Iwhether)))))) (patrRule (ruleKW rule) (ruleIdentifier { DP option Icomma-or - initial with 'comma', 'or' }) (phraseStructureRule (nonTerminal DP) (ruleDef =) (rightHandSide (nonTerminal DP_1) (nonTerminal DP_2))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >) (comment | pass reflexive info\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >) (comment | pass reflexive info\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue initial)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue nonfinalcoordination)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | for AdjP case 14Aug03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DO_contraction)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | initial DP in coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not initial DP in coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not initial DP in coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | to restrict recursion\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue conjunction) (featurePath (atomicValue gloss))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue ending) (comment | pass Conj info to DP_2 to correctly restrict Conj possible in recursion- comma\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-final)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | set feature for mother DP\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | set feature for mother DP\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | set feature for mother DP\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person)))) (closingWedge >) (comment | initial DP gives person\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue human)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue human)))) (closingWedge >) (comment | initial DP gives human\r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pronoun)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pronoun)))) (closingWedge >)) (comment | pronoun from final DP\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue proper)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue proper)))) (closingWedge >)) (comment | proper from final DP\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_head_N)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_head_N)))) (closingWedge >)) (comment | no_head_N from final DP\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue locative)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue locative)))) (closingWedge >) (comment | initial DP gives locative Jan03CB**\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue apposition)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue apposition)))) (closingWedge >) (comment | final DP gives apposition 31Mar03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >) (comment | case determined by\r\n)) (comment | position in sentence\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >) (comment | for apposition 22Jan03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >) (comment | non-final conjunct\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | initial conjuncts unmarked\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue final_conjunction) (featurePath (atomicValue gloss))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue or)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) (comment | final overrules\r\n))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relative)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relcl)) : (featureStructureValue (atomicValue +)) (closingBracket ]) (comment | require rel suffix to only occur when relative clause present\r\n)))))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relative)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relcl)) : (featureStructureValue (atomicValue +)) (closingBracket ]) (comment | require rel suffix to only occur when relative clause present\r\n)))))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) (comment | 24Jul03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue Icomma-or)))))) (patrRule (ruleKW rule) (ruleIdentifier { DP option Icomma-and - initial with 'comma', 'and' }) (phraseStructureRule (nonTerminal DP) (ruleDef =) (rightHandSide (nonTerminal DP_1) (nonTerminal DP_2))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >) (comment | pass reflexive info\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >) (comment | pass reflexive info\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue initial)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue nonfinalcoordination)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | for AdjP case 14Aug03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DO_contraction)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | initial DP in coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not initial DP in coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not initial DP in coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | to restrict recursion\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue conjunction) (featurePath (atomicValue gloss))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue ending) (comment | pass Conj info to DP_2 to correctly restrict Conj possible in recursion - comma\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-final)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | set feature for mother DP\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | set feature for mother DP\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | set feature for mother DP\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person)))) (closingWedge >) (comment | initial DP gives person\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue human)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue human)))) (closingWedge >) (comment | initial DP gives human\r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pronoun)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pronoun)))) (closingWedge >)) (comment | pronoun from final DP\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue proper)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue proper)))) (closingWedge >)) (comment | proper from final DP\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_head_N)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_head_N)))) (closingWedge >)) (comment | no_head_N from final DP\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue locative)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue locative)))) (closingWedge >) (comment | initial DP gives locative Jan03CB**\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue apposition)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue apposition)))) (closingWedge >) (comment | final DP gives apposition 31Mar03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >) (comment | case determined by\r\n)) (comment | position in sentence\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >) (comment | for apposition 22Jan03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >) (comment | non-final conjunct\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | initial conjuncts unmarked\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue final_conjunction) (featurePath (atomicValue gloss))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue and)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number) (featurePath (atomicValue plural))))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | plural comes from 'and'\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number) (featurePath (atomicValue singular))))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue -)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) (comment | final overrules\r\n))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relative)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relcl)) : (featureStructureValue (atomicValue +)) (closingBracket ]) (comment | require rel suffix to only occur when relative clause present\r\n)))))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relative)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relcl)) : (featureStructureValue (atomicValue +)) (closingBracket ]) (comment | require rel suffix to only occur when relative clause present\r\n)))))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) (comment | 24Jul03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue Icomma-and) (comment |-****Coordinate DPs, medial only\r\n)))))) (patrRule (ruleKW rule) (ruleIdentifier { DP option Mand - medial with 'and' }) (phraseStructureRule (nonTerminal DP) (ruleDef =) (rightHandSide (nonTerminal DP_1) (nonTerminal Conj) (nonTerminal DP_2))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >) (comment | pass reflexive info\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >) (comment | pass reflexive info\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue medial)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue nonfinalcoordination)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | for AdjP case 14Aug03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DO_contraction)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-final)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-final)))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue gloss)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue and)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue conjoins_DP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not initial DP in coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not initial DP in coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not initial DP in coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | to restrict recursion\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue conjunction) (featurePath (atomicValue gloss))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue gloss)) (closingWedge >) (comment | require 'and' as upper Conj\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue conjunction) (featurePath (atomicValue gloss))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue gloss)) (closingWedge >) (comment | pass Conj info to DP_2 to correctly restrict Conj possible in recursion\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >) (comment | case determined by\r\n)) (comment | position in sentence\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >) (comment | for apposition 22Jan03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >) (comment | non-final conjunct\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | non-final conjuncts unmarked\r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pronoun)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pronoun)))) (closingWedge >)) (comment | pronoun from final DP\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue proper)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue proper)))) (closingWedge >)) (comment | proper from final DP\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_head_N)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_head_N)))) (closingWedge >)) (comment | no_head_N from final DP\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) (comment | final overrules\r\n))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relative)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relcl)) : (featureStructureValue (atomicValue +)) (closingBracket ]) (comment | require rel suffix to only occur when relative clause present\r\n)))))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relative)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relcl)) : (featureStructureValue (atomicValue +)) (closingBracket ]) (comment | require rel suffix to only occur when relative clause present\r\n)))))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) (comment | 24Jul03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue Mand)))))) (patrRule (ruleKW rule) (ruleIdentifier { DP option Mor - medial with 'or' }) (phraseStructureRule (nonTerminal DP) (ruleDef =) (rightHandSide (nonTerminal DP_1) (nonTerminal Conj) (nonTerminal DP_2))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >) (comment | pass reflexive info\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >) (comment | pass reflexive info\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue medial)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue nonfinalcoordination)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | for AdjP case 14Aug03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DO_contraction)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-final)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-final)))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue gloss)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue or)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue conjoins_DP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not initial DP in coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not initial DP in coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not initial DP in coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | to restrict recursion\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue conjunction) (featurePath (atomicValue gloss))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue gloss)) (closingWedge >) (comment | require 'or' as upper Conj\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue conjunction) (featurePath (atomicValue gloss))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue gloss)) (closingWedge >) (comment | pass Conj info to DP_2 to correctly restrict Conj possible in recursion\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >) (comment | case determined by\r\n)) (comment | position in sentence\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >) (comment | for apposition 22Jan03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >) (comment | non-final conjunct\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | non-final conjuncts unmarked\r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pronoun)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pronoun)))) (closingWedge >)) (comment | pronoun from final DP\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue proper)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue proper)))) (closingWedge >)) (comment | proper from final DP\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_head_N)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_head_N)))) (closingWedge >)) (comment | no_head_N from final DP\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) (comment | final overrules\r\n))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relative)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relcl)) : (featureStructureValue (atomicValue +)) (closingBracket ]) (comment | require rel suffix to only occur when relative clause present\r\n)))))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relative)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relcl)) : (featureStructureValue (atomicValue +)) (closingBracket ]) (comment | require rel suffix to only occur when relative clause present\r\n)))))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) (comment | 24Jul03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue Mor)))))) (patrRule (ruleKW rule) (ruleIdentifier { DP option Mwhether - medial with 'whether' }) (phraseStructureRule (nonTerminal DP) (ruleDef =) (rightHandSide (nonTerminal DP_1) (nonTerminal Conj) (nonTerminal DP_2))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >) (comment | pass reflexive info\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >) (comment | pass reflexive info\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue medial)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue nonfinalcoordination)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | for AdjP case 14Aug03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DO_contraction)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-final)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-final)))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue gloss)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue whether)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue conjoins_DP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not initial in coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not initial DP in coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not initial DP in coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | to restrict recursion\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | to require further recursion \r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue conjunction) (featurePath (atomicValue gloss))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue gloss)) (closingWedge >) (comment | require 'whether' as upper Conj\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue conjunction) (featurePath (atomicValue gloss))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue gloss)) (closingWedge >) (comment | pass Conj info to DP_2 to correctly restrict Conj possible in recursion\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >) (comment | case determined by\r\n)) (comment | position in sentence\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >) (comment | for apposition 22Jan03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >) (comment | non-final conjunct\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | non-final conjuncts unmarked\r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pronoun)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pronoun)))) (closingWedge >)) (comment | pronoun from final DP\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue proper)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue proper)))) (closingWedge >)) (comment | proper from final DP\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_head_N)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_head_N)))) (closingWedge >)) (comment | no_head_N from final DP\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) (comment |final overrules\r\n))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relative)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relcl)) : (featureStructureValue (atomicValue +)) (closingBracket ]) (comment | require rel suffix to only occur when relative clause present\r\n)))))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relative)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relcl)) : (featureStructureValue (atomicValue +)) (closingBracket ]) (comment | require rel suffix to only occur when relative clause present\r\n)))))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) (comment | 24Jul03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue Mwhether)))))) (patrRule (ruleKW rule) (ruleIdentifier { DP option Mcomma - medial with 'comma' }) (phraseStructureRule (nonTerminal DP) (ruleDef =) (rightHandSide (nonTerminal DP_1) (nonTerminal DP_2))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >) (comment | pass reflexive info\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >) (comment | pass reflexive info\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue medial)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue nonfinalcoordination)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | for AdjP case 14Aug03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DO_contraction)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-final)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-final)))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not initial in coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not initial DP in coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not initial DP in coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | to restrict recursion\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | to require further recursion \r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue conjunction) (featurePath (atomicValue gloss))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue ending) (comment | require 'comma' as upper Conj\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue conjunction) (featurePath (atomicValue gloss))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue ending) (comment | pass Conj info to DP_2 to correctly restrict Conj possible in recursion - comma\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue final_conjunction) (featurePath (atomicValue gloss))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue final_conjunction) (featurePath (atomicValue gloss))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >) (comment | case determined by\r\n)) (comment | position in sentence\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >) (comment | for apposition 22Jan03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >) (comment | non-final conjunct\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | non-final conjuncts unmarked\r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pronoun)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pronoun)))) (closingWedge >)) (comment | pronoun from final DP\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue proper)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue proper)))) (closingWedge >)) (comment | proper from final DP\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_head_N)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_head_N)))) (closingWedge >)) (comment | no_head_N from final DP\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) (comment |final overrules\r\n))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relative)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relcl)) : (featureStructureValue (atomicValue +)) (closingBracket ]) (comment | require rel suffix to only occur when relative clause present\r\n)))))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relative)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relcl)) : (featureStructureValue (atomicValue +)) (closingBracket ]) (comment | require rel suffix to only occur when relative clause present\r\n)))))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) (comment | 24Jul03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue Mcomma) (comment |-****Coordinate DPs, final only\r\n)))))) (patrRule (ruleKW rule) (ruleIdentifier { DP option Fandor - final with 'and or' }) (phraseStructureRule (nonTerminal DP) (ruleDef =) (rightHandSide (nonTerminal DP_1) (nonTerminal Conj) (nonTerminal Conj_1) (nonTerminal DP_2))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >) (comment | pass reflexive info\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >) (comment | pass reflexive info\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue nonfinalcoordination)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | for AdjP case 14Aug03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue nonfinalcoordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | for AdjP case 14Aug03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DO_contraction)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-final)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-final)))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue gloss)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue and)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj_1) (featurePath (atomicValue gloss)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue or)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue conjoins_DP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue conjoins_DP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not initial in coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not initial DP in coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not initial DP in coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | to restrict recursion\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | to stop further recursion\r\n)))) (constraint (unificationConstraint (disjunctiveUnificationConstraint { (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue conjunction) (featurePath (atomicValue gloss))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue and))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue conjunction) (featurePath (atomicValue gloss))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue or) (comment | require 'and' or 'or' as upper Conj\r\n)))) }))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pronoun)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pronoun)))) (closingWedge >)) (comment | pronoun from final DP\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue proper)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue proper)))) (closingWedge >)) (comment | proper from final DP\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_head_N)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_head_N)))) (closingWedge >)) (comment | no_head_N from final DP\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue apposition)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue apposition)))) (closingWedge >) (comment | final DP gives apposition 31Mar03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue locative)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue locative)))) (closingWedge >) (comment | final DP gives locative Jan03CB**\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >) (comment | case determined by\r\n)) (comment | position in sentence\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >) (comment | for apposition 22Jan03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | initial conjuncts unmarked\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >) (comment | final conjuncts have case\r\n)))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relative)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relcl)) : (featureStructureValue (atomicValue +)) (closingBracket ]) (comment | require rel suffix to only occur when relative clause present\r\n)))))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relative)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relcl)) : (featureStructureValue (atomicValue +)) (closingBracket ]) (comment | require rel suffix to only occur when relative clause present\r\n)))))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) (comment | 24Jul03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue Fandor)))))) (patrRule (ruleKW rule) (ruleIdentifier { DP option Fandwhether - final with 'and whether' }) (phraseStructureRule (nonTerminal DP) (ruleDef =) (rightHandSide (nonTerminal DP_1) (nonTerminal Conj) (nonTerminal Conj_1) (nonTerminal DP_2))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >) (comment | pass reflexive info\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >) (comment | pass reflexive info\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue nonfinalcoordination)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | for AdjP case 14Aug03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue nonfinalcoordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | for AdjP case 14Aug03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DO_contraction)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-final)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-final)))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue gloss)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue and)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj_1) (featurePath (atomicValue gloss)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue whether)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue conjoins_DP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue conjoins_DP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not initial in coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not initial DP in coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not initial DP in coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | to restrict recursion\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | to stop further recursion\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue conjunction) (featurePath (atomicValue gloss))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal Conj_1) (featurePath (atomicValue gloss)) (closingWedge >) (comment | require 'whether' as upper Conj\r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pronoun)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pronoun)))) (closingWedge >)) (comment | pronoun from final DP\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue proper)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue proper)))) (closingWedge >)) (comment | proper from final DP\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_head_N)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_head_N)))) (closingWedge >)) (comment | no_head_N from final DP\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue apposition)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue apposition)))) (closingWedge >) (comment | final DP gives apposition 31Mar03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue locative)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue locative)))) (closingWedge >) (comment | final DP gives locative Jan03CB**\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >) (comment | case determined by\r\n)) (comment | position in sentence\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >) (comment | for apposition 22Jan03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | initial conjuncts unmarked\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >) (comment | final conjuncts have case\r\n)))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relative)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relcl)) : (featureStructureValue (atomicValue +)) (closingBracket ]) (comment | require rel suffix to only occur when relative clause present\r\n)))))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relative)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relcl)) : (featureStructureValue (atomicValue +)) (closingBracket ]) (comment | require rel suffix to only occur when relative clause present\r\n)))))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) (comment | 24Jul03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue Fandwhether)))))) (patrRule (ruleKW rule) (ruleIdentifier { DP option Fandalso - final with 'and also' }) (phraseStructureRule (nonTerminal DP) (ruleDef =) (rightHandSide (nonTerminal DP_1) (nonTerminal Conj) (nonTerminal Conj_1) (nonTerminal DP_2))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >) (comment | pass reflexive info\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >) (comment | pass reflexive info\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue nonfinalcoordination)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | for Adj case info 14Aug03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue nonfinalcoordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | for AdjP case 14Aug03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DO_contraction)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-final)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-final)))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue gloss)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue and)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj_1) (featurePath (atomicValue gloss)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue also)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue conjoins_DP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue conjoins_DP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not initial in coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not initial DP in coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not initial DP in coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | to restrict recursion\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | to stop further recursion\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue final_conjunction) (featurePath (atomicValue gloss))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue and) (comment | pass info for plural agreement\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue conjunction) (featurePath (atomicValue gloss))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue ending) (comment | require comma as upper Conj\r\n)) (comment ||    <DP conjunction gloss> = <Conj gloss>  | require 'and' as upper Conj\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pronoun)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pronoun)))) (closingWedge >)) (comment | pronoun from final DP\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue proper)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue proper)))) (closingWedge >)) (comment | proper from final DP\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_head_N)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_head_N)))) (closingWedge >)) (comment | no_head_N from final DP\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue apposition)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue apposition)))) (closingWedge >) (comment | final DP gives apposition 31Mar03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue locative)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue locative)))) (closingWedge >) (comment | final DP gives locative Jan03CB**\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >) (comment | case determined by\r\n)) (comment | position in sentence\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >) (comment | for apposition 22Jan03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | initial conjuncts unmarked\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >) (comment | final conjuncts have case\r\n)))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relative)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relcl)) : (featureStructureValue (atomicValue +)) (closingBracket ]) (comment | require rel suffix to only occur when relative clause present\r\n)))))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relative)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relcl)) : (featureStructureValue (atomicValue +)) (closingBracket ]) (comment | require rel suffix to only occur when relative clause present\r\n)))))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) (comment | 24Jul03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue Fandalso)))))) (patrRule (ruleKW rule) (ruleIdentifier { DP option Fand - final with 'and' }) (phraseStructureRule (nonTerminal DP) (ruleDef =) (rightHandSide (nonTerminal DP_1) (nonTerminal Conj) (nonTerminal DP_2))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >) (comment | pass reflexive info\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >) (comment | pass reflexive info\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue nonfinalcoordination)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | for AdjP case 14Aug03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue nonfinalcoordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | for AdjP case 14Aug03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DO_contraction)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-final)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-final)))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue gloss)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue and)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue conjoins_DP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not initial in coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not initial DP in coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not initial DP in coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | to restrict recursion\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | to stop further recursion\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue final_conjunction) (featurePath (atomicValue gloss))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue and) (comment | pass info for plural agreement\r\n)))) (constraint (unificationConstraint (disjunctiveUnificationConstraint { (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue conjunction) (featurePath (atomicValue gloss))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue ending) (comment | require comma as upper Conj\r\n))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue conjunction) (featurePath (atomicValue gloss))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue and) (comment | require 'and' as upper Conj\r\n)))) }))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pronoun)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pronoun)))) (closingWedge >)) (comment | pronoun from final DP\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue proper)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue proper)))) (closingWedge >)) (comment | proper from final DP\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_head_N)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_head_N)))) (closingWedge >)) (comment | no_head_N from final DP\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue apposition)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue apposition)))) (closingWedge >) (comment | final DP gives apposition 31Mar03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue locative)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue locative)))) (closingWedge >) (comment | final DP gives locative Jan03CB**\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >) (comment | case determined by\r\n)) (comment | position in sentence\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >) (comment | for apposition 22Jan03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | initial conjuncts unmarked\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >) (comment | final conjuncts have case\r\n)))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relative)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relcl)) : (featureStructureValue (atomicValue +)) (closingBracket ]) (comment | require rel suffix to only occur when relative clause present\r\n)))))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relative)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relcl)) : (featureStructureValue (atomicValue +)) (closingBracket ]) (comment | require rel suffix to only occur when relative clause present\r\n)))))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) (comment | 24Jul03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue Fand)))))) (patrRule (ruleKW rule) (ruleIdentifier { DP option For - final with 'or' }) (phraseStructureRule (nonTerminal DP) (ruleDef =) (rightHandSide (nonTerminal DP_1) (nonTerminal Conj) (nonTerminal DP_2))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >) (comment | pass reflexive info\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >) (comment | pass reflexive info\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue nonfinalcoordination)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | for AdjP case 14Aug03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue nonfinalcoordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | for AdjP case 14Aug03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DO_contraction)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-final)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-final)))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue gloss)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue or)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue conjoins_DP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not initial in coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not initial DP in coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not initial DP in coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | to restrict recursion\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | to stop further recursion\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue final_conjunction) (featurePath (atomicValue gloss))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue or) (comment | pass info for non-plural agreement\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue conjunction) (featurePath (atomicValue gloss))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue ending) (comment | require comma as upper Conj\r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pronoun)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pronoun)))) (closingWedge >)) (comment | pronoun from final DP\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue proper)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue proper)))) (closingWedge >)) (comment | proper from final DP\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_head_N)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_head_N)))) (closingWedge >)) (comment | no_head_N from final DP\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue apposition)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue apposition)))) (closingWedge >) (comment | final DP gives apposition 31Mar03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue locative)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue locative)))) (closingWedge >) (comment | final DP gives locative Jan03CB**\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >) (comment | case determined by\r\n)) (comment | position in sentence\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >) (comment | for apposition 22Jan03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | initial conjuncts unmarked\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >) (comment | final conjuncts have case\r\n)))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relative)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relcl)) : (featureStructureValue (atomicValue +)) (closingBracket ]) (comment | require rel suffix to only occur when relative clause present\r\n)))))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relative)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relcl)) : (featureStructureValue (atomicValue +)) (closingBracket ]) (comment | require rel suffix to only occur when relative clause present\r\n)))))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) (comment | 24Jul03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue For) (comment |-*****\r\n)))))) (patrRule (ruleKW rule) (ruleIdentifier { DP option casePst - case-marked DP }) (phraseStructureRule (nonTerminal DP) (ruleDef =) (rightHandSide (nonTerminal DP_1) (nonTerminal Case))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue conjoined)) (closingWedge >) (comment | pass up info one level\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue mother_node)) (closingWedge >) (comment | pass up info one level\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue tense) (featurePath (atomicValue past))))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue third))))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | third person only Feb2020\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue apposition)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | to prevent double case marking\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DO_contraction)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | to know normal case in apposition 20Jan03 CB  \r\n)))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (closingWedge >)) == (logConstraintExpression ~ (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue mother_node)) : (featureStructureValue (atomicValue -)) (closingBracket ]) (comment | if coordination, must be allowed initially\r\n)))))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue mother_node)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue type)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue coordination)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (closingBracket ]))) (closingBracket ]) (comment |and be complete\r\n)))))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal Case) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | now case-marked\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue -)) (comment | can't compound if case-marked\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | redo case  to = CB 23May19 \r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue casePst)))))) (patrRule (ruleKW rule) (ruleIdentifier { DP option caseNonPstExceptDef - case-marked DP }) (phraseStructureRule (nonTerminal DP) (ruleDef =) (rightHandSide (nonTerminal DP_1) (nonTerminal Case))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue conjoined)) (closingWedge >) (comment | pass up info one level\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue mother_node)) (closingWedge >) (comment | pass up info one level\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue tense) (featurePath (atomicValue past))))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue third))))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | third person only Feb2020\r\n)))) (constraint (unificationConstraint (disjunctiveUnificationConstraint { (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue indefinite)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue generic)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) }))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue apposition)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | to prevent double case marking\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DO_contraction)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | to know normal case in apposition 20Jan03 CB  \r\n)))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (closingWedge >)) == (logConstraintExpression ~ (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue mother_node)) : (featureStructureValue (atomicValue -)) (closingBracket ]) (comment | if coordination, must be allowed initially\r\n)))))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue mother_node)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue type)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue coordination)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (closingBracket ]))) (closingBracket ]) (comment |and be complete\r\n)))))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal Case) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | now case-marked\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue -)) (comment | can't compound if case-marked\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | redo case to = CB 23May19 \r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue caseNonPstExceptDef)))))) (patrRule (ruleKW rule) (ruleIdentifier { DP option caseNonPstDef - case-marked DP }) (phraseStructureRule (nonTerminal DP) (ruleDef =) (rightHandSide (nonTerminal DP_1) (nonTerminal Case))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue conjoined)) (closingWedge >) (comment | pass up info one level\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue mother_node)) (closingWedge >) (comment | pass up info one level\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue tense) (featurePath (atomicValue past))))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue third))))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | third person only Feb2020\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue indefinite)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue apposition)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | to prevent double case marking\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DO_contraction)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue oblique) (comment | to know normal case in apposition 20Jan03 CB  \r\n)))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (closingWedge >)) == (logConstraintExpression ~ (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue mother_node)) : (featureStructureValue (atomicValue -)) (closingBracket ]) (comment | if coordination, must be allowed initially\r\n)))))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue mother_node)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue type)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue coordination)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (closingBracket ]))) (closingBracket ]) (comment |and be complete\r\n)))))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal Case) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | now case-marked\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue -)) (comment | can't compound if case-marked\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue oblique) (comment | redo case to = CB 23May19 \r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue caseNonPstDef)))))) (patrRule (ruleKW rule) (ruleIdentifier { DP option case1and2pronouns - case-marked DP }) (phraseStructureRule (nonTerminal DP) (ruleDef =) (rightHandSide (nonTerminal DP_1) (nonTerminal Case))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue conjoined)) (closingWedge >) (comment | pass up info one level\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue mother_node)) (closingWedge >) (comment | pass up info one level\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue tense) (featurePath (atomicValue past))))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue person) (featurePath (atomicValue third))))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 1st and 2nd person only Feb2020\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pronoun)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | 1st and 2nd person pron only Feb2020\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue indefinite)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue apposition)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | to prevent double case marking\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DO_contraction)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue objective) (comment | to know normal case in apposition 20Jan03 CB \r\n)))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (closingWedge >)) == (logConstraintExpression ~ (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue mother_node)) : (featureStructureValue (atomicValue -)) (closingBracket ]) (comment | if coordination, must be allowed initially\r\n)))))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue mother_node)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue type)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue coordination)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (closingBracket ]))) (closingBracket ]) (comment |and be complete\r\n)))))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal Case) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | now case-marked\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue -)) (comment | can't compound if case-marked\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue objective) (comment | redo case to = CB 23May19 \r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue case1and2pronouns)))))) (patrRule (ruleKW rule) (ruleIdentifier { DP option caseAppos - case-marked DP including apposition }) (phraseStructureRule (nonTerminal DP) (ruleDef =) (rightHandSide (nonTerminal DP_1) (nonTerminal Case))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (disjunctiveUnificationConstraint { (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue apposition)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | 17Jan03  CB\r\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue apposition)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue namely) (comment | 21Nov03 CB\r\n)))) }))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | to prevent double case marking\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DO_contraction)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | to know normal case in apposition 20Jan03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | changed from case from Case 17Feb03 CB\r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | now case-marked\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue -)) (comment | can't compound if case-marked\r\n))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (closingWedge >)) == (logConstraintExpression ~ (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue conjoined)) : (featureStructureValue (atomicValue +)) (closingBracket ]) (comment | apposition only, not coordination\r\n)))))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue caseAppos) (comment | 16Jan03 RL Added this rule, moved to DP level 20Jan03 CB, split into 2 rules to avoid duplicate parses due to options in DP_2 when have PP instead 27Jan03 CB\r\n)))))) (patrRule (ruleKW rule) (ruleIdentifier { DP option Appos - Apposition, commas required } |e.g. John, the butcher, came.\r\n DP = DP_1 DP_2 < DP head > = < DP_1 head > | 27Jan03CB\r\n < DP_1 head agr > = < DP_2 head agr > | person and number agreement\r\n < DP head apposed > = < DP_2 > | pass up info for generic/refl 19Feb03 CB Name of feature changed Apr 2020CB\r\n < DP_1 head type comma > = + < DP_2 head type comma > = + < DP_2 head type apposition > = - | allow stacking only one way 20Jan03 CB\r\n < DP_1 head type case-marked > = - | case-marked above apposition only 20Jan03 CB\r\n < DP_2 head type case-marked > = - | case-marked above apposition only 20Jan03 CB\r\n < DP_1 head type relative > = - | N cannot have REL with following modifier\r\n < DP_2 head type DO_contraction > = - | DO_contraction use 1contr rule\r\n |    <DP_2 head type coordination> = -   | not allowing coordinate apposition |removed 18Mar03 CB\r\n < DP head case_for_position > = < DP_1 head case_for_position > | pass down in case of iteration 27Jan03 CB\r\n < DP_1 head case > = < DP head case_for_position > < DP_2 head case > = < DP head case_for_position > < DP_2 head infl polarity > = + | Apposition phrase is not negative\r\n < DP_1 > == ~ [ mother_node : - ] | if coordination, must be allowed initially\r\n < DP_1 > == [ mother_node : + ] -> [ head : [ type : [ coordination : + ] ] ] |and be complete\r\n < DP_2 > == ~ [ mother_node : - ] | if coordination, must be allowed initially\r\n < DP_2 > == [ mother_node : + ] -> [ head : [ type : [ coordination : + ] ] ] |and be complete\r\n < DP head reflexive > = < DP_2 head reflexive > | pass reflexive info\r\n < DP head type compound > <= < DP_2 head type compound > | 04 Apr03 CB\r\n < DP head type apposition > <= + | 17Jan03 CB\r\n < DP rule > = Appos | generic/ref pn cannot be checked inside PP apposition\r\n rule { DP option PPAppos - Apposition with PP, commas required }) (phraseStructureRule (nonTerminal DP) (ruleDef =) (rightHandSide (nonTerminal DP_1) (nonTerminal PP))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head)) (closingWedge >) (comment | 27Jan03CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal PP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | case-marked above apposition only 20Jan03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | N cannot have REL with following modifier\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >) (comment | pass down in case of iteration 27Jan03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal PP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue sentential)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal PP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >) (comment | pass reflexive info\r\n)))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (closingWedge >)) == (logConstraintExpression ~ (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue mother_node)) : (featureStructureValue (atomicValue -)) (closingBracket ]) (comment | if coordination, must be allowed initially\r\n)))))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue mother_node)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue type)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue coordination)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (closingBracket ]))) (closingBracket ]) (comment |and be complete\r\n)))))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal PP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) (comment | 04 Apr03 CB\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue apposition)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | 17Jan03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue PPAppos) (comment | for ygny type apposition/coordination/relativization, added 24Mar03 CB\r\n)))))) (patrRule (ruleKW rule) (ruleIdentifier { DP option namely - "ygny"-type apposition }) (phraseStructureRule (nonTerminal DP) (ruleDef =) (rightHandSide (nonTerminal DP_1) (nonTerminal Conj) (nonTerminal DP_2))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >) (comment | assume same case marking - Ron?? \r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue gloss)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue namely)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | no coordination above ygny  changed from "= namely" Apr2020\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue conjunction) (featurePath (atomicValue gloss))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue namely) (comment | to restrict interaction w/ coordination\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue reflexive))) (closingWedge >) (comment | pass reflexive info\r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue apposition)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue namely)) (comment | 21Nov03 CB\r\n))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relative)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relcl)) : (featureStructureValue (atomicValue +)) (closingBracket ]) (comment | require rel suffix to only occur when relative clause present\r\n)))))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP_2) (featurePath (atomicValue head) (featurePath (atomicValue type))) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relative)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue relcl)) : (featureStructureValue (atomicValue +)) (closingBracket ]) (comment | require rel suffix to only occur when relative clause present\r\n)))))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue namely)))))) (patrRule (ruleKW rule) (ruleIdentifier { DP option relative_clause }) (phraseStructureRule (nonTerminal DP) (ruleDef =) (rightHandSide (nonTerminal DP_1) (nonTerminal CP))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal CP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue root)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal CP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue question)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal CP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue conj_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 03Apr03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal CP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | 21Nov03 CB\r\n)) (comment |    <DP_1 conjoined> = -             | not conjoined head 21Apr03 CB\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal CP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (closingWedge >)) == (logConstraintExpression ~ (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue conjoined)) : (featureStructureValue (atomicValue +)) (closingBracket ]) (comment | not cojoined head\r\n)))))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue relative_clause) (comment |rule added 28Jan03 CB\r\n)))))) (patrRule (ruleKW rule) (ruleIdentifier { DP option relcl2 - relative clause with no rel suffix, head by Pron, PropN, Dem, Deg, QP, or phrases }) (phraseStructureRule (nonTerminal DP) (ruleDef =) (rightHandSide (nonTerminal DP_1) (nonTerminal CP))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | rel suffix not required\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue indefinite)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | (but can't be indefinite instead)\r\n)))) (constraint (unificationConstraint (disjunctiveUnificationConstraint { (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | if conjoined head \r\n))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | must be mother-node\r\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue mother_node)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) }))) (constraint (unificationConstraint (disjunctiveUnificationConstraint { (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue proper)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | for proper noun heads\r\n))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pronoun)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | or pronoun heads\r\n)))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue suffix_Pn)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | or with suffix Pn **24Jul06 CB\r\n)))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_head_N)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | or Dem, Deg or QP heads\r\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pronoun)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_head_N)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | or phrases w/ final modifiers\r\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pronoun)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-final)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_head_N)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | or phrases w/ initial modifiers\r\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pronoun)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-final)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_head_N)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | or phrases w/ modifiers both sides\r\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue pronoun)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-final)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) }))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal CP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue root)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal CP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue question)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal CP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue conj_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 03Apr03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal CP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | 21Nov03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal CP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue relcl2) (comment |rule added 7Apr03 CB\r\n)))))) (patrRule (ruleKW rule) (ruleIdentifier { DP option relcl2+kh - relative clause with no rel suffix, with +kh suffixed to head }) (phraseStructureRule (nonTerminal DP) (ruleDef =) (rightHandSide (nonTerminal DP_1) (nonTerminal IP))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comp_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue root)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue question)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue conj_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | 03Apr03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue initialP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | no InitP allowed in IP 21Apr03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | 21Nov03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >) (comment |    <DP_1 conjoined> = -\r\n)) (comment |    {<DP_1 conjoined> = -             | if conjoined head     ***asking Ron\r\n))) (constraint (comment |    /<DP_1 conjoined> = +             | must be mother-node\r\n)) (constraint (comment |     <DP_1 mother_node> = +\r\n)) (constraint (comment |    }\r\n)) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue relativeCl)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (featurePath (atomicValue relativeCl)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not iterative 03Jun03 CB\r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue relativity) (featurePath (atomicValue conjoined)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue conjoined)))) (closingWedge >) (comment | for compounding constraints with main V 20Oct03 CB\r\n)) (comment |?|    <DP head relativity compounds_with1> = <IP head type final-conjunct compounds_with1>\r\n))) (constraint (comment |?|    <DP head relativity compounds_with2> = <IP head type final-conjunct compounds_with2>\r\n)) (constraint (comment |?|    <DP head relativity compounds_with3> = <IP head type final-conjunct compounds_with3>\r\n)) (constraint (comment |?|    <DP head relativity compounds_with4> = <IP head type final-conjunct compounds_with4>\r\n)) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal DP_1) (closingWedge >)) == (logConstraintExpression ~ (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue conjoined)) : (featureStructureValue (atomicValue +)) (closingBracket ]) (comment | not conjoined head\r\n)))))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue relcl2+kh)))))) (patrRule (ruleKW rule) (ruleIdentifier { DP option 1 - no modifiers }) (phraseStructureRule (nonTerminal DP) (ruleDef =) (rightHandSide (nonTerminal D'))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal D') (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 1)))))) (patrRule (ruleKW rule) (ruleIdentifier { DP option 1conjI - no modifiers, Conj initial }) (phraseStructureRule (nonTerminal DP) (ruleDef =) (rightHandSide (nonTerminal Conj) (nonTerminal D'))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal D') (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not in DP coordination construction\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue initialP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | restrict conjunctions here and in DP \r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue gloss)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue also)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 1conjI)))))) (patrRule (ruleKW rule) (ruleIdentifier { DP option 1conjIF - no modifiers, Conj initial, final }) (phraseStructureRule (nonTerminal DP) (ruleDef =) (rightHandSide (nonTerminal Conj) (nonTerminal D') (nonTerminal Conj_2))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal D') (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not in DP coordination construction\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue initialP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | restrict conjunctions here and in DP \r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal D') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal D') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue gloss)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue also)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP-final)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal Conj_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal Conj_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue -)) (comment | 04 Apr03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 1conjIF)))))) (patrRule (ruleKW rule) (ruleIdentifier { DP option 1conjF - no modifiers, Conj final }) (phraseStructureRule (nonTerminal DP) (ruleDef =) (rightHandSide (nonTerminal D') (nonTerminal Conj))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal D') (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal D') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal D') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not in DP coordination construction\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue initialP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | restrict conjunctions here and in DP \r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP-final)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue -)) (comment | 04 Apr03 CB\r\n))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (closingWedge >)) == (logConstraintExpression ~ (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue gloss)) : (featureStructureValue (atomicValue namely)) (closingBracket ])))))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 1conjF)))))) (patrRule (ruleKW rule) (ruleIdentifier { DP option 2a - modifiers initial }) (phraseStructureRule (nonTerminal DP) (ruleDef =) (rightHandSide (nonTerminal Deg_1) (optionalTerminals ( (nonTerminal Deg) )) (nonTerminal D'))) (comment | Deg_1 is the negative particle "na", Deg is "alone"\r\n) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal D') (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifies_NP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifies_NP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg_1) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue polarity)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue polarity)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (disjunctiveUnificationConstraint { (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | initial modifiers not case-marked\r\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue gen_initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue genitive) (comment | unless can take genitive initially\r\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue gen_initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | 7Apr03 CB\r\n)))) }))) (constraint (unificationConstraint (disjunctiveUnificationConstraint { (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg_1) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | initial modifiers not case-marked\r\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue gen_initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg_1) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue genitive) (comment | unless can take genitive initially\r\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue gen_initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | 7Apr03 CB\r\n)))) }))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue polarity)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal Deg_1) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue polarity)))) (closingWedge >)) (comment | negative comes from Deg\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 2a)))))) (patrRule (ruleKW rule) (ruleIdentifier { DP option 2aconjI - modifiers initial, Conj initial }) (phraseStructureRule (nonTerminal DP) (ruleDef =) (rightHandSide (nonTerminal Conj) (nonTerminal Deg_1) (optionalTerminals ( (nonTerminal Deg) )) (nonTerminal D'))) (comment | Deg_1 is the negative particle "na", Deg is "alone"\r\n) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal D') (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifies_NP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifies_NP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg_1) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue polarity)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue polarity)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (disjunctiveUnificationConstraint { (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | initial modifiers not case-marked\r\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue gen_initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue genitive) (comment | unless can take genitive initially\r\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue gen_initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | 7Apr03 CB\r\n)))) }))) (constraint (unificationConstraint (disjunctiveUnificationConstraint { (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg_1) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | initial modifiers not case-marked\r\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue gen_initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg_1) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue genitive) (comment | unless can take genitive initially\r\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue gen_initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | 7Apr03 CB\r\n)))) }))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not in DP coordination construction\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue initialP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | restrict conjunctions here and in DP \r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue gloss)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue also)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue polarity)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal Deg_1) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue polarity)))) (closingWedge >)) (comment | negative comes from Deg\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 2aconjI)))))) (patrRule (ruleKW rule) (ruleIdentifier { DP option 2aconjIF - modifiers initial, Conj initial, final }) (phraseStructureRule (nonTerminal DP) (ruleDef =) (rightHandSide (nonTerminal Conj) (nonTerminal Deg_1) (optionalTerminals ( (nonTerminal Deg) )) (nonTerminal D') (nonTerminal Conj_2))) (comment | Deg_1 is the negative "na", Deg is "alone"\r\n) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal D') (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal D') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal D') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifies_NP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifies_NP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg_1) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue polarity)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue polarity)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (disjunctiveUnificationConstraint { (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | initial modifiers not case-marked\r\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue gen_initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue genitive) (comment | unless can take genitive initially\r\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue gen_initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | 7Apr03 CB\r\n)))) }))) (constraint (unificationConstraint (disjunctiveUnificationConstraint { (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg_1) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | initial modifiers not case-marked\r\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue gen_initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg_1) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue genitive) (comment | unless can take genitive initially\r\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue gen_initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | 7Apr03 CB\r\n)))) }))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not in DP coordination construction\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue initialP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | restrict conjunctions here and in DP \r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue gloss)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue also)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP-final)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue polarity)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal Deg_1) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue polarity)))) (closingWedge >)) (comment | negative comes from Deg\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal Conj_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal Conj_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue -)) (comment | 04 Apr03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 2aconjIF)))))) (patrRule (ruleKW rule) (ruleIdentifier { DP option 2aconjF - modifiers initial, Conj final }) (phraseStructureRule (nonTerminal DP) (ruleDef =) (rightHandSide (nonTerminal Deg_1) (optionalTerminals ( (nonTerminal Deg) )) (nonTerminal D') (nonTerminal Conj))) (comment | Deg_1 is the negative particle "na", Deg is "alone"\r\n) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal D') (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal D') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal D') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifies_NP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifies_NP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg_1) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue polarity)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue polarity)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (disjunctiveUnificationConstraint { (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | initial modifiers not case-marked\r\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue gen_initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue genitive) (comment | unless can take genitive initially\r\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue gen_initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | 7Apr03 CB\r\n)))) }))) (constraint (unificationConstraint (disjunctiveUnificationConstraint { (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg_1) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | initial modifiers not case-marked\r\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue gen_initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg_1) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue genitive) (comment | unless can take genitive initially\r\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue gen_initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | 7Apr03 CB\r\n)))) }))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not in DP coordination construction\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue initialP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | restrict conjunctions here and in DP \r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP-final)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue polarity)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal Deg_1) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue polarity)))) (closingWedge >)) (comment | negative comes from Deg\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue -)) (comment | 04 Apr03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 2aconjF)))))) (patrRule (ruleKW rule) (ruleIdentifier { DP option 2b - modifier initial }) (phraseStructureRule (nonTerminal DP) (ruleDef =) (rightHandSide (nonTerminal Deg) (nonTerminal D'))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal D') (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifies_NP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment |    /<Deg head type modifies_NPrep> = +  | added for drst byrwn... 10Jul03 CB\r\n)) (comment |     <D' head case> = genitive           | removed for Ability 18 Mar2020\r\n))) (constraint (comment |    }\r\n)) (constraint (comment |    <Deg head agr number plural> = -   |commented off to combine rules **19Jul06 CB\r\n)) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | initial modifiers not case-marked\r\n)) (comment |     <Deg head type gen_initial> = -\r\n))) (constraint (comment |    /<Deg head case> = genitive       | unless can take genitive initially\r\n)) (constraint (comment |     <Deg head type gen_initial> = +    | 7Apr03 CB\r\n)) (constraint (comment |    }\r\n)) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue polarity)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 2b) (comment |Combined this rule with option 2b above since plurality does not come from Deg **19Jul06 CB\r\n)) (comment |rule {DP option 2bpl - modifier initial - plural}\r\n))) (constraint (comment |DP = Deg D'\r\n)) (constraint (comment |    <DP head> = <D' head>\r\n)) (constraint (comment |    <Deg head type comma> = -\r\n)) (constraint (comment |    <Deg head type modifies_NP> = +\r\n)) (constraint (comment |    <Deg head agr number plural> = +\r\n)) (constraint (comment |    {<Deg head case> = direct     | initial modifiers not case-marked\r\n)) (constraint (comment |     <Deg head type gen_initial> = -\r\n)) (constraint (comment |    /<Deg head case> = genitive       | unless can take genitive initially\r\n)) (constraint (comment |     <Deg head type gen_initial> = +    | 7Apr03 CB\r\n)) (constraint (comment |    }\r\n)) (constraint (comment |    <DP head type case-marked> = -\r\n)) (constraint (comment |    <DP conjoined> = -\r\n)) (constraint (comment |    <Deg head infl polarity> = +\r\n)) (constraint (comment |    <DP head agr number> <= <Deg head agr number>  | plurality comes from Deg\r\n)) (constraint (comment |    <DP rule> = 2bpl\r\n)))) (patrRule (ruleKW rule) (ruleIdentifier { DP option 2bconjI - modifier initial, Conj initial }) (phraseStructureRule (nonTerminal DP) (ruleDef =) (rightHandSide (nonTerminal Conj) (nonTerminal Deg) (nonTerminal D'))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal D') (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifies_NP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number) (featurePath (atomicValue plural))))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (disjunctiveUnificationConstraint { (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | initial modifiers not case-marked\r\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue gen_initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue genitive) (comment | unless can take genitive initially\r\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue gen_initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | 7Apr03 CB\r\n)))) }))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not in DP coordination construction\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue initialP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | restrict conjunctions here and in DP \r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue gloss)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue also)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue polarity)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 2bconjI)))))) (patrRule (ruleKW rule) (ruleIdentifier { DP option 2bconjIpl - plural modifier initial, Conj initial }) (phraseStructureRule (nonTerminal DP) (ruleDef =) (rightHandSide (nonTerminal Conj) (nonTerminal Deg) (nonTerminal D'))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal D') (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifies_NP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number) (featurePath (atomicValue plural))))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (disjunctiveUnificationConstraint { (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | initial modifiers not case-marked\r\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue gen_initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue genitive) (comment | unless can take genitive initially\r\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue gen_initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | 7Apr03 CB\r\n)))) }))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not in DP coordination construction\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue initialP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | restrict conjunctions here and in DP \r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue gloss)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue also)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue polarity)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number)))) (closingWedge >)) (comment | plurality comes from Deg\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 2bconjIpl)))))) (patrRule (ruleKW rule) (ruleIdentifier { DP option 2bconjIF - modifier initial, Conj initial, final }) (phraseStructureRule (nonTerminal DP) (ruleDef =) (rightHandSide (nonTerminal Conj) (nonTerminal Deg) (nonTerminal D') (nonTerminal Conj_2))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal D') (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal D') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal D') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifies_NP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number) (featurePath (atomicValue plural))))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (disjunctiveUnificationConstraint { (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | initial modifiers not case-marked\r\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue gen_initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue genitive) (comment | unless can take genitive initially\r\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue gen_initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | 7Apr03 CB\r\n)))) }))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not in DP coordination construction\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue initialP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | restrict conjunctions here and in DP \r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue gloss)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue also)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP-final)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue polarity)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal Conj_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal Conj_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue -)) (comment | 04 Apr03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 2bconjIF)))))) (patrRule (ruleKW rule) (ruleIdentifier { DP option 2bconjIFpl - plural modifier initial, Conj initial, final }) (phraseStructureRule (nonTerminal DP) (ruleDef =) (rightHandSide (nonTerminal Conj) (nonTerminal Deg) (nonTerminal D') (nonTerminal Conj_2))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal D') (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal D') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal D') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifies_NP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number) (featurePath (atomicValue plural))))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (disjunctiveUnificationConstraint { (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | initial modifiers not case-marked\r\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue gen_initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue genitive) (comment | unless can take genitive initially\r\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue gen_initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | 7Apr03 CB\r\n)))) }))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not in DP coordination construction\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue initialP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | restrict conjunctions here and in DP \r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue gloss)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue also)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP-final)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue polarity)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal Conj_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal Conj_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue -)) (comment | 04 Apr03 CB\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number)))) (closingWedge >)) (comment | plurality comes from Deg\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 2bconjIFpl)))))) (patrRule (ruleKW rule) (ruleIdentifier { DP option 2bconjF - modifier initial, Conj final }) (phraseStructureRule (nonTerminal DP) (ruleDef =) (rightHandSide (nonTerminal Deg) (nonTerminal D') (nonTerminal Conj))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal D') (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal D') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal D') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifies_NP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number) (featurePath (atomicValue plural))))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (disjunctiveUnificationConstraint { (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | initial modifiers not case-marked\r\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue gen_initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue genitive) (comment | unless can take genitive initially\r\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue gen_initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | 7Apr03 CB\r\n)))) }))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not in DP coordination construction\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue initialP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | restrict conjunctions here and in DP \r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP-final)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue polarity)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue -)) (comment | 04 Apr03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 2bconjF)))))) (patrRule (ruleKW rule) (ruleIdentifier { DP option 2bconjFpl - plural modifier initial, Conj final }) (phraseStructureRule (nonTerminal DP) (ruleDef =) (rightHandSide (nonTerminal Deg) (nonTerminal D') (nonTerminal Conj))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal D') (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal D') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal D') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifies_NP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number) (featurePath (atomicValue plural))))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (disjunctiveUnificationConstraint { (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | initial modifiers not case-marked\r\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue gen_initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue genitive) (comment | unless can take genitive initially\r\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue gen_initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | 7Apr03 CB\r\n)))) }))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not in DP coordination construction\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue initialP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | restrict conjunctions here and in DP \r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP-final)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue polarity)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue -)) (comment | 04 Apr03 CB\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number)))) (closingWedge >)) (comment | plurality comes from Deg\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 2bconjFpl)))))) (patrRule (ruleKW rule) (ruleIdentifier { DP option 2z - modifiers final }) (phraseStructureRule (nonTerminal DP) (ruleDef =) (rightHandSide (nonTerminal D') (nonTerminal Deg))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal D') (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal D') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal D') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifies_NP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue polarity)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP-final)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue agr))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal D') (featurePath (atomicValue head) (featurePath (atomicValue agr))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | Deg not marked for case\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue -)) (comment | 04 Apr03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 2z)))))) (patrRule (ruleKW rule) (ruleIdentifier { DP option 2zconjI - modifiers final, Conj initial }) (phraseStructureRule (nonTerminal DP) (ruleDef =) (rightHandSide (nonTerminal Conj) (nonTerminal D') (nonTerminal Deg))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal D') (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal D') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal D') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifies_NP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue polarity)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP-final)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue agr))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal D') (featurePath (atomicValue head) (featurePath (atomicValue agr))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | Deg not marked for case\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not in DP coordination construction\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue initialP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | restrict conjunctions here and in DP \r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue gloss)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue also)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue -)) (comment | 04 Apr03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 2zconjI)))))) (patrRule (ruleKW rule) (ruleIdentifier { DP option 2zconjIF - modifiers final, Conj initial, final }) (phraseStructureRule (nonTerminal DP) (ruleDef =) (rightHandSide (nonTerminal Conj) (nonTerminal D') (nonTerminal Deg) (nonTerminal Conj_2))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal D') (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal D') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal D') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifies_NP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue polarity)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP-final)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue agr))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal D') (featurePath (atomicValue head) (featurePath (atomicValue agr))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | Deg not marked for case\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not in DP coordination construction\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue initialP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | restrict conjunctions here and in DP \r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue gloss)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue also)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP-final)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal Conj_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal Conj_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue -)) (comment | 04 Apr03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 2zconjIF)))))) (patrRule (ruleKW rule) (ruleIdentifier { DP option 2zconjF - modifiers final, Conj final }) (phraseStructureRule (nonTerminal DP) (ruleDef =) (rightHandSide (nonTerminal D') (nonTerminal Deg) (nonTerminal Conj))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal D') (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal D') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal D') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifies_NP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue polarity)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP-final)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue agr))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal D') (featurePath (atomicValue head) (featurePath (atomicValue agr))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | Deg not marked for case\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue case-marked)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not in DP coordination construction\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue initialP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | restrict conjunctions here and in DP \r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP-final)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue -)) (comment | 04 Apr03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal DP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 2zconjF) (comment |-********************************************************\r\n)) (comment |rules split 29Jan03 CB to deal with phrases for relcl2\r\n))))) (patrRule (ruleKW rule) (ruleIdentifier { D' option 4a - no modifiers }) (phraseStructureRule (nonTerminal D') (ruleDef =) (rightHandSide (nonTerminal NP))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal D') (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal NP) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal D') (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 4a)))))) (patrRule (ruleKW rule) (ruleIdentifier { D' option 4aDem - only demonstratives, initial }) (phraseStructureRule (nonTerminal D') (ruleDef =) (rightHandSide (nonTerminal Dem) (nonTerminal NP))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal D') (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal NP) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Dem) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Dem) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comp_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | head relcl 7Apr03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Dem) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | Dem unmarked for case in Gilaki/Balochi when a modifier\r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal NP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue generic)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue -)) (comment | generic nouns become non-generic with Dem  8Jan2020 CB\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal D') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue wh)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal Dem) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue wh)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal D') (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue polarity)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal Dem) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue polarity)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal D') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-initial)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | for relcl2 constraint 29Jan03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal D') (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 4a) (comment |-*********************************************************\r\n)))))) (patrRule (ruleKW rule) (ruleIdentifier { NP option 1a - no possessor }) (phraseStructureRule (nonTerminal NP) (ruleDef =) (rightHandSide (disjunctiveTerminals { (nonTerminal N'') (disjunctionNonTerminal / (nonTerminal N')) }))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal NP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal N'') (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal NP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head)) (closingWedge >) (comment |    {<NP head type genitive_suffix> = -   | if +, possessor required, eliminates NPreps\r\n)) (comment |    /<NP head type genitive_suffix> = +\r\n))) (constraint (comment |     <NP head type locative> = +          | 0May19 CB locatives are genitive\r\n)) (constraint (comment |    }                                     | testing removal 20Aug2019\r\n)) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal NP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 1a)))))) (patrRule (ruleKW rule) (ruleIdentifier { NP option 1bposs - no separate marker, possessor final } NP = { N'' / N' } DP < NP head > = < N'' head > < NP head > = < N' head > < NP head type NPrep > = - | **22Jul06 CB NPrep use 1bNPrep\r\n < NP head type no_head_N > = - | to disallow Num, Q as having possessors Mar2020\r\n < DP head type apposition > = - | apposition to whole DP, not just possessor 20Jan03 CB \r\n < DP head type case-marked > = - | possessor not separately case-marked 20Jan03 CB\r\n < DP head type no_head_N > = - | to disallow Num, Q as possessors 14Jul03\r\n < N' head type comma > = - < N'' head type comma > = - < N' head type pronoun > = - | pronouns do not have noun possessors Apr 2020\r\n < N'' head type pronoun > = - | pronouns do not have noun possessors Apr 2020\r\n < N' head type relative > = - | N cannot have REL with following modifier\r\n < N'' head type relative > = - | N cannot have REL with following modifier\r\n < N' head type temporal > = - | possessed nouns are not temporal APr2020\r\n < N'' head type temporal > = - | possessed nouns are not temporal APr2020\r\n < DP head type temporal > = - | possessors are not temporal APr2020\r\n < DP head type DO_contraction > = - | DO_contraction use 1contr rule\r\n ||    <DP head type coordination> = -   | not allowing coordinate possessors |Genitive 3 has 22May2019 CB\r\n < DP head case_for_position > = genitive | to know normal case for conjoined DPs\r\n < DP head case > = genitive | possessor is genitive case\r\n |   {<DP head case> = genitive          | possessor is genitive case\r\n |   /<DP head type genitive_suffix> = +  | took genitive case off genitive_suffix for other issues, so need |this\r\n |   }                                    | for genitive possessors  16Aug2019\r\n < DP head infl polarity > = + | possessors are not negative\r\n < DP head type relcl > = - | no relcl within possessor 28Jan03CB\r\n < NP head possessor > = < DP > < N' head case > = < NP head case_for_position > < N'' head case > = < NP head case_for_position > < NP head reflexive > = < DP head reflexive > | pass reflexive info to possessor\r\n < NP head type modifier-final > <= + | was for Gilaki to handle genitive case required with final modifiers\r\n < DP > == ~ [ cat : Num ] | numbers can't be possessors  \r\n < NP head type indefinite > <= < DP head type indefinite > < NP head type relative > <= < DP head type relative > < NP head type comma > <= < DP head type comma > | needed  17Jan03 CB\r\n < NP head type compound > <= < DP head type compound > | 04Apr03 CB\r\n < NP rule > = 1bposs |This rule needed???  trying removal 20 AUG2019\r\n |rule added **22Jul06 CB to deal with differences with NPrep vs possessors, e.g. negative objects\r\n |rule {NP option 1bNPrep - NPrep object final}\r\n |NP = {N'' / N'} DP\r\n |    <NP head> = <N'' head>\r\n |    <NP head> = <N' head>\r\n |    <NP head type NPrep> = +\r\n |    <DP head type apposition> = -   | apposition to whole DP, not just object 20Jan03 CB \r\n |    <DP head type case-marked> = -           | object not separately case-marked 20Jan03 CB\r\n |    <DP head type no_head_N> = -    | to disallow Num, Q as objects 14Jul03\r\n |    <N' head type comma> = -\r\n |    <N'' head type comma> = -\r\n |    <N' head type relative> = -    | N cannot have REL with following modifier\r\n |    <N'' head type relative> = -    | N cannot have REL with following modifier\r\n |    <DP head type DO_contraction> = -  | DO_contraction use 1contr rule\r\n |    <DP head case_for_position> = direct  | to know normal case for conjoined DPs\r\n |    {<DP head case> = direct          | changed to direct\r\n |     <DP head type pronoun> = -\r\n |     <DP head type genitive_suffix> = -\r\n |    /<DP head case> = genitive           | except for pronoun objects\r\n |     <DP head type pronoun> = +\r\n |     <DP head type genitive_suffix> = -\r\n |    /<DP head case> = genitive           | or when has genitive_suffix\r\n |     <DP head type genitive_suffix> = +\r\n |    }\r\n |    <DP head type relcl> = -         | no relcl within object 28Jan03CB\r\n |    <NP head object> = <DP>\r\n |    <N' head case> = <NP head case_for_position>\r\n |    <N'' head case> = <NP head case_for_position>\r\n |    <NP head reflexive> = <DP head reflexive> | pass reflexive info to object\r\n |    <NP head type modifier-final> <= +   | to handle genitive case required with final modifiers\r\n |    <DP> == ~[cat:Num]             | numbers can't be objects \r\n |    <NP head type indefinite> <= <DP head type indefinite>\r\n |    <NP head type relative> <= <DP head type relative>\r\n |    <NP head type comma> <= <DP head type comma>      | needed  17Jan03 CB\r\n |    <NP head type compound> <= <DP head type compound>  | 04Apr03 CB\r\n |    <NP rule> = 1bNPrep\r\n rule { NP option 1contr - no separate marker, DO_contraction possessor final } NP = { N'' / N' } DP < NP head > = < N'' head > < NP head > = < N' head > < N'' head type comma > = - < N' head type comma > = - < N'' head type relative > = - | N cannot have REL with following modifier\r\n < DP head type DO_contraction > = + | DO_contraction\r\n < DP head case > = genitive | specially marked for Gilaki/Balochi transfer\r\n < DP head infl polarity > = + | possessors are not negative\r\n < DP head type relcl > = - | no relcl within possessor 28Jan03CB\r\n < DP head type coordination > = - < NP head possessor > = < DP > < N' head case > = < NP head case_for_position > < N'' head case > = < NP head case_for_position > < N' head type DO_contraction > = - | to eliminate double contractions\r\n < N'' head type DO_contraction > = - | to eliminate double contractions\r\n < NP head reflexive > = < DP head reflexive > | pass reflexive info to possessor\r\n < NP head type modifier-final > <= + | to handle genitive case required with final modifiers\r\n < NP head type DO_contraction > <= < DP head type DO_contraction > | for contraction form of possessor\r\n < NP head case > <= < DP head case > | accusative case comes from DO_contraction\r\n < NP head type indefinite > <= < DP head type indefinite > < NP head type relative > <= < DP head type relative > < NP head type comma > <= < DP head type comma > < NP head type compound > <= < DP head type compound > | 04Apr03 CB\r\n < NP rule > = 1contr | removed 28Apr2020 needed???\r\n |rule {NP option 6a - non-nominal heads}\r\n |NP = { Deg / QP} | RL Apr 2020 took out "Dem /"\r\n ||    <NP head> = <Dem head>\r\n |    <NP head> = <Deg head>\r\n |    <NP head> = <QP head>\r\n |    <QP head type human> = + | RL 11Dec02 Force an NP that consists only of a QP to be human |so that we don't get two identical parses at the IP level (one for 3rd sg and one for 3rd pl |subject)\r\n |    <Deg head type quantifier> = +\r\n |    <Deg head case> = direct       | RL 6Apr03 A degree word that stands alone can't have |genitive suffix. This eliminates 2 extra parses from Acts 13:20a.\r\n |    <Deg head type gen_initial> = -    | RL 9May03 Likewise a degree word that takes a |genitive can't stand alone.\r\n ||    <Dem head type wh > = -        |- so "which" not separate\r\n |    <NP head type modifier-final> = -\r\n |    <NP head type modifier-initial> = -\r\n |    <NP head type no_head_N> = +        | to disallow compound V with neg alone\r\n |    <NP rule> = 6a\r\n | removed 28Apr2020 needed???\r\n |rule {NP option 6aPP - non-nominal heads, with partitive PP after}\r\n |NP = { Deg / QP} PP | RL Apr 2020 took out "Dem /"\r\n ||    <NP head> = <Dem head>\r\n |    <NP head> = <Deg head>\r\n |    <NP head> = <QP head>\r\n |    <NP head reflexive> = <PP head reflexive> | pass reflexive info to PP\r\n ||    <Dem head type comma> = -\r\n |    <Deg head type comma> = -\r\n |    <QP head type comma> = -\r\n ||    <Dem head type relative> = -\r\n |    <Deg head type relative> = -\r\n |    <QP head type relative> = -\r\n |    <Deg head type quantifier> = +\r\n ||    <Dem head type wh > = -        |- so "which" not separate\r\n |    <PP head type stranded> = -            |- PP must have overt complement\r\n |    <PP head type sentential> = -    |- sentential not within NP\r\n |    <NP head type modifier-final> = -\r\n |    <NP head type modifier-initial> = -\r\n |    <NP head type no_head_N> = +        | to disallow compound V with neg alone\r\n |    <NP head type relative> <= <PP head type relative>\r\n |    <NP head type comma> <= <PP head type comma>\r\n |    <PP head object head type> == [modifier-final:+] -> ~[compound:+]  | PPs with modified |objects whose final element is marked compound, must compound 16Jul03 CB\r\n |    <PP head> == ~[rootgloss:for]      | PP not benefactor 24Jul03 CB\r\n |    <NP rule> = 6aPP\r\n rule { NP option 6apn - NP = Pn }) (phraseStructureRule (nonTerminal NP) (ruleDef =) (rightHandSide (nonTerminal Pron))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal NP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal Pron) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal NP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue reflexivity)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal NP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 6apn)))))) (patrRule (ruleKW rule) (ruleIdentifier { NP option 6apnreflex - NP = ReflexivePn }) (phraseStructureRule (nonTerminal NP) (ruleDef =) (rightHandSide (nonTerminal Pron))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal NP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal Pron) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal NP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue reflexivity)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Pron) (featurePath (atomicValue head) (featurePath (atomicValue agr))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal NP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive) (featurePath (atomicValue head) (featurePath (atomicValue agr))))) (closingWedge >) (comment |enforce agreement\r\n)) (comment ||    <NP head reflexive> = <Pron> |enforce agreement won't run - causes cycle WOrk on.\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal NP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 6apnreflex)))))) (patrRule (ruleKW rule) (ruleIdentifier { NP option 6aempreflex - NP = Pn + ReflexivePn }) (comment | emphatic with pers num agreement\r\n) (phraseStructureRule (nonTerminal NP) (ruleDef =) (rightHandSide (nonTerminal Pron_1) (nonTerminal Pron_2))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal NP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal Pron_2) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Pron_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue reflexivity)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Pron_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue reflexivity)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Pron_1) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | keeping Pron_1 unmarked for case, we expect case on Pron_2 when needed\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Pron_1) (featurePath (atomicValue head) (featurePath (atomicValue agr))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal Pron_2) (featurePath (atomicValue head) (featurePath (atomicValue agr))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Pron_2) (featurePath (atomicValue head) (featurePath (atomicValue agr))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal NP) (featurePath (atomicValue head) (featurePath (atomicValue reflexive) (featurePath (atomicValue head) (featurePath (atomicValue agr))))) (closingWedge >) (comment |enforce agreement\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal NP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 6aempreflex) (comment |-********************************************************\r\n)))))) (patrRule (ruleKW rule) (ruleIdentifier { N'' option 1 - QPs initial }) (phraseStructureRule (nonTerminal N'') (ruleDef =) (rightHandSide (nonTerminal QP) (nonTerminal N'))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N'') (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal QP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal QP) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | initial modifiers unmarked for case\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue object_agr_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment |CB 24May19   no object agr\r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal N'') (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal QP) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal N'') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue indefinite)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal QP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue indefinite)))) (closingWedge >)) (comment | to make nouns preceded by one to pass indefinite feature up.\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-initial)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | for relcl2 constraint 28Jan03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N'') (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 1)))))) (patrRule (ruleKW rule) (ruleIdentifier { N'' option 2 - QPs final }) (phraseStructureRule (nonTerminal N'') (ruleDef =) (rightHandSide (nonTerminal N') (nonTerminal QP))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N'') (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal QP) (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue agr) (featurePath (atomicValue number)))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | N cannot have REL with following modifier\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N'') (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal N'') (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal QP) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment |    <QP head type ordinal> = +\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue object_agr_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment |CB 24May19   no object agr\r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal N'') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-final)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | to handle genitive case required with final modifiers\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal QP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal N'') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal QP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal N'') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue -)) (comment | 04Apr03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N'') (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 2) (comment |-********************************************************\r\n)))))) (patrRule (ruleKW rule) (ruleIdentifier { N' option 1a - AdjP initial, recursive }) (phraseStructureRule (nonTerminal N') (ruleDef =) (rightHandSide (nonTerminal AdjP) (nonTerminal N'_2))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal N'_2) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal AdjP) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | initial modifiers unmarked for case\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal AdjP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal AdjP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue attributive)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | 8May19 RL CB here as well as AdjP final true?\r\n)) (comment |    <AdjP head type ordinal> = -     | testing this with genitive.txt\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal AdjP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N'_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue object_agr_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment |CB 24May19   no object agr\r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-initial)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | for relcl2 constraint 28Jan03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 1a)))))) (patrRule (ruleKW rule) (ruleIdentifier { N' option 1b - AdjP final, recursive }) (phraseStructureRule (nonTerminal N') (ruleDef =) (rightHandSide (nonTerminal N'_2) (nonTerminal AdjP))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal N'_2) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal AdjP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP-final)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal AdjP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue attributive)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | 8May19 RL\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N'_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue nonfinalcoordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | coordination use next rule\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | N cannot have REL with following modifier\r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-final)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | to handle genitive case required with final modifiers\r\n))) (constraint (comment |    <N' head type genitive_suffix> <= <AdjP head type genitive_suffix> | N marking can be overridden by AdjP, if AdjP also marked then another modifier required.\r\n)) (constraint (unificationConstraint (disjunctiveUnificationConstraint { (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal AdjP) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | unmarked for case 14Aug03 CB\r\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal AdjP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue genitive_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal AdjP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue genitive_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | unless has genitive_suffix\r\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal AdjP) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue genitive)))) }))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N'_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue object_agr_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment |CB 24May19   no object agr\r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue indefinite)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal AdjP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue indefinite)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal AdjP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal AdjP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal AdjP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) (comment | 04Apr03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 1b)))))) (patrRule (ruleKW rule) (ruleIdentifier { N' option 1bcoord - AdjP final, recursive, for non-final coordination }) (phraseStructureRule (nonTerminal N') (ruleDef =) (rightHandSide (nonTerminal N'_2) (nonTerminal AdjP))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal N'_2) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal AdjP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue DP-final)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal AdjP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue attributive)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | 8May19 RL\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N'_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue nonfinalcoordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (disjunctiveUnificationConstraint { (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal AdjP) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | unmarked for case 14Aug03 CB\r\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal AdjP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue genitive_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal AdjP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue genitive_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | unless has genitive_suffix\r\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal AdjP) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue genitive)))) }))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | N cannot have REL with following modifier\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N'_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue object_agr_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment |CB 24May19   no object agr\r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-final)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | to handle genitive case required with final modifiers\r\n))) (constraint (comment |    <N' head type genitive_suffix> <= <AdjP head type genitive_suffix> | N marking can be overridden by AdjP, if AdjP also marked then another modifier required.\r\n)) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue indefinite)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal AdjP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue indefinite)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal AdjP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal AdjP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal AdjP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) (comment | 04Apr03 CB\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 1bcoord) (comment |09-APR-04 added for participle - need to noload any Adj entries derived from V+participle **20Jul06 CB Not restricting this type of participle so constraint removed.\r\n)))))) (patrRule (ruleKW rule) (ruleIdentifier { N' option 2b - VPart final, recursive }) (phraseStructureRule (nonTerminal N') (ruleDef =) (rightHandSide (nonTerminal N'_2) (nonTerminal V))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal N'_2) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N'_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N'_2) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue nonfinalcoordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | coordination use next rule\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue participle)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | ??\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | N cannot have REL with following modifier\r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-final)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | to handle genitive case required with final modifiers\r\n))) (constraint (comment |    <N' head type genitive_suffix> <= <V head type genitive_suffix> | N marking can be overridden by V, if V also marked then another modifier required.\r\n)) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue indefinite)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue -)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue -)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue -)))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal V) (closingWedge >)) == (logConstraintExpression ~ (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue rootgloss)) : (featureStructureValue (atomicValue become)) (closingBracket ]) (comment | Sdn does not form participle adjectives 13-APR-04\r\n)))))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 2b) (comment |09-APR-04 added for participle **20Jul06 CB Not restricting this type of participle so constraint removed.\r\n)))))) (patrRule (ruleKW rule) (ruleIdentifier { N' option 2bcoord - VPart final, recursive, for non-final coordination }) (phraseStructureRule (nonTerminal N') (ruleDef =) (rightHandSide (nonTerminal N'_2) (nonTerminal V))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal N'_2) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N'_2) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N'_2) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue case_for_position))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue nonfinalcoordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue coordination)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue participle)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | unmarked for case 14Aug03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | N cannot have REL with following modifier\r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-final)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | to handle genitive case required with final modifiers\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue genitive_suffix)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue genitive_suffix)))) (closingWedge >)) (comment | N marking can be overridden by V, if V also marked then another modifier required.\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue indefinite)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue -)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue -)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal V) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue -)))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal V) (closingWedge >)) == (logConstraintExpression ~ (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue rootgloss)) : (featureStructureValue (atomicValue become)) (closingBracket ]) (comment | Sdn does not form participle adjectives 13-APR-04\r\n)))))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 2bcoord) (comment | try eliminating this rule, seldom needed 19Feb03  12Aug2019 trying for Balach with brothers\r\n)) (comment | removed Apr2020, allowing with PP as adjoined PP instead, verb has singular agreement\r\n))) (constraint (comment |rule {N' option 3bPP - noun, PP final}\r\n)) (constraint (comment |N' = N PP\r\n)) (constraint (comment |    <N' head> = <N head>\r\n)) (constraint (comment |    <N' head rootgloss> = <N rootgloss>  |for compounding constraint 10Jul03\r\n)) (constraint (comment |    <PP head rootgloss> = with\r\n)) (constraint (comment |    <PP head type stranded> = -         |- P must have overt complement\r\n)) (constraint (comment |    <PP head type sentential> = -       |- sentential not within NP\r\n)) (constraint (comment |    <N head type comma> = -\r\n)) (constraint (comment |    <N head type copular_suffix> = -    | Apr2020\r\n)) (constraint (comment |    <N' head type no_head_N> = -\r\n)) (constraint (comment |    <N' head reflexive> = <PP head reflexive> | pass reflexive info to PP\r\n)) (constraint (comment |    <N' head type relative> = -    | N cannot have REL with following modifier\r\n)) (constraint (comment |    <N' head type relative> <= <PP head type relative>\r\n)) (constraint (comment |    <N' head type comma> <= <PP head type comma>\r\n)) (constraint (comment |    <N' head type compound> <= <PP head type compound>  | 17Jan03 CB\r\n)) (constraint (comment |    <N' rule> = 3bPP\r\n)))) (patrRule (ruleKW rule) (ruleIdentifier { N' option 3b - noun }) (phraseStructureRule (nonTerminal N') (ruleDef =) (rightHandSide (nonTerminal N))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal N) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue rootgloss))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal N) (featurePath (atomicValue rootgloss)) (closingWedge >) (comment |for compounding constraint 10Jul03\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue participle))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue none) (comment | for participle constraint 12-APR-04\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue subject) (featurePath (atomicValue head) (featurePath (atomicValue agr))))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue none) (comment | testing 28May19 ***\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue atributive)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | testing 28May19 ***\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_head_N)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 3b)))))) (patrRule (ruleKW rule) (ruleIdentifier { N' option conj - conjoined nouns }) (phraseStructureRule (nonTerminal N') (ruleDef =) (rightHandSide (optionalTerminals ( (nonTerminal N_3) (nonTerminal Conj_2) )) (nonTerminal N_2) (nonTerminal Conj_1) (nonTerminal N_1))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal N_1) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue rootgloss))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal N_2) (featurePath (atomicValue rootgloss)) (closingWedge >) (comment |for compounding constraint 10Jul03\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue participle))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue none) (comment | for participle constraint 12-APR-04\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N_2) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N_3) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj_2) (featurePath (atomicValue gloss)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue and)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj_1) (featurePath (atomicValue gloss)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue and)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | to prevent recursion\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N_1) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N_2) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N_3) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_head_N)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue genitive_suffix)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | to force following modifier\r\n))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue conj) (comment |added 09Jul03 CB for compound infinitives\r\n)))))) (patrRule (ruleKW rule) (ruleIdentifier { N' option compound }) (phraseStructureRule (nonTerminal N') (ruleDef =) (rightHandSide (nonTerminal N_1) (nonTerminal N))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal N) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue rootgloss))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal N) (featurePath (atomicValue rootgloss)) (closingWedge >) (comment |for compounding constraint 10Jul03\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue participle))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue none) (comment | for participle constraint 12-APR-04\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N_1) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue finite)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_head_N)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (disjunctiveUnificationConstraint { (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal N) (featurePath (atomicValue rootgloss)) (closingWedge >))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with2)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal N) (featurePath (atomicValue rootgloss)) (closingWedge >)))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with3)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal N) (featurePath (atomicValue rootgloss)) (closingWedge >)))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with4)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal N) (featurePath (atomicValue rootgloss)) (closingWedge >)))) }))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue compound) (comment |added 11Dec03 CB for compound infinitives with Adj\r\n)))))) (patrRule (ruleKW rule) (ruleIdentifier { N' option compoundAdj }) (phraseStructureRule (nonTerminal N') (ruleDef =) (rightHandSide (nonTerminal Adj) (nonTerminal N))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal N) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue rootgloss))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal N) (featurePath (atomicValue rootgloss)) (closingWedge >) (comment |for compounding constraint 10Jul03\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue participle))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue none) (comment | for participle constraint 12-APR-04\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Adj) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Adj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Adj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compound)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue finite)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue no_head_N)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (disjunctiveUnificationConstraint { (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Adj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with1)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal N) (featurePath (atomicValue rootgloss)) (closingWedge >))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Adj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with2)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal N) (featurePath (atomicValue rootgloss)) (closingWedge >)))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Adj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with3)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal N) (featurePath (atomicValue rootgloss)) (closingWedge >)))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Adj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue compounds_with4)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal N) (featurePath (atomicValue rootgloss)) (closingWedge >)))) }))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N') (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue compoundAdj) (comment |-***********************************************************\r\n)))))) (patrRule (ruleKW rule) (ruleIdentifier { PP option 2a - optional adverbial or Deg before }) (phraseStructureRule (nonTerminal PP) (ruleDef =) (rightHandSide (optionalTerminals ( (nonTerminal Deg_1) )) (disjunctiveOptionalNonTerminal ( (nonTerminal AdvP) (disjunctionOptionalNonTerminal / (nonTerminal Deg)) )) (nonTerminal P'))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal PP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal P') (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal AdvP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal AdvP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue manner)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifies_PP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifies_PP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg_1) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue polarity)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (disjunctiveUnificationConstraint { (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P') (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment |new\r\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue genitive_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P') (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue genitive))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue genitive_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (disjunctionUnificationConstraint / (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P') (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue genitive))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue genitive_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue prefix_Prep)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | added 17Feb03 CB for P AdjP\r\n))) (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-final)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | added 17Feb03 CB for P AdjP\r\n)))) }))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal PP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 2a) (comment |-***********************************************************\r\n)))))) (patrRule (ruleKW rule) (ruleIdentifier { P' option 1a - prepositions, DP complement only - not for bh = to } P' = P ( N ) DP < P' head > = < P head > < P' head rootgloss > = < P rootgloss > < P' head gloss > = < P gloss > < P head type comma > = - < N head type comma > = - < N head subject head agr > = none | testing 28May19 ***\r\n < N head type attributive > = - | testing 28May19 ***\r\n < P head type PP-initial > = + |    {<P head type prefix_Prep> = -                                       | causing failure 22Aug2019\r\n |    /<P head type prefix_Prep> = +  \r\n |     <P head type demonstrative> = + | need to allow object with bdyn qrar CB\r\n |     <P head type pronoun> = -       | but not with pronoun\r\n |    }\r\n < P head type suffix_Pn > = - < P' head reflexive > = < DP head reflexive > | pass reflexive info\r\n < DP head type case-marked > = - |RL 30Jan02  can't have a DO marker in a prepositional phrase.\r\n < DP head type DO_contraction > = - { < DP head case > = genitive | we are setting the case of the DP in the Prep Phrase to genitive (this should help with transfer to Balochi)\r\n < DP head case_for_position > = genitive | to know normal case for conjoined DPs\r\n < P head type translates2Prep > = - / < DP head type genitive_suffix > = + < P head type translates2Prep > = - < DP head case_for_position > = genitive | to know normal case for conjoined DPs\r\n / < DP head case > = oblique | different case marking for PPs that stay prepositions like with\r\n < DP head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < P head type translates2Prep > = + < DP head type pronoun > = - / < DP head case > = oblique | different case marking for PPs that stay prepositions like with\r\n < DP head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < P head type translates2Prep > = + < DP head type pronoun > = + < DP head agr person third > = + / < DP head case > = direct | different case for 1st and 2nd pronouns  23Jan2020\r\n < DP head case_for_position > = direct | to know normal case for conjoined DPs\r\n < P head type translates2Prep > = + < DP head type pronoun > = + < DP head agr person first > = + / < DP head case > = direct < DP head case_for_position > = direct | to know normal case for conjoined DPs\r\n < P head type translates2Prep > = + < DP head type pronoun > = + < DP head agr person second > = + } < P' head type stranded > = - |- not missing a complement\r\n < P' head object > = < DP > |- for passive, logical constraint 27Jan03 CB\r\n < N head case > = oblique < P head case > = direct < DP head participle > = none | trying to restrict participles 12-APR-04\r\n < DP head possessor head participle > = none | trying to restrict participles 12-APR-04\r\n < DP head type nonfinalcoordination > = - < DP > == ~ [ mother_node : - ] | if coordination, must be allowed initially\r\n < DP > == [ mother_node : + ] -> [ head : [ type : [ coordination : + ] ] ] |and be complete\r\n < DP head type > == [ relative : + ] -> [ relcl : + ] | require rel suffix to only occur when relative clause present\r\n < P > == ~ [ rootgloss : to ] | IO, locative use other rule                  | Jun2019 CB\r\n < P > == ~ [ gloss : to ] | IO, locative use other rule                  | Jun2019 CB\r\n < P' head type comma > <= < DP head type comma > < P' head type wh > <= < DP head type wh > |- wh for pied-piping\r\n |following removed 21Apr03 CB for "from this same man" marked on P.  If this doesn't work for other situations, need to split feature between source and locative, mark source on P, and add InitP rule allowing source PPs.\r\n |    <P' head type locative> <= <DP head type locative> | Feb03 CB\r\n |    <P' head> == [rootgloss:to] -> ~[object:[head:[type:[pronoun:+]]]]  |only nonpronominals with bh (otherwise use next rule) 27Jan03 CB, removed Jun2019\r\n < P' rule > = 1a |************\r\n |added 26Jun2019 CB locative use of to with noun below \r\n rule { P' option 1aIO - prepositions, DP complement only for IO P = to } P' = P DP < P' head > = < P head > < P' head rootgloss > = < P rootgloss > < P rootgloss > = to < P' head gloss > = < P gloss > < P gloss > = to < P' head type location_PP > = - | not for location with motion verbs\r\n < P head type comma > = - < P head type PP-initial > = + |    {<P head type prefix_Prep> = -                                       | causing failure 22Aug2019\r\n |    /<P head type prefix_Prep> = +  \r\n |     <P head type demonstrative> = + | need to allow object with bdyn qrar CB\r\n |     <P head type pronoun> = -       | but not with pronoun\r\n |    }\r\n < P head type suffix_Pn > = - < P' head reflexive > = < DP head reflexive > | pass reflexive info\r\n < DP head type case-marked > = - |RL 30Jan02  can't have a DO marker in a prepositional phrase.\r\n < DP head type DO_contraction > = - ||    <DP head case_for_position> = objective  | to know normal case for conjoined DPs- DP case set by VP rule\r\n < P' head type stranded > = - |- not missing a complement\r\n < P' head object > = < DP > |- for passive, logical constraint 27Jan03 CB\r\n < P head case > = direct < DP head participle > = none | trying to restrict participles 12-APR-04\r\n < DP head possessor head participle > = none | trying to restrict participles 12-APR-04\r\n < DP head type nonfinalcoordination > = - < DP > == ~ [ mother_node : - ] | if coordination, must be allowed initially\r\n < DP > == [ mother_node : + ] -> [ head : [ type : [ coordination : + ] ] ] |and be complete\r\n < DP head type > == [ relative : + ] -> [ relcl : + ] | require rel suffix to only occur when relative clause present\r\n < P' head type comma > <= < DP head type comma > < P' head type wh > <= < DP head type wh > |- wh for pied-piping\r\n |following removed 21Apr03 CB for "from this same man" marked on P.  If this doesn't work for other situations, need to split feature between source and locative, mark source on P, and add InitP rule allowing source PPs.\r\n |    <P' head type locative> <= <DP head type locative> | Feb03 CB\r\n < P' rule > = 1aIO |added 22Aug2019 CB \r\n rule { P' option 1aLocTo - prepositions, DP complement only for P = to when a locative } P' = P DP < P' head > = < P head > < P' head rootgloss > = < P rootgloss > < P rootgloss > = to < P' head gloss > = < P gloss > < P gloss > = to < P head type locative > = + < P' head type location_PP > = + < P head type comma > = - < P head type PP-initial > = + |    {<P head type prefix_Prep> = -                                       | causing failure 22Aug2019\r\n |    /<P head type prefix_Prep> = +  \r\n |     <P head type demonstrative> = + | need to allow object with bdyn qrar CB\r\n |     <P head type pronoun> = -       | but not with pronoun\r\n |    }\r\n < P head type suffix_Pn > = - < P' head reflexive > = < DP head reflexive > | pass reflexive info\r\n < DP head type case-marked > = - |RL 30Jan02  can't have a DO marker in a prepositional phrase.\r\n < DP head type DO_contraction > = - < DP head case_for_position > = oblique | to know normal case for conjoined DPs\r\n < DP head case > = oblique | we are setting the case of the DP in the locative Prep Phrase to oblique (this should help with transfer to Balochi)\r\n < P' head type stranded > = - |- not missing a complement\r\n < P' head object > = < DP > |- for passive, logical constraint 27Jan03 CB\r\n < P head case > = direct < DP head participle > = none | trying to restrict participles 12-APR-04\r\n < DP head possessor head participle > = none | trying to restrict participles 12-APR-04\r\n < DP head type nonfinalcoordination > = - < DP > == ~ [ mother_node : - ] | if coordination, must be allowed initially\r\n < DP > == [ mother_node : + ] -> [ head : [ type : [ coordination : + ] ] ] |and be complete\r\n < DP head type > == [ relative : + ] -> [ relcl : + ] | require rel suffix to only occur when relative clause present\r\n < P' head type comma > <= < DP head type comma > < P' head type wh > <= < DP head type wh > |- wh for pied-piping\r\n < P' rule > = 1aLocTo rule { P' option 1adv - prepositions, locative complement only }) (phraseStructureRule (nonTerminal P') (ruleDef =) (rightHandSide (nonTerminal P) (optionalTerminals ( (nonTerminal N) )) (nonTerminal AdvP))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P') (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal P) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P') (featurePath (atomicValue head) (featurePath (atomicValue rootgloss))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal P) (featurePath (atomicValue rootgloss)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P') (featurePath (atomicValue head) (featurePath (atomicValue gloss))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal P) (featurePath (atomicValue gloss)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue PP-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal AdvP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue locative)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue locative)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | pass up locative feature\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue stranded)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment |- not missing a complement\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue oblique)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal P') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal AdvP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal P) (closingWedge >)) == (logConstraintExpression ~ (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue rootgloss)) : (featureStructureValue (atomicValue for)) (closingBracket ]) (comment | benefactors use option benefactorPP\r\n)))))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal P) (closingWedge >)) == (logConstraintExpression ~ (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue gloss)) : (featureStructureValue (atomicValue for)) (closingBracket ]) (comment | benefactors use option benefactorPP\r\n)))))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P') (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 1adv) (comment | RL added this rule 23Jan03 E.g: bh^^vwr kaml\r\n)))))) (patrRule (ruleKW rule) (ruleIdentifier { P' option 1adj - prepositions, adjective }) (phraseStructureRule (nonTerminal P') (ruleDef =) (rightHandSide (nonTerminal P) (nonTerminal AdjP))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P') (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal P) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P') (featurePath (atomicValue head) (featurePath (atomicValue rootgloss))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal P) (featurePath (atomicValue rootgloss)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P') (featurePath (atomicValue head) (featurePath (atomicValue gloss))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal P) (featurePath (atomicValue gloss)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue PP-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal AdjP) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue stranded)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment |- not missing a complement\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | added 17Feb03 CB - changed to direct 12Aug2019\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue prefix_Prep)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | added 17Feb03 CB\r\n)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal P) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifier-final)))) (closingWedge >)) <= (priorityUnionRightHandSide (atomicValue +)) (comment | added 17Feb03 CB\r\n))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal P') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal AdjP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal P) (closingWedge >)) == (logConstraintExpression ~ (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue rootgloss)) : (featureStructureValue (atomicValue for)) (closingBracket ]) (comment | benefactors use option benefactorPP\r\n)))))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal P) (closingWedge >)) == (logConstraintExpression ~ (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue gloss)) : (featureStructureValue (atomicValue for)) (closingBracket ]) (comment | benefactors use option benefactorPP\r\n)))))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P') (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 1adj)))))) (patrRule (ruleKW rule) (ruleIdentifier { P' option 2a - prepositions, IP complement }) (phraseStructureRule (nonTerminal P') (ruleDef =) (rightHandSide (nonTerminal P) (optionalTerminals ( (nonTerminal N) )) (nonTerminal IP))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P') (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal P) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P') (featurePath (atomicValue head) (featurePath (atomicValue rootgloss))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal P) (featurePath (atomicValue rootgloss)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P') (featurePath (atomicValue head) (featurePath (atomicValue gloss))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal P) (featurePath (atomicValue gloss)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue PP-initial)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue prefix_Prep)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue suffix_Pn)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue root)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue root)))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue question)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue mood) (featurePath (atomicValue imperative))))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue participle)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | restrict participle within IP\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue copular)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue initialP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | restrict InitP within IP complement \r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue conj_suffix)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not h2 13Mar03 CB per Ron\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relcl)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | not a rel clause 21Nov03 CB\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue stranded)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment |- not missing a complement\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue sentential)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal N) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue oblique)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal P') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal IP) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal P) (closingWedge >)) == (logConstraintExpression ~ (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue rootgloss)) : (featureStructureValue (atomicValue for)) (closingBracket ]) (comment | benefactors use option benefactorPP\r\n)))))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal P) (closingWedge >)) == (logConstraintExpression ~ (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue gloss)) : (featureStructureValue (atomicValue for)) (closingBracket ]) (comment | benefactors use option benefactorPP\r\n)))))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P') (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 2a)))))) (patrRule (ruleKW rule) (ruleIdentifier { P' option bh-I - prefixed to oblique, complement required } P' = P DP < P' head > = < P head > < P' head rootgloss > = < P rootgloss > < P' head gloss > = < P gloss > < P head type comma > = - < P head type passive > = + < P head case > = oblique < P head type prefix_Prep > = + < P head type suffix_Pn > = - < P' head reflexive > = < DP head reflexive > | pass reflexive info\r\n < P' head object > = < DP > |- for passive, etc.\r\n < DP head type DO_contraction > = - < DP head case_for_position > = direct | to know normal case for conjoined DPs\r\n < DP head case > = direct < P' head type stranded > = - |- not missing a complement\r\n < DP head participle > = none | trying to restrict participles 12-APR-04\r\n < DP head possessor head participle > = none | trying to restrict participles 12-APR-04\r\n < DP head type nonfinalcoordination > = - < DP > == ~ [ mother_node : - ] | if coordination, must be allowed initially\r\n < DP > == [ mother_node : + ] -> [ head : [ type : [ coordination : + ] ] ] |and be complete\r\n < DP head type > == [ relative : + ] -> [ relcl : + ] | require rel suffix to only occur when relative clause present\r\n < P' head type comma > <= < DP head type comma > < P' rule > = bh-I rule { P' option bh-II - prefixed to N, Pn or Dem complement so full PP }) (phraseStructureRule (nonTerminal P') (ruleDef =) (rightHandSide (nonTerminal P))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P') (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal P) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P') (featurePath (atomicValue head) (featurePath (atomicValue rootgloss))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal P) (featurePath (atomicValue rootgloss)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P') (featurePath (atomicValue head) (featurePath (atomicValue gloss))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal P) (featurePath (atomicValue gloss)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue passive)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue prefix_Prep)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue stranded)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment |- not missing a complement\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P') (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue bh-II) (comment |added 15Jul03 CB\r\n)))))) (patrRule (ruleKW rule) (ruleIdentifier { P' option pn-sf - pronoun suffixed to P so full PP }) (phraseStructureRule (nonTerminal P') (ruleDef =) (rightHandSide (nonTerminal P))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P') (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal P) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P') (featurePath (atomicValue head) (featurePath (atomicValue rootgloss))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal P) (featurePath (atomicValue rootgloss)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P') (featurePath (atomicValue head) (featurePath (atomicValue gloss))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal P) (featurePath (atomicValue gloss)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue passive)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue suffix_Pn)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P') (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue stranded)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment |- not missing a complement\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal P') (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue pn-sf) (comment |-***********************************************************\r\n)))))) (patrRule (ruleKW rule) (ruleIdentifier { QP option 2 as Numbers - modifiers final }) (phraseStructureRule (nonTerminal QP) (ruleDef =) (rightHandSide (nonTerminal NumP) (optionalTerminals ( (nonTerminal Q) )) (optionalTerminals ( (nonTerminal Adj) )))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal QP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal NumP) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Adj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue ordinal)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Adj) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal QP) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal QP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 2)))))) (patrRule (ruleKW rule) (ruleIdentifier { QP option Q alone }) (phraseStructureRule (nonTerminal QP) (ruleDef =) (rightHandSide (nonTerminal Q))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal QP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal Q) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal QP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue Q)))))) (patrRule (ruleKW rule) (ruleIdentifier { NumP option number ( optional classifier ) }) (phraseStructureRule (nonTerminal NumP) (ruleDef =) (rightHandSide (nonTerminal Num) (optionalTerminals ( (nonTerminal NumCl) )))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal NumP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal Num) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal NumCl) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal NumP) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal NumP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue number) (comment | RL 5Feb02 classifier alone.\r\n)))))) (patrRule (ruleKW rule) (ruleIdentifier { NumCl option numberCl }) (phraseStructureRule (nonTerminal NumP) (ruleDef =) (rightHandSide (nonTerminal NumCl))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal NumP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal NumCl) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal NumP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue numberCl)))))) (patrRule (ruleKW rule) (ruleIdentifier { NumP as compound }) (phraseStructureRule (nonTerminal NumP) (ruleDef =) (rightHandSide (nonTerminal NumP_1) (nonTerminal Conj) (nonTerminal NumP_2))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal NumP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal NumP_1) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal NumP) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment |RL 5Feb02 limit recursion to right node only.\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal NumP_1) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal NumP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue compound) (comment |-***********************************************************\r\n)))))) (patrRule (ruleKW rule) (ruleIdentifier { AdjP option 0 - conjoined }) (phraseStructureRule (nonTerminal AdjP) (ruleDef =) (rightHandSide (nonTerminal AdjP_1) (nonTerminal Conj) (nonTerminal AdjP_2))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal AdjP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal AdjP_2) (featurePath (atomicValue head)) (closingWedge >) (comment | make right-headed for case marking 03Apr03\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal AdjP) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +) (comment | limit recursion to left node only\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal AdjP_2) (featurePath (atomicValue conjoined)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal AdjP_1) (featurePath (atomicValue head) (featurePath (atomicValue case))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue direct) (comment | unmarked except final\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Conj) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue conjoins_DP)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal AdjP_1) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue relative)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment | intial conjunct not marked with REL\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal AdjP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 0)))))) (patrRule (ruleKW rule) (ruleIdentifier { AdjP option 2 - degree modifiers initial }) (phraseStructureRule (nonTerminal AdjP) (ruleDef =) (rightHandSide (optionalTerminals ( (nonTerminal Deg) )) (nonTerminal Adj))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal AdjP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal Adj) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue modifies_Adj)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue +)))) (constraint (priorityUnionConstraint (priorityUnionLeftHandSide (openingWedge <) (nonTerminal AdjP) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue polarity)))) (closingWedge >)) <= (priorityUnionRightHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue infl) (featurePath (atomicValue polarity)))) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal AdjP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 2) (comment |-***********************************************************\r\n)))))) (patrRule (ruleKW rule) (ruleIdentifier { AdvP option 1 - no modifiers }) (phraseStructureRule (nonTerminal AdvP) (ruleDef =) (rightHandSide (nonTerminal Adv))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal AdvP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal Adv) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal AdvP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 1)))))) (patrRule (ruleKW rule) (ruleIdentifier { AdvP option 2 - modifiers initial }) (phraseStructureRule (nonTerminal AdvP) (ruleDef =) (rightHandSide (nonTerminal Deg) (nonTerminal Adv))) (constraints (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal AdvP) (featurePath (atomicValue head)) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal Adv) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head) (featurePath (atomicValue type) (featurePath (atomicValue comma)))) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue -) (comment |    <Deg head type modifies_Adv> = <Adv head type>  |replace this with the following Apr2020\r\n)))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal AdvP) (featurePath (atomicValue head) (featurePath (atomicValue modifier) (featurePath (atomicValue head)))) (closingWedge >)) = (uniConstraintRightHandSide (openingWedge <) (nonTerminal Deg) (featurePath (atomicValue head)) (closingWedge >)))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal AdvP) (featurePath (atomicValue head)) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue type)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue manner)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue modifier)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue type)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue modifies_Adv)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue manner)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ])))))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal AdvP) (featurePath (atomicValue head)) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue type)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue temporal)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue modifier)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue type)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue modifies_Adv)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue temporal)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ])))))) (constraint (logicalConstraint (logConstraintLeftHandSide (openingWedge <) (nonTerminal AdvP) (featurePath (atomicValue head)) (closingWedge >)) == (logConstraintExpression (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue type)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue locative)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (closingBracket ]))) (binop ->) (logConstraintFactor (featureStructure (openingBracket [) (featureStructureName (atomicValue modifier)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue head)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue type)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue modifies_Adv)) : (featureStructureValue (featureStructure (openingBracket [) (featureStructureName (atomicValue locative)) : (featureStructureValue (atomicValue +)) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ]))) (closingBracket ])))))) (constraint (unificationConstraint (uniConstraintLeftHandSide (openingWedge <) (nonTerminal AdvP) (featurePath (ruleKW rule)) (closingWedge >)) = (uniConstraintRightHandSide (atomicValue 2))))))) <EOF>)